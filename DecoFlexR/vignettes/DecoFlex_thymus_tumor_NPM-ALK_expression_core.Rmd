---
title: "DecoFlex_thymus_tumor_NPM-ALK_expression_core"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DecoFlex_thymus_tumor_NPM-ALK_expression_core}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r basic.configurations, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


**Computational Epigenomics Research group:** [epi-logos.com](https://epi-logos.com/)

# Introduction (vignette #2)

Wi will refer to some code, documentation and plots from this: https://github.com/crhisto/thymus_NPM-ALK_notebook

This tutorial will cover the following content:

```{r function.import.libraries}
#Function to install and load libraries
check_install_load_library <- function(library_name, type = 'BiocManager' ){
  
  if(type == 'BiocManager'){
    if(library_name %in% rownames(installed.packages())){
      library(library_name, character.only=TRUE)
    }else{
      BiocManager::install(library_name)
      library(library_name, character.only=TRUE)
    }
  }
  
}
```

```{r setup}
library(DecoFlex)
environment <- 'server'

if(environment == 'desktop'){
  reticulate::py_install(envname="~/miniconda3/envs/r_DecoFlex", packages="/Users/crhisto/Documents/GitHub/NMMFlex/NMMFlexPy", pip=TRUE)
}else{
  reticulate::py_install(envname="~/anaconda3/envs/r_DecoFlex", packages="/mnt_volumen/GIT_REPOSITORIES/NMMFlex/NMMFlexPy", pip=TRUE)
}

```

TODO create function to install differents and load.
First, we have to install 2 libraries that have been modified in order to use sparse matrices in R: [Biobase](https://github.com/Bioconductor/Biobase) and [xbioc](https://github.com/renozao/xbioc). Then we imported a modified version of the library [SCDC](https://meichendong.github.io/SCDC/articles/SCDC.html) that has been modified to support: sparse matrices, parallelism, and Dynamic threshold for markers selection, among other improvements. Finally, we imported the general libraries required to run the complete pipeline.
```{r importing_libraries, include=FALSE}
if (!require("devtools")) {
  install.packages("devtools")
}

#Check Biobase modified installation
if("Biobase" %in% rownames(installed.packages())){
  library(Biobase)
}else{
  devtools::install_github( repo = "crhisto/Biobase" )
  library(Biobase)
}

#Check xbioc modified installation
if("xbioc" %in% rownames(installed.packages())){
  library(xbioc)
}else{
  devtools::install_github( repo = "crhisto/xbioc" )
  library(xbioc)
}

#Check hdf5r installation
if("hdf5r" %in% rownames(installed.packages())){
  library(hdf5r)
}else{
  #install the package hdf5r
  #Use the following command in ubuntu linux: sudo apt-get install libhdf5-dev
  install.packages("hdf5r")
  library(hdf5r)
}

if("methylKit" %in% rownames(installed.packages())){
  library(methylKit)
}else{
  BiocManager::install("methylKit")
  library(methylKit)
}

if("dendextend" %in% rownames(installed.packages())){
  library(dendextend)
}else{
  install.packages('dendextend')
  library(dendextend)
}



if("SeuratDisk" %in% rownames(installed.packages())){
  library(SeuratDisk)
}else{
  remotes::install_github("mojaveazure/seurat-disk")
  library(SeuratDisk)
}



#for deconvolution SCDC library
library(pheatmap)
library(foreach)
library(doParallel)
library(Seurat)
library(fpc)
library(tidyverse)
library(fpc)
library(stringr)
library(dbscan)
library(slam)
library(dplyr)
library(ggplot2)
library(reshape2)
library(DESeq2)
library(BiocGenerics)
library(Matrix)
library(SeuratDisk)
library(methylKit)
library(gplots)
```

# 1. Data adquisition

First let's load the bulk and single-cell data from thymus using the github repository
```{bash downloading_data, eval=FALSE, include=FALSE}
mkdir data_thymus
cd data_thymus
#downloading the scRNA-seq dataset
wget https://zenodo.org/record/3711134/files/thymus_annotated_matrix_files.zip
unzip thymus_annotated_matrix_files.zip

#downloading the bulk RNA-seq dataset
wget https://raw.githubusercontent.com/crhisto/thymus_NPM-ALK_notebook/master/data/eset.thymus.bulk.sparse.RData.zip
unzip eset.thymus.bulk.sparse.RData.zip
```

Importing of the bulk data with the 12 samples in a ESET object type supporting sparse matrices.
```{r import_bulk_data_object}
path.data <- paste0(getwd(), '/', 'data_thymus/')
load(paste0(path.data, "eset.thymus.bulk.sparse.RData"))
eset.thymus.bulk.sparse
```

```{bash installing.anndata}
pip install anndata
```


```{python convertion.h3ad}

import anndata
anndata
adata = anndata.read("/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/data_thymus/HTA08.v02.A04.Science_mouse_total.h5ad")
adata.write("/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/data_thymus/HTA08.v02.A04.Science_mouse_total.zip.h5ad", compression="gzip")

```


Importing data for the single cell dataset and creation of the corresponding seurat objects for both: the complete set of time points and the last 3 time points ('4W','8W','24W').
```{r creating_seural_scRNA_seq_data}
path.data.sc <- paste0(path.data, "") 


#convert
string_converted <- SeuratDisk::Convert(paste0(path.data.sc, "HTA08.v02.A04.Science_mouse_total.zip.h5ad"),
                                         overwrite = TRUE, dest = "h5seurat", assay = "RNA")
#locad
seurat_object.all <- SeuratDisk::LoadH5Seurat(string_converted, meta.data = FALSE)

# I get all the columns for all tisue samples for all experiments.
annotations.all <- read.table(paste0(path.data.sc, "HTA08.v02.A04.Science_mouse_total.csv"), 
                 header = TRUE,
                 sep = ",")

#I get the names of the cell types (clusters) to create the dataset
paste(shQuote(sort(unique(annotations.all$cell.types))), collapse=", ")
paste(shQuote(sort(unique(annotations.all$age))), collapse=", ")

cluster_list.thymus <- data.frame(cell.types = c('aDC', 'B', 'CD4+T', 'CD8+T', 'cTEC', 'DC1', 'DC2', 'DN(P)', 'DN(Q)', 'DP(P)', 'DP(Q)', 'Endo', 'Epi_unknown', 'Ery', 'Fb', 'HSC', 'IELpA', 'IELpB/NKT', 'Mac', 'Mono', 'mTEC', 'NK', 'NMP', 'pDC', 'TEC_early', 'Treg', 'VSMC', 'αβT(entry)', 'γδT'), cluster_normalized = paste0('cluster_', 1:29), cluster_order = as.numeric(c(1:29)))

#I add the cluster normalized for avoiding problems with names and special characters
annotations.all <- annotations.all %>% inner_join(cluster_list.thymus, by = "cell.types")

#I add the information from the annotations to the seurat object
seurat_object.all@meta.data$index_cell_id <- annotations.all$index
seurat_object.all@meta.data$cell_types_name <- annotations.all$cell.types
seurat_object.all@meta.data$stage <- annotations.all$stage
seurat_object.all@meta.data$age <- annotations.all$age
seurat_object.all@meta.data$sample_id <- annotations.all$sample_id
seurat_object.all@meta.data$cluster_normalized <- annotations.all$cluster_normalized

#Assign the identity
Idents(seurat_object.all) <- seurat_object.all$age

seurat_object.all <- subset(seurat_object.all, idents = c('E12', 'E13', 'E14', 'E15', 'E16', 'E17', 'E18', 'P0', '4W','8W','24W'))

#add filter of samples in the seurat object
seurat_object.4w_8w_24w <- subset(seurat_object.all, idents = c('4W','8W','24W'))

#create the count matrix base on the seurat object
counts.thymus.4w_8w_24w <- create_count_matrix(seurat_object.4w_8w_24w)
counts.thymus.all <- create_count_matrix(seurat_object.all)
```

Creation of object with the scRNA-seq data for the deconvolution
```{r create_eset_scrna_reference, echo = T, results = 'hide'}
#Use the function to create the sparse eset object
eset.sc.thymus.4.sparse <- create_sparse_eset_object(counts.thymus.4w_8w_24w, seurat_object.4w_8w_24w)
head(eset.sc.thymus.4.sparse)

eset.sc.thymus.4.sparse.all <- create_sparse_eset_object(counts.thymus.all, seurat_object.all)
head(eset.sc.thymus.4.sparse.all)

#Fixing the samples names staring with numbers. Instead I will add the string: 'sample_' to fix it
eset.sc.thymus.4.sparse_fixed <- eset.sc.thymus.4.sparse
eset.sc.thymus.4.sparse_fixed$age <- paste0('sample_', eset.sc.thymus.4.sparse_fixed$age)

```

# 2. Deconvolution with automatic hierarchy and simulation

Se can see that this has to be improve with the intra-checking that is missing. This is not the optimal configuration.
```{r deconvolution.hierarchical.multi.level.schema.automatic.selection}

#Parameters for the execution
single_cell_data_exp <- eset.sc.thymus.4.sparse_fixed
sub_clusters_var <- 'cluster_normalized'
sample <- 'age'
subset_celltypes <-  paste0('cluster_', c(8,9,10,11,28,4,3))
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#Running the process that automatically selects the hierarchy and runs the deconvolution.
deco.simul.auto.hierarchy.selection.thymus <- hierachy_selection_plus_deconvolution(
  single_cell_data_exp = single_cell_data_exp,
  var_cell_type = sub_clusters_var,
  subset_celltypes = subset_celltypes,
  number_clusters_one_celltype = 1,
  min_size_leaf = 4,
  var_sample = sample,
  random_seed = NULL, 
  use_min_cor_strategy = use_min_cor_strategy, 
  delete_shared_level_markers = delete_shared_level_markers, 
  delete_shared_internal_markers = delete_shared_internal_markers, 
  filter_markers = NULL,
  param.logfc.threshold = 0.7, 
  param.p_val_adj = 0.05,
  filter_main_markers = FALSE,
  verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

#3. Manual hierarchy analysis 

```{r correlation.thymus, fig.width=10, fig.height=10}
#I create the reference of all celltypes
reference_w.7.celltypes.thymus <- create_basis_multiple(x = eset.sc.thymus.4.sparse,
                                            ct.sub = paste0('cluster_', c(8,9,10,11,28,4,3)),
                                            ct.varname = 'cluster_normalized',
                                            sample = 'age')

#TODO check if this is the same function...
reference.thymus <- decoflex_build_cell_reference(x = eset.sc.thymus.4.sparse, 
                                                  ct.varname =sub_clusters_var, 
                                                  sample = 'age')

color_gradient <- colorRampPalette(c("white","steelblue"))

reference_w.7.celltypes.thymus.with.names <- reference_w.7.celltypes.thymus$basis.mvw[, paste0('cluster_', c(8,9,10,11,28,4,3))]
colnames(reference_w.7.celltypes.thymus.with.names) <- cluster_list.thymus$cell.types[c(8,9,10,11,28,4,3)]

cor.reference_matrix_w.7.celltypes.thymus <- cor(reference_w.7.celltypes.thymus.with.names)
gplots::heatmap.2(cor.reference_matrix_w.7.celltypes.thymus,
                  cellnote = round(cor.reference_matrix_w.7.celltypes.thymus, 2), 
                  trace="none",
                  col=color_gradient(10),
                  breaks=seq(0,1,0.1),
                  margins=c(12,12), 
                  cexRow = 1, cexCol = 1, 
                  dendrogram = "both", 
                  key=FALSE)

```

Let's try to see how is the hierarchy in the original dataset.
```{r hierarchy.analysis}

# Finding distance matrix
distance_mat <- dist(t(cor(reference_w.7.celltypes.thymus.with.names)), method = 'euclidean')
#distance_mat <- dist(t(cor(reference_w.7.celltypes.thymus$basis)), method = 'euclidean')

distance_mat <- dist(t(log(reference_w.7.celltypes.thymus$basis + 1e-10)), method = 'euclidean')

x$basis.mvw

# Fitting Hierarchical clustering Model
# to training dataset
set.seed(240)  # Setting seed,  "complete", "average"
Hierar_cl <- hclust(distance_mat, method = "average")
#Hierar_cl
 
# Plotting dendrogram
plot(Hierar_cl)
 
# Choosing no. of clusters
# Cutting tree by height
abline(h = 110, col = "green")
 
# Cutting tree by no. of clusters
fit_7_celltypes.thymus <- cutree(Hierar_cl, k = 3 )
fit_7_celltypes.thymus
 
table(fit_7_celltypes.thymus)
rect.hclust(Hierar_cl, k = 3, border = "green")
 
```


#4. Creation of manual hierarchy

```{r hierarchy.creation}

#Binary hierarchy.
hierarchical_clustering_sc_thymus.v1 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(8,9,10,11,28,4,3)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(11, 28, 4, 3)), next_level_clustering=list(
               '1'=list(tree_level=2, leaf_number=1, celltype_list=paste0('cluster_', c(11, 28)), next_level_clustering=NULL), 
               '2'=list(tree_level=2, leaf_number=2, celltype_list=paste0('cluster_', c(4, 3)), next_level_clustering=NULL)
             )), 
             '2'=list(tree_level=1, leaf_number=2, celltype_list=paste0('cluster_', c(8, 9, 10)), next_level_clustering=NULL)
           )
  )
)

#Binary hierarchy with pair separations. Good signal of double negative
hierarchical_clustering_sc_thymus.v2 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(8,9,10,11,28,4,3)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(8, 9, 10, 11, 28)), next_level_clustering=list(
               '1'=list(tree_level=2, leaf_number=1, celltype_list=paste0('cluster_', c(8, 9)), next_level_clustering=NULL), 
               '2'=list(tree_level=2, leaf_number=2, celltype_list=paste0('cluster_', c(10, 11, 28)), next_level_clustering=NULL)
             )), 
             '2'=list(tree_level=1, leaf_number=2, celltype_list=paste0('cluster_', c(4, 3)), next_level_clustering=NULL)
           )
  )
)

#Three main groups.
hierarchical_clustering_sc_thymus.v3 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(8,9,10,11,28,4,3)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(8, 9)), next_level_clustering=NULL), 
             '2'=list(tree_level=1, leaf_number=2, celltype_list=paste0('cluster_', c(10, 11, 28)), next_level_clustering=NULL), 
             '3'=list(tree_level=1, leaf_number=3, celltype_list=paste0('cluster_', c(4, 3)), next_level_clustering=NULL)
           )
  )
)

#Four main groups.
hierarchical_clustering_sc_thymus.v4 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(8,9,10,11,28,4,3)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(8, 9)), next_level_clustering=NULL), 
             '2'=list(tree_level=1, leaf_number=2, celltype_list=paste0('cluster_', c(10, 11)), next_level_clustering=NULL), 
             '3'=list(tree_level=1, leaf_number=3, celltype_list=paste0('cluster_', c(28)), next_level_clustering=NULL), 
             '4'=list(tree_level=1, leaf_number=4, celltype_list=paste0('cluster_', c(4, 3)), next_level_clustering=NULL)
           )
  )
)

#Binary hierarchy with pair separations. Good signal of double negative
hierarchical_clustering_sc_thymus.v5 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(8,9,10,11,28,4,3)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(8, 9, 10, 11)), next_level_clustering=list(
               '1'=list(tree_level=2, leaf_number=1, celltype_list=paste0('cluster_', c(8, 9)), next_level_clustering=NULL), 
               '2'=list(tree_level=2, leaf_number=2, celltype_list=paste0('cluster_', c(10, 11)), next_level_clustering=NULL)
             )), 
             '2'=list(tree_level=1, leaf_number=2, celltype_list=paste0('cluster_', c(4, 3, 28)), next_level_clustering=NULL)
           )
  )
)

```

#5. Deconvolution with simulation

```{r deconvolution.simulation}
detach(package:DecoFlex,unload=TRUE)
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.4.sparse_fixed
hierarchy = hierarchical_clustering_sc_thymus.v2
sub_clusters_var <- 'cluster_normalized'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE


start_time <- Sys.time()

#let's run de simulation
deco.simulation.oligo.tree_guided.recursive.results <- 
  run_deconvolution_simulation_generic_recursive(single_cell_data_exp = single_cell_data_exp, 
                                                 hierarchy = hierarchy,
                                                 sub_clusters_var = sub_clusters_var,
                                                 sample = sample, 
                                                 use_min_cor_strategy = use_min_cor_strategy, 
                                                 delete_shared_level_markers = delete_shared_level_markers, 
                                                 delete_shared_internal_markers = delete_shared_internal_markers,
                                                 param.logfc.threshold = 0.7,
                                                 param.p_val_adj = 0.05,
                                                 verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

## 5.1. Actual proportions and correlation

```{r actual.proportions.correlations}

#Create pseudo 
pseudo.bulk.data.thymus <- generateBulk_allcells(single_cell_data_exp,
                                            ct.varname = sub_clusters_var,
                                            sample = sample,
                                            ct.sub = NULL,
                                            verbose = TRUE)

order_normalized <- paste0('cluster_', c(8,9,10,11,28,4,3))
order_samples <- c('sample_4W','sample_8W','sample_24W')
list_pseudotime <- c('DN(P)', 'DN(Q)', 'DP(P)', 'DP(Q)', 'αβT(entry)', 'CD8+T', 'CD4+T')

#Calculate the proportion for clusters for 7 clusters
real_proportion <- as.data.frame.matrix(pseudo.bulk.data.thymus$truep)

real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]

real_proportion.pseudotime.rescaled <- NULL
for(counter in 1:nrow(real_proportion.pseudotime)){
  new_row <- real_proportion.pseudotime[counter,]/sum(real_proportion.pseudotime[counter,])
  real_proportion.pseudotime.rescaled <- rbind(real_proportion.pseudotime.rescaled, new_row)
}

#just checking. Everything should sum up 1.
rowSums(real_proportion.pseudotime.rescaled)
#Adding names
colnames(real_proportion.pseudotime.rescaled) <- list_pseudotime


#Now lest compare with the calculated proportions from the pseudo bulk data.
proportions_calculated_pseudo_bulk <- t(deco.simulation.oligo.tree_guided.recursive.results$result_deco$back_propagation_proportions_top_detailed[order_normalized, order_samples])
colnames(proportions_calculated_pseudo_bulk) <- list_pseudotime

# By celltype
cor(real_proportion.pseudotime.rescaled, proportions_calculated_pseudo_bulk)

#By sample
cor(t(real_proportion.pseudotime.rescaled), t(proportions_calculated_pseudo_bulk))

#Creation dataframes for individual correlation
proportions_calculated_pseudo_bulk.df <- data.frame(t(proportions_calculated_pseudo_bulk))
real_proportion.pseudotime.rescaled.df <- data.frame(t(real_proportion.pseudotime.rescaled))

#0.8796212
cor(proportions_calculated_pseudo_bulk.df$sample_4W, real_proportion.pseudotime.rescaled.df$sample_4W, method = c("pearson"))
#0.877927
cor(proportions_calculated_pseudo_bulk.df$sample_8W, real_proportion.pseudotime.rescaled.df$sample_8W, method = c("pearson"))

#0.921099
cor(proportions_calculated_pseudo_bulk.df$sample_24W, real_proportion.pseudotime.rescaled.df$sample_24W, method = c("pearson"))

```


# 6. Deconvolution with manual hierarchy

Now we will run the deconvolution with the actual bulk dataset from Thymus experiment.
```{r deconvolution.manual.hierarchy}
library(DecoFlex)


order_normalized <- paste0('cluster_', c(8,9,10,11,28,4,3))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.00000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.00000001


#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.4.sparse_fixed
hierarchy = hierarchical_clustering_sc_thymus.v5$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'cluster_normalized'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.results <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 0.3, # 0.2
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 30,
                                          min_delta_cor_threshold = 0.0, 
                                          verbose = TRUE)
# Time difference of 37.13297 mins 0.2, 00
end_time <- Sys.time()
end_time - start_time
```

##6.1. Plot real proportions vs WT

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion}

order_normalized <- paste0('cluster_', c(8,9,10,11,28,4,3))
order_samples <- c('sample_4W','sample_8W','sample_24W')
list_pseudotime <- c('DN(P)', 'DN(Q)', 'DP(P)', 'DP(Q)', 'αβT(entry)', 'CD8+T', 'CD4+T')

#Calculate the proportion for clusters for 7 clusters
real_proportion <- as.data.frame.matrix(deco.simulation.oligo.tree_guided.recursive.results$pseudo.bulk.data$truep)
real_proportion <- real_proportion['sample_24W',]

real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]

real_proportion.pseudotime.rescaled <- NULL
for(counter in 1:nrow(real_proportion.pseudotime)){
  new_row <- real_proportion.pseudotime[counter,]/sum(real_proportion.pseudotime[counter,])
  real_proportion.pseudotime.rescaled <- rbind(real_proportion.pseudotime.rescaled, new_row)
}

#just checking. Everything should sum up 1.
rowSums(real_proportion.pseudotime.rescaled)
#Adding names
colnames(real_proportion.pseudotime.rescaled) <- list_pseudotime


# A. wt data from deconvolution with tree hierarchy
#wt_data <- t(deco.actual.data.thymus.results$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')])

#B. wt data from flat configuration
wt_data <- t(deco.actual.data.thymus.flat.results$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')])

#C. Data from expression and methylation model
#wt_data <- t(better_model.thymus$h[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')])

#D. Data from expression, methylation, Z matrix.
#wt_data <- t(model.alpha.beta.op.thymus$h[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')])

#E. Data from expression, methylation: partial
#wt_data <- t(deco.alpha.beta.zero.results$h[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')])


wt_data <- data.frame(wt_data)
colnames(wt_data) <- list_pseudotime


#Joinning the bulk data wt
comparison_real_vs_deconvolution <- rbind(wt_data, real_proportion.pseudotime.rescaled)


thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))

thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))


thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)

thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_KO'] <- 'KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'Thy_ALKpos_KO'] <- 'ALKKO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_4W'] <- '4w_thymus')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_8W'] <- '8w_thymus')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_24W'] <- '24w_thymus')

##thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO', 'ALK', 'ALKKO', '4w_thymus', '8w_thymus', '24w_thymus'))

thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl','4w_thymus', '8w_thymus', '24w_thymus'))

#real proportion vs control
thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)

p <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% c('4w_thymus','8w_thymus', '24w_thymus', 'Ctrl') & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
  geom_point(size=6, shape=20, alpha = .40, position=position_jitter(width=.3,height=.00)) +
  labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text=element_text(size=16),
        legend.title = element_text(size = 16),
          legend.text = element_text(size = 16)) + 
  ylim(0, 1.0)
 
p +  scale_color_manual(name = "Sample", breaks = c('4w_thymus', '8w_thymus', '24w_thymus', 'Ctrl'), values = c("turquoise3", "bisque2", "darkgrey", "#136c38")) + theme_light()
```
## 6.2. Plot real proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion}
order_normalized <- paste0('cluster_', c(8,9,10,11,28,4,3))
order_samples <- c('sample_4W','sample_8W','sample_24W')
list_pseudotime <- c('DN(P)', 'DN(Q)', 'DP(P)', 'DP(Q)', 'αβT(entry)', 'CD8+T', 'CD4+T')

#Calculate the proportion for clusters for 7 clusters
real_proportion <- as.data.frame.matrix(deco.simulation.oligo.tree_guided.recursive.results$pseudo.bulk.data$truep)

real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]

real_proportion.pseudotime.rescaled <- NULL
for(counter in 1:nrow(real_proportion.pseudotime)){
  new_row <- real_proportion.pseudotime[counter,]/sum(real_proportion.pseudotime[counter,])
  real_proportion.pseudotime.rescaled <- rbind(real_proportion.pseudotime.rescaled, new_row)
}

#just checking. Everything should sum up 1.
rowSums(real_proportion.pseudotime.rescaled)
#Adding names
colnames(real_proportion.pseudotime.rescaled) <- list_pseudotime


# A. Normal deconvolution: All experiments
#experimental_data <- t(deco.actual.data.thymus.results$back_propagation_proportions_top_detailed[order_normalized, ])

# B. flat model
experimental_data <- t(deco.actual.data.thymus.flat.results$result_deco_top_cluster$h[order_normalized, ])

# C. Expression and methylation data.
#experimental_data <- t(better_model.thymus$h[order_normalized, ])

# D. Data from expression, methylation, Z matrix.
#experimental_data <- t(model.alpha.beta.op.thymus$h[order_normalized, ])

# E. Data from expression, methylation: partial model
#experimental_data <- t(deco.alpha.beta.zero.results$h[order_normalized, ])



experimental_data <- data.frame(experimental_data)
colnames(experimental_data) <- list_pseudotime


#Joining the bulk data wt
comparison_real_vs_deconvolution <- rbind(experimental_data, real_proportion.pseudotime.rescaled)


thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))

thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))


thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)

thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_KO'] <- 'KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'Thy_ALKpos_KO'] <- 'ALKKO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_4W'] <- '4w_thymus')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_8W'] <- '8w_thymus')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_24W'] <- '24w_thymus')

thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO', 'ALK', 'ALKKO', '4w_thymus', '8w_thymus', '24w_thymus'))

#thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO'))

#real proportion vs control
thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)

p <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% c('Ctrl', 'KO', 'ALK', 'ALKKO') & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
  geom_point(size=6, shape=20, alpha = .50, position=position_jitter(width=.3,height=.00)) +
  labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text=element_text(size=16),
        legend.title = element_text(size = 16),
          legend.text = element_text(size = 16)) + 
  ylim(0, 1.0)
 
p +  scale_color_manual(name = "Sample", breaks = c('4w_thymus', '8w_thymus', '24w_thymus', 'Ctrl', 'KO', 'ALK', 'ALKKO'), values = c("turquoise3", "bisque2", "darkgrey", "#136c38", "blue", "red", "orange")) + theme_light()
```

# 7. Deconvolution with methylation data

## 7.1 Methylation data

Now I will import the methylation data. Check this: https://nbis-workshop-epigenomics.readthedocs.io/en/latest/content/tutorials/methylationSeq/Seq_Tutorial.html
```{r import.methylation.data}

load('data_thymus/meth/MethylKitDiffs.rData')

# Now I will get the object with all samples, filter it and join the samples
methylation.filtered <- filterByCoverage(myobj, lo.count=10, lo.perc=NULL, hi.count=NULL, hi.perc=99.9)
methylation.filtered.norm <- normalizeCoverage(methylation.filtered, method = "median")
methylation.filtered.united <- methylKit::unite(methylation.filtered.norm, destrand=FALSE)
perc.meth.thymus <- percMethylation(methylation.filtered.united)/100

# Adding identifiers to be able to create Z matrix and make comparisons 
# with other references
rownames(perc.meth.thymus) <- paste0('cg_', methylation.filtered.united$start)
perc.meth.thymus <- data.frame(perc.meth.thymus)
perc.meth.thymus$chr <- methylation.filtered.united$chr
perc.meth.thymus$start <- methylation.filtered.united$start
perc.meth.thymus$end <- methylation.filtered.united$end
perc.meth.thymus$strand <- methylation.filtered.united$strand

# Let's rename the samples to be compatible with the bulk data
# The original order: "C1","C2","C3","KO1","KO2","KO3","Tu1","Tu2","Tu3","AlkKO1","AlkKO2","AlkKO3"
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")
                     
colnames(perc.meth.thymus) <- c(standard_name_thymus, c('chr', 'start', 'end', 'strand'))

#Finally I have the methylation level for each CpG and each sample
summary(perc.meth.thymus)
nrow(perc.meth.thymus)
ncol(perc.meth.thymus)

#Lets save the data in the final state.
#save(perc.meth.thymus, file = "data_thymus/meth/methylation_thymus_12_samples.rData")
#load(file = "data_thymus/meth/methylation_thymus_12_samples.rData")

hist(as.matrix(perc.meth.thymus[,standard_name_thymus]), main = 'Histogram Methylation')

```
Filtering of the methylation data
```{r methylation.filters}

#load(file = "data_thymus/meth/methylation_thymus_12_samples.rData")

perc.meth.thymus.df <- data.frame(perc.meth.thymus)

nrow(perc.meth.thymus.df) #34164

filter_activated <- FALSE

if(filter_activated){
  # 1. filter rows with zero and ones
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df %>% filter(rowSums(across(where(is.numeric)))!=0) # 33678 rows
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df.filtered %>% filter(rowSums(across(where(is.numeric)))!=1) # 33678 rows
  
  # 2. filter rows with at least 1 zero: 28.296
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df.filtered[apply(perc.meth.thymus.df.filtered,1, function(x) all(x!=0)),]
  
  
  # 3. filter if four have zero 29.244
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df.filtered[apply(perc.meth.thymus.df.filtered,1, function(x) sum(x==0, na.rm=TRUE) < 4),]
  
  # 4.filtering of values iqual zero and values equal 1.
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df.filtered[apply(perc.meth.thymus.df.filtered,1, function(x) sum(x==0, na.rm=TRUE) <= 0),] # 27.296 rows
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df.filtered[apply(perc.meth.thymus.df.filtered,1, function(x) sum(x==1, na.rm=TRUE) <= 0),]# 8.042 rows
  
}else{
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df
}

```

Now I will take the methylation data and relate it with genes.
```{r methylation.join.genes}
check_install_load_library('BSgenome.Mmusculus.UCSC.mm10')
check_install_load_library('org.Mm.eg.db')
check_install_load_library('GenomicFeatures')
check_install_load_library("TxDb.Mmusculus.UCSC.mm10.knownGene")
check_install_load_library("biovizBase")
check_install_load_library("genomation")

###
# let's check the genes

# 1. I can also download the database as library.
mm10KG <- TxDb.Mmusculus.UCSC.mm10.knownGene

# Importing just genes for normal chromosomes and with the gene_id
chromosome_list <- c(paste0('chr', 1:19), 'chrX', 'chrY')
filter <- list(tx_chrom = chromosome_list)
genes.gr <- genes(mm10KG, filter = filter, columns=c("gene_id"))
# Droping the chromosomes that are not used. https://support.bioconductor.org/p/95879/
seqlevels(genes.gr) <- seqlevelsInUse(genes.gr)

# Let's try to create a different version of the gene list but with some base pair added
# at the beginning in the promoter region (between 100bp and 1000bp)
genes.gr.df <- data.frame(genes.gr)
bp.to.add <- 1000
genes.extended.gr <- GRanges(genes.gr.df$seqnames, 
                              IRanges(start = genes.gr.df$start-bp.to.add, 
                                      end = genes.gr.df$end),
                              strand = genes.gr.df$strand, 
                              gene_id = genes.gr.df$gene_id)

analysis_type <- 'only_gene'
analysis_type <- 'gene_plus_promotor_region'
if(analysis_type !='only_gene'){
  print(paste0('Extension of gene + promotor region of ', bp.to.add, ' bp.'))
  genes.gr <- genes.extended.gr
}

# I need the gene names
feature.maping.symbol <- mapIds(org.Mm.eg.db, unique(genes.gr$gene_id), 'SYMBOL', 'ENTREZID')
feature.maping.symbol.df <- data.frame(ID_REF = unique(genes.gr$gene_id), gene_name=feature.maping.symbol)



#2. Importing promoters and reducing the segments that can be joined.
promoters <- promoters(mm10KG,upstream = 2000, downstream = 100)
promoters <- GenomicRanges::reduce(promoters)

#3. Importing different parts 
FiveUTR <- GenomicRanges::reduce(flatGrl(fiveUTRsByTranscript(mm10KG)))
ThreeUTR <- GenomicRanges::reduce(flatGrl(threeUTRsByTranscript(mm10KG)))
CDS <- GenomicRanges::reduce(cds(mm10KG))
Introns <- GenomicRanges::reduce(flatGrl(intronsByTranscript(mm10KG)))



################
# now the methylation

# I create the GRanges object for the methylation, thinking about the contend.
perc.meth.thymus.gr <- makeGRangesFromDataFrame(perc.meth.thymus.df)
# Another method
perc.meth.thymus.gr <- GRanges(perc.meth.thymus.df$chr, 
                              IRanges(start = perc.meth.thymus.df$start, 
                                      end = perc.meth.thymus.df$end),
                              strand = perc.meth.thymus.df$strand, 
                              ID_METH = rownames(perc.meth.thymus.df))


perc.meth.thymus.gr <- perc.meth.thymus.gr[perc.meth.thymus.gr@seqnames %in% chromosome_list]
# Droping the chromosomes that are not used. https://support.bioconductor.org/p/95879/
seqlevels(perc.meth.thymus.gr) <- seqlevelsInUse(perc.meth.thymus.gr)


# Now I will see the overlapping with genes
overlaps.genes.cpgs <- findOverlaps(genes.gr, perc.meth.thymus.gr)

# Now I will create a dataset with the summary
overlaps.genes.cpgs.df <- data.frame(overlaps.genes.cpgs)
# Assign the actual values
overlaps.genes.cpgs.df$ID_REF <- genes.gr[overlaps.genes.cpgs.df$queryHits]$gene_id
overlaps.genes.cpgs.df$ID_METH <- perc.meth.thymus.gr[overlaps.genes.cpgs.df$subjectHits]$ID_METH


# Add cpg names
perc.meth.thymus$ID_METH <- rownames(perc.meth.thymus)

# 4. join the data with gene names
expression.CpGs.hits <- overlaps.genes.cpgs.df %>% left_join(feature.maping.symbol.df, by="ID_REF")
#with methylation data
expression.CpGs.hits.meth <- expression.CpGs.hits %>% left_join(perc.meth.thymus, by="ID_METH")

```

Let's take the marker genes for all the hierarchy.
```{r filtering.marker.genes}

#Adding top groups
all_markers.thymus <- c(
  #First the main leaf and the next level
  rownames(deco.actual.data.thymus.results$deco_results_list$subcluster_level_1_leaf_1$result_deco_top_cluster$w),
  rownames(deco.actual.data.thymus.results$deco_results_list$subcluster_level_1_leaf_1$deco_results_list$subcluster_level_2_leaf_1$result_deco_top_cluster$w),
  rownames(deco.actual.data.thymus.results$deco_results_list$subcluster_level_1_leaf_1$deco_results_list$subcluster_level_2_leaf_2$result_deco_top_cluster$w),
  
  #After the another leaf that doesn't have more levels.
  rownames(deco.actual.data.thymus.results$deco_results_list$subcluster_level_1_leaf_2$result_deco_top_cluster$w)
)

#Unique markers: 697
all_markers.thymus <- unique(all_markers.thymus)
length(all_markers.thymus)

```

After that I can filter the cpgs based on the markers
```{r filter.methylation.just.markers.genes}

# First filter cpgs associated with marker genes.
expression.CpGs.hits.meth.filtered.marker.genes <- expression.CpGs.hits.meth[expression.CpGs.hits.meth$gene_name %in% all_markers.thymus,]

#I filtered the CpGs that are associated with the marker genes.
perc.meth.thymus.filtered.marker.genes <- perc.meth.thymus[unique(expression.CpGs.hits.meth.filtered.marker.genes$ID_METH),]

```


## 7.1. Deconvolution with methylation.
Now I will run the deconvolution with both: expression and methylation data
One of the options it to fix the H proportion matrix.
```{r oligo.decoflex.deconvolution.expression.methylation.reference.actual.data}

order_normalized <- paste0('cluster_', c(8,9,10,11,28,4,3))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.00000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.00000001

#lets find the genes shared between single cell reference and bulk data
inter.bulk.sc.thymus <- intersect(rownames(eset.thymus.bulk.sparse.df.filtered), 
                                  rownames(reference_w.7.celltypes.thymus$basis.mvw)) 

#697
inter.bulk.sc.thymus.vs.markers <- intersect(inter.bulk.sc.thymus, all_markers.thymus)
length(inter.bulk.sc.thymus.vs.markers)

#Replacing zeros and nulls with a small value.
perc.meth.thymus <- data.frame(perc.meth.thymus.filtered.marker.genes) # 2,290
perc.meth.thymus[is.na(perc.meth.thymus)] <- 0


alpha_values <- c(0.001, 0.01, 0.1, 0.3, 0.5, 0.8)

start_time <- Sys.time()

bulk_data_expr <- eset.thymus.bulk.sparse.df.filtered[inter.bulk.sc.thymus.vs.markers, standard_name_thymus]
bulk_data_meth <- perc.meth.thymus[, standard_name_thymus]
fixed_w <- data.frame(reference_w.7.celltypes.thymus$basis.mvw[inter.bulk.sc.thymus.vs.markers, order_normalized])

grid_search_deco.dnmt1.ko.expr.meth.thymus <- run_grid_search(
  bulk_data_methylation = data.frame(bulk_data_meth),
  bulk_data_expression = data.frame(bulk_data_expr),
  data_expression_auxiliary = NULL,
  k = as.integer(7),
  alpha_list = alpha_values, beta_list = NULL,
  delta_threshold = 1e-10,
  max_iterations = as.integer(200),
  threads = as.integer(0),
  fixed_h = data.frame(deco.actual.data.thymus.results$back_propagation_proportions_top_detailed[order_normalized, standard_name_thymus]),
  fixed_w = fixed_w,
  proportion_constraint_h = as.logical(TRUE),
  constraint_type_a = 'sigmoid',
  constraint_value_a = as.double('0.50'),
  model_type = 'core_expression'
  )

#10 iterations: Time difference of 18.698 mins -> all genes
end_time <- Sys.time()
end_time - start_time
```

## 7.1.1 Performance of the deconvolution

Let's analyze the behavior and performance of the grid search algorithm to gain insights into its effectiveness.
```{r decoflex.gridsearch.thymus.plots.performance, fig.width=5, fig.height=3}

grid_search_deco.dnmt1.ko.expr.meth.thymus.df <- create_dataframe_results_multiple_deconvolutions(grid_search_deco.dnmt1.ko.expr.meth.thymus)

#Performance plots
performance_plot_multiple_deconvolutions(grid_search_deco.dnmt1.ko.expr.meth.thymus.df)
performance_plot_multiple_deconvolutions(grid_search_deco.dnmt1.ko.expr.meth.thymus.df, main_parameter = 'beta')
performance_plot_multiple_deconvolutions(grid_search_deco.dnmt1.ko.expr.meth.thymus.df, main_parameter = 'alpha')
```

```{r decoflex.gridsearch.thymus.plots, fig.width=7, fig.height=4}

plot_heatmap_alpha_beta(grid_search_deco.dnmt1.ko.expr.meth.thymus.df, fill_value = 'log_divergence_value')
plot_heatmap_alpha_beta(grid_search_deco.dnmt1.ko.expr.meth.thymus.df, fill_value = 'log_delta_divergence_value')
```

```{r histogram.methylation}

better_model.thymus <- choose_model_from_grid_search_object(grid_search_deco.dnmt1.ko.expr.meth.thymus, alpha = 0.001, beta=0)

hist(as.matrix(better_model.thymus$a), main = 'Histogram Thymus DecoFlex W - Meth profile')
```



## 7.3. Correlation methylation and signature. It turned out that the shared genes are just 12, therefore correlation doesn't make sense in this case.
```{r correlation.methylation.signature}
#importing the external data
library("readxl")
methylation_data <- read_excel('data_thymus/external_references/DNA_methylation_data.xlsx', sheet = "means")

cell_types_thymus.methylation <- c('CD4', 'CD8', 'B_cell', 'Mono', 'Granu')
methylation_data_fixed <- data.frame(methylation_data[, c(cell_types_thymus.methylation, 'chromStart')])

# Let's try the filtering, first counting and then keeping the uniques.
# I need to improve this.
library(dplyr)
#95086
methylation_data_fixed.counter <- methylation_data_fixed %>% dplyr::add_count(chromStart, name = "count_chromStart")

#54,124
methylation_data_filtered <- methylation_data_fixed.counter[methylation_data_fixed.counter$count_chromStart==1, c(cell_types_thymus.methylation, 'chromStart')]

#I name the columns with the location
rownames(methylation_data_filtered) <- paste0('cg_', methylation_data_filtered$chromStart)
methylation_data_filtered <- methylation_data_filtered[, cell_types_thymus.methylation]

#Convertion to double: 54124
gene_methylation_data.fixed.temp <- sapply(methylation_data_filtered, as.numeric)
rownames(gene_methylation_data.fixed.temp) <- rownames(methylation_data_filtered)

# replace the NA by zeros: 54124
gene_methylation_data.fixed <- data.frame(gene_methylation_data.fixed.temp) %>% mutate(across(everything(), .fns = ~replace_na(.,0))) 
  

#########################

#let's choose the better model
better_model.thymus <- choose_model_from_grid_search_object(grid_search_deco.dnmt1.ko.expr.meth.thymus, alpha = 0.001, beta=0)
model.results.matrix.a.methylation.patterns <- better_model.thymus$a

#######################

# now let's calculate the shared CpGs: Only 12 are shared!! such a waste of time!!
shared.cpg.methylation <- intersect(rownames(gene_methylation_data.fixed),
                                    rownames(model.results.matrix.a.methylation.patterns))

#shared
length(shared.cpg.methylation)

corr.methylation <- cor(x=gene_methylation_data.fixed[shared.cpg.methylation, ],
    y=model.results.matrix.a.methylation.patterns[shared.cpg.methylation, ], 
    method = 'pearson')

corr.methylation

```

# 8. Complete deconvolution: expr, meth and Z matrix

## 8.1. Creation of Z matrix

Let's construct the auxiliary matrix corresponding to the Z matrix. During this research phase, we need to develop the following strategies:

1. In this dataset, each row corresponds to a gene, and each column represents a sample. It's essential to aggregate the methylation values for each gene-sample pair. The objective here is to assess the methylation value within each gene, along with an adjacent 1000 base pairs (bp) region preceding the CpG site. This preceding region, known as the promoter region, typically consists of a high concentration of CpG sites (forming CpG islands) and is the primary target for methylation.


Now I will create the first Z matrix without scaling
```{r creation.auxiliary.matrix.expression.methylation.z.data}
# After the steps 1,2,3,4 from the chunck named: "methylation.join.genes" I will complete the Z matrix

# 5. I have the matrix that I will use in the deconvolution with Generalized Kullback Leibler convergence based on mutual information
expression.CpGs.hits.meth.by.gene <- expression.CpGs.hits.meth %>% group_by(gene_name) %>% 
  dplyr::summarise(Thy_WT_1= sum(Thy_WT_1),
            Thy_WT_2= sum(Thy_WT_2),
            Thy_WT_3= sum(Thy_WT_3),
            
            Thy_KO_1= sum(Thy_KO_1),
            Thy_KO_2= sum(Thy_KO_2),
            Thy_KO_3= sum(Thy_KO_3),
            
            Tumor_ALKpos_WT_1= sum(Tumor_ALKpos_WT_1),
            Tumor_ALKpos_WT_2= sum(Tumor_ALKpos_WT_2),
            Tumor_ALKpos_WT_3= sum(Tumor_ALKpos_WT_3),
            
            Thy_ALKpos_KO_1= sum(Thy_ALKpos_KO_1),
            Thy_ALKpos_KO_2= sum(Thy_ALKpos_KO_2),
            Thy_ALKpos_KO_3= sum(Thy_ALKpos_KO_3),
            .groups = 'drop') %>% 
  as.data.frame()

#6. Finally I have to scale from 0 to 1
scale_matrix_z <- function(matrix){
  library("scales")
  print('Original: ')
  print(colMeans(matrix, na.rm = TRUE))
  matrix.scaled <- apply(matrix, 2, rescale)
  print('Scaled: ')
  print(colMeans(matrix.scaled, na.rm = TRUE))
  message(paste0('Rows: ', nrow(matrix.scaled),
               ', Columns:', ncol(matrix.scaled)))
  return(matrix.scaled)
}

#Finally I get the matrix scaled
expression.CpGs.hits.meth.by.gene.scaled <- scale_matrix_z(expression.CpGs.hits.meth.by.gene[standard_name_thymus])
rownames(expression.CpGs.hits.meth.by.gene.scaled) <- expression.CpGs.hits.meth.by.gene$gene_name

#non scaled version
expression.CpGs.hits.meth.by.gene.final <- as.matrix(expression.CpGs.hits.meth.by.gene)
rownames(expression.CpGs.hits.meth.by.gene.final) <- expression.CpGs.hits.meth.by.gene.final[, c('gene_name')]
expression.CpGs.hits.meth.by.gene.final <- expression.CpGs.hits.meth.by.gene.final[,standard_name_thymus]

```

Additionally, we can create an auxiliary matrix, Z, that summarizes the information by calculating the expression divided by methylation as a factor or score.
```{r creation.auxiliary.matrix.expression.methylation.z.data.summarizing}

# I also can create an score expresion/methylation or the other way around.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
#6391
shared_genes <- intersect(rownames(eset.thymus.bulk.sparse.df.filtered), expression.CpGs.hits.meth.by.gene$gene_name) 


##### SCORES

#lets order the datasets 
expression.CpGs.hits.meth.by.gene.ordered <- expression.CpGs.hits.meth.by.gene[match(shared_genes, expression.CpGs.hits.meth.by.gene$gene_name),standard_name_thymus]
eset.thymus.bulk.sparse.df.filtered.ordered <- eset.thymus.bulk.sparse.df.filtered[match(shared_genes, rownames(eset.thymus.bulk.sparse.df.filtered)),standard_name_thymus]


###### Score A: gene_expression / sum(neighboring CpGs methylation)

# Calculation of the score A
expression.CpGs.hits.meth.by.gene.score.a <- expression.CpGs.hits.meth.by.gene.ordered / eset.thymus.bulk.sparse.df.filtered.ordered
#7.1 Let's replace the NAs values with a value almost 0 (1e20), however in the future the library has to be able to use the NA as advantage.
expression.CpGs.hits.meth.by.gene.score.a[is.na(expression.CpGs.hits.meth.by.gene.score.a)] <- 0.0000000001
expression.CpGs.hits.meth.by.gene.score.a[sapply(expression.CpGs.hits.meth.by.gene.score.a, is.infinite)] <- 0.0000000001



######### Score B: sum(neighboring CpGs methylation)/gene_expression 
expression.CpGs.hits.meth.by.gene.score.b <- eset.thymus.bulk.sparse.df.filtered.ordered / expression.CpGs.hits.meth.by.gene.ordered
#7.1 Let's replace the NAs values with a value almost 0 (1e20), however in the future the library has to be able to use the NA as advantage.
expression.CpGs.hits.meth.by.gene.score.b[is.na(expression.CpGs.hits.meth.by.gene.score.b)] <- 0.0000000001
expression.CpGs.hits.meth.by.gene.score.b[sapply(expression.CpGs.hits.meth.by.gene.score.b, is.infinite)] <- 0.0000000001


#6. Finally I have to scale from 0 to 1
expression.CpGs.hits.meth.by.gene.score.a.scaled <- scale_matrix_z(expression.CpGs.hits.meth.by.gene.score.a[standard_name_thymus])
expression.CpGs.hits.meth.by.gene.score.b.scaled <- scale_matrix_z(expression.CpGs.hits.meth.by.gene.score.b[standard_name_thymus])

```

We could add the missing marker genes in the Z matrix with zero or near to zero values.

```{r missing.markers.z.matrix}

# 1. 697 shared marker genes with the input
inter.bulk.sc.thymus.vs.markers <- intersect(inter.bulk.sc.thymus, all_markers.thymus)
length(inter.bulk.sc.thymus.vs.markers)

# 2. Also shared with the z matrix: 250
inter.bulk.sc.thymus.vs.markers.vs.z.matrix <- intersect(inter.bulk.sc.thymus.vs.markers, rownames(expression.CpGs.hits.meth.by.gene.final))
length(inter.bulk.sc.thymus.vs.markers.vs.z.matrix)

# 3. 244 Now I will calculate what is missing
diff_markers <- setdiff(inter.bulk.sc.thymus.vs.markers, rownames(expression.CpGs.hits.meth.by.gene.final))
length(diff_markers)

# 4. I create a matrix with the missing genes in order to add them to the Z matrix.
temp_matrix <- matrix(nrow = length(diff_markers), ncol = ncol(expression.CpGs.hits.meth.by.gene.final), 0.0000000001)
rownames(temp_matrix) <- diff_markers 
colnames(temp_matrix) <- colnames(expression.CpGs.hits.meth.by.gene.final)

# 5. Creation of the Z matrix with the genes with some methylated CpGs and the rest with zero values.
expression.CpGs.hits.meth.by.gene.final.complete <- rbind(expression.CpGs.hits.meth.by.gene.final, 
                                                          temp_matrix)

```


## 8.2. Deconvolution

We will calculate the B matrix using the Z matrix, incorporating the scores for all seven cell types. I need to fix a possible problem with marker genes, since it get reduced when I tried to recover information about methylation. Maybe I can add zeros to the genes that are not present.
```{r decoflex.gridsearch.thymus.plus.z}

order_normalized <- paste0('cluster_', c(8,9,10,11,28,4,3))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#let's choose the better model
better_model.thymus <- choose_model_from_grid_search_object(grid_search_deco.dnmt1.ko.expr.meth.thymus, alpha = 0.001, beta=0)

#606 shared marker genes with the input
inter.bulk.sc.thymus.vs.markers <- intersect(inter.bulk.sc.thymus, all_markers.thymus)
length(inter.bulk.sc.thymus.vs.markers)

#Also shared with the z matrix: 606 (With the missing fix)
inter.bulk.sc.thymus.vs.markers.vs.z.matrix <- intersect(inter.bulk.sc.thymus.vs.markers, rownames(expression.CpGs.hits.meth.by.gene.final.complete))
length(inter.bulk.sc.thymus.vs.markers.vs.z.matrix)

#I got the actual proportions fixed for the best
W_expression<- data.frame(reference_w.7.celltypes.thymus$basis.mvw[inter.bulk.sc.thymus.vs.markers.vs.z.matrix, order_normalized])
A_methylation <- data.frame(better_model.thymus$a[, order_normalized])
H_proportions <- data.frame(deco.actual.data.thymus.results$back_propagation_proportions_top_detailed[order_normalized, standard_name_thymus])


bulk_data_expr <- eset.thymus.bulk.sparse.df.filtered[inter.bulk.sc.thymus.vs.markers.vs.z.matrix, standard_name_thymus]
bulk_data_meth <- perc.meth.thymus[, standard_name_thymus]

matrix_z_auxiliary_data <- data.frame(expression.CpGs.hits.meth.by.gene.final.complete[inter.bulk.sc.thymus.vs.markers.vs.z.matrix, standard_name_thymus])
fixed_w <- data.frame(reference_w.7.celltypes.thymus$basis.mvw[inter.bulk.sc.thymus.vs.markers, ])

alpha_values.list <- c(0.0, 0.00001, 0.0001, 0.001, 0.01, 0.1, 1)
beta_values.list <-  c(0.0, 0.00001, 0.0001, 0.001, 0.01, 0.1, 1)

start_time <- Sys.time()

grid_search_deco.fixed.w.a.h.alpha.list.thymus <- run_grid_search(
  bulk_data_expression = data.frame(bulk_data_expr[inter.bulk.sc.thymus.vs.markers.vs.z.matrix, standard_name_thymus]),
  bulk_data_methylation = data.frame(bulk_data_meth[,standard_name_thymus]),
  data_expression_auxiliary = matrix_z_auxiliary_data[inter.bulk.sc.thymus.vs.markers.vs.z.matrix, standard_name_thymus],
  k = 7,
  alpha_list = alpha_values.list, 
  beta_list = beta_values.list,
  max_iterations = as.integer(30),
  threads = 0,
  delta_threshold=1e-10,
  proportion_constraint_h = as.logical(TRUE),  
  fixed_w = data.frame(W_expression),
  #fixed_a = data.frame(A_methylation), 
  #fixed_h = data.frame(H_proportions), 
  model_type = 'core_expression'
)

end_time <- Sys.time()
end_time - start_time
```

## 8.2.1. Performance of the deconvolution.

Let's analyze the behavior and performance of the grid search algorithm to gain insights into its effectiveness.
```{r decoflex.gridsearch.thymus.plus.z.plots.performance, fig.width=5, fig.height=3}

grid_search_deco.fixed.w.a.h.alpha.list.thymus.df <- create_dataframe_results_multiple_deconvolutions(grid_search_deco.fixed.w.a.h.alpha.list.thymus)

#Performance plots
performance_plot_multiple_deconvolutions(grid_search_deco.fixed.w.a.h.alpha.list.thymus.df)
performance_plot_multiple_deconvolutions(grid_search_deco.fixed.w.a.h.alpha.list.thymus.df, main_parameter = 'beta')
performance_plot_multiple_deconvolutions(grid_search_deco.fixed.w.a.h.alpha.list.thymus.df, main_parameter = 'alpha')
```

```{r decoflex.gridsearch.thymus.plus.z.plots, fig.width=7, fig.height=4}

plot_heatmap_alpha_beta(grid_search_deco.fixed.w.a.h.alpha.list.thymus.df, fill_value = 'log_divergence_value')
plot_heatmap_alpha_beta(grid_search_deco.fixed.w.a.h.alpha.list.thymus.df, fill_value = 'log_delta_divergence_value')
```

## 8.3 Plot of B matrix: relation expression. -> methylation

Now, we are prepared to visually examine both A matrices
```{r  decoflex.gridsearch.thymus.plus.z.b.matrix.analysis, fig.width=20, fig.height=7}

model.alpha.beta.op.thymus <- choose_model_from_grid_search_object(
  grid_search_deco.fixed.w.a.h.alpha.list.thymus,
  alpha = 0.1, beta = 0.00001)

list_pseudotime.thymus <- c('DN(P)', 'DN(Q)', 'DP(P)', 'DP(Q)', 'αβT(entry)', 'CD8+T', 'CD4+T')
model.alpha.beta.op.thymus.b <- model.alpha.beta.op.thymus$b
rownames(model.alpha.beta.op.thymus.b) <- list_pseudotime.thymus

palette.v1 <- colorRampPalette(c("red", "black", "green"))(n = 1000)
palette.v2 <- colorRampPalette(c("red", "green"))(n = 100)
color_scheme <- gplots::redgreen(75)

Colv  <- (as.matrix(model.alpha.beta.op.thymus.b)) %>% t %>% dist %>% hclust %>% as.dendrogram %>%
   set("branches_k_color", k = 2) %>% set("branches_lwd", 1) %>%
   rotate_DendSer(ser_weight = dist(t(x)))

par(cex.main=1)
gplots::heatmap.2((as.matrix(model.alpha.beta.op.thymus.b)),
                  trace="none",
                  margins=c(13,12), 
                  cexRow =2, cexCol = 2, 
                  dendrogram='column',     
                  Rowv=FALSE,
                  Colv=Colv,
                  col = palette.v1,
                  main = "Cell types vs samples: thymus")

Colv  <- log(as.matrix(model.alpha.beta.op.thymus.b)) %>% t %>% dist %>% hclust %>% as.dendrogram %>%
   set("branches_k_color", k = 2) %>% set("branches_lwd", 1) %>%
   rotate_DendSer(ser_weight = dist(t(x)))

par(cex.main=1)
plot.1 <- gplots::heatmap.2(log(as.matrix(model.alpha.beta.op.thymus.b)),
                  trace="none",
                  margins=c(13,12), 
                  cexRow = 2, cexCol = 2, 
                  dendrogram='column',     
                  Rowv=FALSE,
                  Colv=Colv,
                  col = palette.v2,
                  main = "Cell types vs samples in thymus")
print(plot.1$colDendrogram)

```

#9 Extra analysis

## 9.1. Correlation single cell expression data with external data

```{r external.data.adquisition.expression}

#importing the external data
library("readxl")
gene_expression_data <- read_excel('data_thymus/external_references/Gene_expression_data.xlsx', sheet = "means")

inters.external.vs.bulk <- intersect(unique(gene_expression_data$geneName), rownames(bulk_data_expr))

#assign the gene name as rownames: 18018
gene_expression_data.filtered <- gene_expression_data[gene_expression_data$geneName %in% inters.external.vs.bulk,]

#17918
length(unique(gene_expression_data.filtered$geneName))

# Remove duplicates by single column: 17918
gene_expression_data.filtered.dedu <- gene_expression_data.filtered[!duplicated(gene_expression_data.filtered$geneName), ]
rownames(gene_expression_data.filtered.dedu) <- gene_expression_data.filtered.dedu$geneName


gene_expression_data.fixed <- data.frame(gene_expression_data.filtered.dedu[, c('CD4', 'CD8', 'B_cell', 'Mono', 'Granu')])
rownames(gene_expression_data.fixed) <- gene_expression_data.filtered.dedu$geneName
gene_expression_data.fixed.temp <- sapply(gene_expression_data.fixed, as.numeric)
rownames(gene_expression_data.fixed.temp) <- rownames(gene_expression_data.fixed)

# replace the NA by zeros.
gene_expression_data.fixed <- data.frame(gene_expression_data.fixed.temp) %>% mutate(across(everything(), .fns = ~replace_na(.,0))) 
gene_expression_data.fixed.df <- data.frame(gene_expression_data.fixed)


#correlation between this and the single cell data.
single_cell_ref.df <- data.frame( reference_w.7.celltypes.thymus$basis.mvw)
single_cell_ref.df <- single_cell_ref.df[inters.external.vs.bulk,]
single_cell_ref.df <- na.omit(single_cell_ref.df)

```

```{r corr.single.cell.external.expression}

inters.external.vs.bulk <- intersect(rownames(gene_expression_data.fixed), rownames(single_cell_ref.df))

# The whole set of genes: Bad results
corr.expression <- cor(x=gene_expression_data.fixed[inters.external.vs.bulk, ],
    y=single_cell_ref.df[inters.external.vs.bulk, ], 
    method = 'pearson')
gene_expression_data.fixed.df

# Just the markers: zero correlation
corr.expression.just.markers <- cor(x=gene_expression_data.fixed[inter.bulk.sc.thymus.vs.markers, ],
    y=single_cell_ref.df[inter.bulk.sc.thymus.vs.markers, ], 
    method = 'pearson')
corr.expression.just.markers

```

# 10. Partial referenced model

With this setup we want to fix one proportion line: 
1. WT with the average values of single cell data.
2. The first 7 cell-types, leaving one cell-type uncover and therefore possible to be optimized.

## 10.1. Flat deconvolution 

```{r hierarchy.creation.flat}
#Binary hierarchy.
hierarchical_clustering_sc_thymus.flat <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(8,9,10,11,28,4,3)), 
           next_level_clustering=NULL
  )
)

```

Let's run first a deconvolution over the 7 cell-types without any extra configuration to extract marker genes.
```{r flat.deconvolution.manual.hierarchy}
library(DecoFlex)

order_normalized <- paste0('cluster_', c(8,9,10,11,28,4,3))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.00000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.00000001

#Filtering the eset object to have just 28w
eset.sc.thymus.4.sparse_fixed.24W <- eset.sc.thymus.4.sparse_fixed[, eset.sc.thymus.4.sparse_fixed$age %in% c('sample_24W')]
 

#Parameters for the simulation
#single_cell_data_exp <- eset.sc.thymus.4.sparse_fixed
single_cell_data_exp <- eset.sc.thymus.4.sparse_fixed.24W
hierarchy = hierarchical_clustering_sc_thymus.flat$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'cluster_normalized'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.flat.results <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 1.5,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 10,
                                          min_delta_cor_threshold = 0.0, 
                                          verbose = TRUE)
# Time difference of 37.13297 mins 0.2, 00
end_time <- Sys.time()
end_time - start_time
```

Now we need and differencial expression analysis over the bulk data to identify the up and down-regulated genes.
```{r differential.expression.analysis.thymus}

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

countdata <- as.matrix(eset.thymus.bulk.sparse@assayData$exprs)
countdata <- countdata[,standard_name_thymus]

#I put numbers on it because other wise I wouldn't get  ko vs wt.
type <- c("real_tumor","real_tumor","real_tumor",
          "real_tumor","real_tumor","real_tumor",
          "real_tumor","real_tumor","real_tumor",
          "real_tumor","real_tumor","real_tumor")

treatment <- c("Thy_WT","Thy_WT","Thy_WT",
                 "Thy_KO","Thy_KO","Thy_KO",
                 "Thy_ALKpos_WT","Thy_ALKpos_WT","Thy_ALKpos_WT",
                 "Thy_ALKpos_KO","Thy_ALKpos_KO","Thy_ALKpos_KO"
                 )

time <- c("18w","18w","18w",
          "18w","18w","18w",
          "18w","18w","18w",
          "18w","18w","18w")

replicates  <- c("1","2","3",
                 "1","2","3",
                 "1","2","3",
                 "1","2","3")

#secondary information
sample <- paste0("count_", 1:12)

coldata <- as.data.frame(cbind(replicates, treatment, time, sample, type))
rownames(coldata) <- NULL

#building the object DESeqDataSet
ddsFullCountTable <- DESeqDataSetFromMatrix(
  countData = countdata,
  colData = coldata,
  design = ~treatment)

#giving the order and setting the control sample for the analyisis, which is - in this case - the real Tumor_ALKpos_WT.
ddsFullCountTable$treatment <- factor(ddsFullCountTable$treatment, levels = c("Thy_ALKpos_WT","Thy_WT", "Thy_KO", "Thy_ALKpos_KO"))

  
dds <- ddsFullCountTable

## Pre-filter
dds <- dds[ rowSums(counts(dds)) > 1, ]

## The rlog and variance stabilizing transformations => homoskedastic data
rld <- rlog(dds, blind = FALSE)
vsd <- vst(dds, blind = FALSE)
dds <- estimateSizeFactors(dds)
normalized.wt.bulk <- counts(dds, normalized=TRUE)

dds <- DESeq(dds)
resultsNames(dds)

  
RES.thymus.lfc <- list(Intercept = results(dds, name = "Intercept"),
                       treatment_Thy_WT_vs_Thy_ALKpos_WT = results(dds, name = "treatment_Thy_WT_vs_Thy_ALKpos_WT"), 
                         treatment_Thy_KO_vs_Thy_ALKpos_WT = results(dds, name = "treatment_Thy_KO_vs_Thy_ALKpos_WT"), 
                         treatment_Thy_ALKpos_KO_vs_Thy_ALKpos_WT = results(dds, name = "treatment_Thy_ALKpos_KO_vs_Thy_ALKpos_WT"))


RES.thymus.lfc


#now lets check the genes that I should include
select_markers_de <- function(de_object){
  rownames(de_object[which(abs(de_object$log2FoldChange) >= 8 & de_object$padj <= 0.05),])
}

#236
de_genes.thymus <- c(select_markers_de(RES.thymus.lfc$treatment_Thy_WT_vs_Thy_ALKpos_WT),
              select_markers_de(RES.thymus.lfc$treatment_Thy_KO_vs_Thy_ALKpos_WT),
              select_markers_de(RES.thymus.lfc$treatment_Thy_ALKpos_KO_vs_Thy_ALKpos_WT))

#144. We hope that this will be enought to describe the missing celltype.
de_genes.thymus <- unique(de_genes.thymus)

```

Let's put together the marker genes from the flat deconvolution and the differential expressed genes.
```{r final.list.genes}


#Let's create the w reference with all the genes and then we could see which are shared with the final_markers_partial_model
# I don't use the one in the model becasue only has the marker genes in the reference and I need those  plus the Differential
# expressed ons
single_cell_data_exp <- eset.sc.thymus.4.sparse_fixed
top_clusters_list = paste0('cluster_', c(8,9,10,11,28,4,3))
bulk_data = eset.thymus.bulk.sparse.df.filtered
sub_clusters_var <- 'cluster_normalized'
sample <- 'age'

w_matrix_reference <- decoflex_build_cell_reference(
  x = single_cell_data_exp,
  ct.sub = top_clusters_list,
  ct.varname = sub_clusters_var,
  sample = sample,
  verbose = TRUE)

# sorting the results by columns
w_matrix_reference.basics <- w_matrix_reference$basis[, paste0('cluster_', c(8,9,10,11,28,4,3))]



#172
final_markers_partial_model <- c(de_genes.thymus, rownames(deco.actual.data.thymus.flat.results$result_deco_top_cluster$w))

#172
final_markers_partial_model <- unique(final_markers_partial_model)
length(final_markers_partial_model)

#57 (what???? why???)
shared.final.vs.w <- intersect(final_markers_partial_model, rownames(as.matrix(w_matrix_reference.basics)))
length(shared.final.vs.w)

final_markers_partial_model <- shared.final.vs.w

```

## 10.2. Creation of partial references: W and H

Now we can create the partial references with ONE fixed cell-type
```{r creation.mask.matrices.h.w.one.celltype}

# I have n genes as rows and m+1 columns, being the last one the unknown one. 
mask_h <- matrix(FALSE, nrow = 8, ncol = 12)
colnames(mask_h) <- standard_name_thymus
rownames(mask_h) <- paste0('cluster_', c(8,9,10,11,28,4,3, 'unknown'))

# In this case, I can do two things: 1. Fix just the celltypes that I have as reference and the unknown leave it as black. 2. Assign the unknown cell-type as zero, since it suppose to be a WT, and then in the other conditions it will appear a proportion. Also the Tumor DNMT1 KO, will be similar to WT.
version <- 'two'
if(version=='one'){
  #Version 1.
  mask_h[1:7,1:3] <- TRUE
}else if(version=='two'){
  #Version 1.
  mask_h[1:8,1:3] <- TRUE
}




#Now let's put the proportions that I needed, filling with zeros the rest
partial_h_fixed <- matrix(0, nrow = 8, ncol = 12)
colnames(partial_h_fixed) <- standard_name_thymus
rownames(partial_h_fixed) <- paste0('cluster_', c(8,9,10,11,28,4,3, 'unknown'))
#let's take the proportion
proportions_wt_single_cell <- as.data.frame.matrix(deco.simulation.oligo.tree_guided.recursive.results$pseudo.bulk.data$truep) 
proportions_wt_single_cell['sample_24W', paste0('cluster_', c(8,9,10,11,28,4,3)) ]

#Since I have three replicates I have to fix the proportions three times
partial_h_fixed[1:7,1] <- as.matrix(proportions_wt_single_cell['sample_24W', paste0('cluster_', c(8,9,10,11,28,4,3)) ])
partial_h_fixed[1:7,2] <- as.matrix(proportions_wt_single_cell['sample_24W', paste0('cluster_', c(8,9,10,11,28,4,3)) ])
partial_h_fixed[1:7,3] <- as.matrix(proportions_wt_single_cell['sample_24W', paste0('cluster_', c(8,9,10,11,28,4,3)) ])





#Now I will create the W
mask_w <- matrix(TRUE, nrow = length(final_markers_partial_model), ncol = 8)
colnames(mask_w) <- paste0('cluster_', c(8,9,10,11,28,4,3, 'unknown'))
rownames(mask_w) <- final_markers_partial_model
mask_w[1:length(final_markers_partial_model), 8] <- FALSE

# I have k cell-types rows by m samples. I want to add the same proportions to the first three wild-type samples corresponding to the 
# '4W','8W','24W' time points
partial_w_fixed <- matrix(0, nrow = length(final_markers_partial_model), ncol = 8)
colnames(partial_w_fixed) <- paste0('cluster_', c(8,9,10,11,28,4,3, 'unknown'))
rownames(partial_w_fixed) <- final_markers_partial_model

#Let's filter the w matrix reference (partially)
w_matrix_reference_basis_fixed <- as.data.frame(w_matrix_reference$basis)
w_matrix_reference_basis_fixed <- w_matrix_reference_basis_fixed[final_markers_partial_model, ]

partial_w_fixed[1:length(final_markers_partial_model), 1:7] <- as.matrix(w_matrix_reference_basis_fixed)

```

Now we can create the partial references with TWO fixed cell-type
```{r creation.mask.matrices.h.w.multiple.celltype}

celltypes_names <- paste0('cluster_', c(8,9,10,11,28,4,3, 'unknown_01', 'unknown_02'))

# I have n genes as rows and m+1 columns, being the last one the unknown one. 
mask_h <- matrix(FALSE, nrow = (7+2), ncol = 12)
colnames(mask_h) <- standard_name_thymus
rownames(mask_h) <- celltypes_names

# In this case, I can do two things: 1. Fix just the celltypes that I have as reference and the unknown leave it as black. 2. Assign the unknown cell-type as zero, since it suppose to be a WT, and then in the other conditions it will appear a proportion. Also the Tumor DNMT1 KO, will be similar to WT.
version <- 'two'
if(version=='one'){
  #Version 1.
  mask_h[1:7,1:3] <- TRUE
}else if(version=='two'){
  #Version 1.
  mask_h[1:9,1:3] <- TRUE
}




#Now let's put the proportions that I needed, filling with zeros the rest
partial_h_fixed <- matrix(0.0000000001, nrow = (7+2), ncol = 12)
colnames(partial_h_fixed) <- standard_name_thymus
rownames(partial_h_fixed) <- celltypes_names
#let's take the proportion
proportions_wt_single_cell <- as.data.frame.matrix(deco.simulation.oligo.tree_guided.recursive.results$pseudo.bulk.data$truep) 
proportions_wt_single_cell['sample_24W', paste0('cluster_', c(8,9,10,11,28,4,3)) ]

#Since I have three replicates I have to fix the proportions three times
partial_h_fixed[1:7,1] <- as.matrix(proportions_wt_single_cell['sample_24W', paste0('cluster_', c(8,9,10,11,28,4,3)) ])
partial_h_fixed[1:7,2] <- as.matrix(proportions_wt_single_cell['sample_24W', paste0('cluster_', c(8,9,10,11,28,4,3)) ])
partial_h_fixed[1:7,3] <- as.matrix(proportions_wt_single_cell['sample_24W', paste0('cluster_', c(8,9,10,11,28,4,3)) ])





#Now I will create the W
mask_w <- matrix(TRUE, nrow = length(final_markers_partial_model), ncol = (7+2))
colnames(mask_w) <- celltypes_names
rownames(mask_w) <- final_markers_partial_model
mask_w[1:length(final_markers_partial_model), 8:9] <- FALSE

# I have k cell-types rows by m samples. I want to add the same proportions to the first three wild-type samples corresponding to the 
# '4W','8W','24W' time points
partial_w_fixed <- matrix(0.0000000001, nrow = length(final_markers_partial_model), ncol = (7+2))
colnames(partial_w_fixed) <- celltypes_names
rownames(partial_w_fixed) <- final_markers_partial_model

#Let's filter the w matrix reference (partially)
w_matrix_reference_basis_fixed <- as.data.frame(w_matrix_reference$basis)
w_matrix_reference_basis_fixed <- w_matrix_reference_basis_fixed[final_markers_partial_model, ]

partial_w_fixed[1:length(final_markers_partial_model), 1:7] <- as.matrix(w_matrix_reference_basis_fixed)

```

## 10.3. Running deconvolution with partial reference model

Finally we can put together the model and run the partial conditioned deconvolution model to see if that work
```{r flat.deconvolution.partial.references}

order_normalized <- paste0('cluster_', c(8,9,10,11,28,4,3))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001

#Replacing zeros and nulls with a small value.
perc.meth.thymus <- data.frame(perc.meth.thymus.filtered.marker.genes) # 2,290
perc.meth.thymus[is.na(perc.meth.thymus)] <- 0.00000000001
bulk_data_meth <- perc.meth.thymus[, standard_name_thymus]

proportion_constraint_h = TRUE

start_time <- Sys.time()

# I run the deconvolution without any other parameter
deco.alpha.beta.zero.results <- run_complete_deconvolution(
  x_matrix = data.frame(eset.thymus.bulk.sparse.df.filtered[final_markers_partial_model, standard_name_thymus]),
  y_matrix = data.frame(bulk_data_meth),
  z_matrix = NULL,
  k = 8,
  alpha = 0.00001, 
  beta = 0,
  delta_threshold=1e-10, 
  max_iterations=8000, 
  #I have to deactivate the sum 1 because that is just for the 7 cell types
  proportion_constraint_h = proportion_constraint_h,
  partial_w_fixed=data.frame(partial_w_fixed[final_markers_partial_model, ]),
  partial_h_fixed=data.frame(partial_h_fixed),
  w_mask_fixed=data.frame(mask_w),
  h_mask_fixed=data.frame(mask_h),
  batches_partial_fixed=1)

end_time <- Sys.time()
end_time - start_time
```
Analysis of proportions
```{r proportions.assignment}
colSums(deco.alpha.beta.zero.results$h[1:7,])

prop_recal <- deco.alpha.beta.zero.results$h

if(proportion_constraint_h){
  
}else{
  prop_recal[1:7, ] <- prop_recal[1:7, ]/colSums(prop_recal[1:7, ])
}

prop_recal <- round(prop_recal, 4)
prop_recal
```


## 10.4. Plot with flat model proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion.flat.model}
order_normalized <- paste0('cluster_', c('8','9','10','11','28','4','3', 'unknown'))
order_samples <- c('sample_4W','sample_8W','sample_24W')
list_pseudotime <- c('DN(P)', 'DN(Q)', 'DP(P)', 'DP(Q)', 'αβT(entry)', 'CD8+T', 'CD4+T', 'unknown')

#Calculate the proportion for clusters for 7 clusters
real_proportion <- as.data.frame.matrix(deco.simulation.oligo.tree_guided.recursive.results$pseudo.bulk.data$truep)
real_proportion <- cbind(real_proportion, 'cluster_unknown'=0)

real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]

real_proportion.pseudotime.rescaled <- NULL
for(counter in 1:nrow(real_proportion.pseudotime)){
  new_row <- real_proportion.pseudotime[counter,]/sum(real_proportion.pseudotime[counter,])
  real_proportion.pseudotime.rescaled <- rbind(real_proportion.pseudotime.rescaled, new_row)
}

#just checking. Everything should sum up 1.
rowSums(real_proportion.pseudotime.rescaled)
#Adding names
colnames(real_proportion.pseudotime.rescaled) <- list_pseudotime


# All experiments
experimental_data <- t(prop_recal[order_normalized, ])
experimental_data <- data.frame(experimental_data)
colnames(experimental_data) <- list_pseudotime


#Joining the bulk data wt
comparison_real_vs_deconvolution <- rbind(experimental_data, real_proportion.pseudotime.rescaled)


thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))

thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))


thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)

thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_KO'] <- 'KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'Thy_ALKpos_KO'] <- 'ALKKO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_4W'] <- '4w_thymus')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_8W'] <- '8w_thymus')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_24W'] <- '24w_thymus')

thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO', 'ALK', 'ALKKO', '4w_thymus', '8w_thymus', '24w_thymus'))

#thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl'))

#real proportion vs control
thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)

# assign values to zero
#thymus.proportions.deconvolution.summarized.melt$value[thymus.proportions.deconvolution.summarized.melt$value < 0.01] = 0.01

p <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% c('Ctrl', 'KO', 'ALK', 'ALKKO') & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
  geom_point(size=4, shape=20, alpha = .30, position=position_jitter(width=.3,height=.00)) +
  labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text=element_text(size=16),
        legend.title = element_text(size = 16),
          legend.text = element_text(size = 16)) + 
  ylim(-0.1, 1.0)
 
p +  scale_color_manual(name = "Sample", breaks = c('4w_thymus', '8w_thymus', '24w_thymus', 'Ctrl', 'KO', 'ALK', 'ALKKO'), values = c("turquoise3", "bisque2", "darkgrey", "#136c38", "blue", "red", "orange")) + theme_light()
```
# 11.  Simplest model

```{r simple.model}

eset.sc.thymus.4.sparse_fixed$cluster_normalized_joint <- 

```

## 10.1. Flat deconvolution 

```{r hierarchy.creation.flat}
#Binary hierarchy.
hierarchical_clustering_sc_thymus.flat <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(8,9,10,11,28,4,3)), 
           next_level_clustering=NULL
  )
)

```

Let's run first a deconvolution over the 7 cell-types without any extra configuration to extract marker genes.
```{r flat.deconvolution.manual.hierarchy}
library(DecoFlex)

order_normalized <- paste0('cluster_', c(8,9,10,11,28,4,3))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.00000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.00000001

#Filtering the eset object to have just 28w
eset.sc.thymus.4.sparse_fixed.24W <- eset.sc.thymus.4.sparse_fixed[, eset.sc.thymus.4.sparse_fixed$age %in% c('sample_24W')]
 

#Parameters for the simulation
#single_cell_data_exp <- eset.sc.thymus.4.sparse_fixed
single_cell_data_exp <- eset.sc.thymus.4.sparse_fixed.24W
hierarchy = hierarchical_clustering_sc_thymus.flat$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'cluster_normalized'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.flat.results <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 1.5,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 10,
                                          min_delta_cor_threshold = 0.0, 
                                          verbose = TRUE)
# Time difference of 37.13297 mins 0.2, 00
end_time <- Sys.time()
end_time - start_time
```
