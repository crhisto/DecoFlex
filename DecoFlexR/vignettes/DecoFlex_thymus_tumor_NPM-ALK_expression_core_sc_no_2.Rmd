---
title: "DecoFlex_thymus_tumor_NPM-ALK_expression_core_sc.v2."
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DecoFlex_thymus_tumor_NPM-ALK_expression_core}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r function.import.libraries}
#Function to install and load libraries
check_install_load_library <- function(library_name, type = 'BiocManager' ){
  
  if(type == 'BiocManager'){
    if(library_name %in% rownames(installed.packages())){
      library(library_name, character.only=TRUE)
    }else{
      BiocManager::install(library_name)
      library(library_name, character.only=TRUE)
    }
  }
  
}
```

```{r setup}
library(DecoFlex)
reticulate::py_install(envname="~/miniconda3/envs/r_DecoFlex", packages="/Users/crhisto/Documents/GitHub/NMMFlex/NMMFlexPy", pip=TRUE)
```

TODO create function to install differents and load.
First, we have to install 2 libraries that have been modified in order to use sparse matrices in R: [Biobase](https://github.com/Bioconductor/Biobase) and [xbioc](https://github.com/renozao/xbioc). Then we imported a modified version of the library [SCDC](https://meichendong.github.io/SCDC/articles/SCDC.html) that has been modified to support: sparse matrices, parallelism, and Dynamic threshold for markers selection, among other improvements. Finally, we imported the general libraries required to run the complete pipeline.
```{r importing_libraries, include=FALSE}
if (!require("devtools")) {
  install.packages("devtools")
}

#Check Biobase modified installation
if("Biobase" %in% rownames(installed.packages())){
  library(Biobase)
}else{
  devtools::install_github( repo = "crhisto/Biobase" )
  library(Biobase)
}

#Check xbioc modified installation
if("xbioc" %in% rownames(installed.packages())){
  library(xbioc)
}else{
  devtools::install_github( repo = "crhisto/xbioc" )
  library(xbioc)
}

#Check hdf5r installation
if("hdf5r" %in% rownames(installed.packages())){
  library(hdf5r)
}else{
  #install the package hdf5r
  #Use the following command in ubuntu linux: sudo apt-get install libhdf5-dev
  install.packages("hdf5r")
  library(hdf5r)
}

if("methylKit" %in% rownames(installed.packages())){
  library(methylKit)
}else{
  BiocManager::install("methylKit")
  library(methylKit)
}

if("dendextend" %in% rownames(installed.packages())){
  library(dendextend)
}else{
  install.packages('dendextend')
  library(dendextend)
}



if("SeuratDisk" %in% rownames(installed.packages())){
  library(SeuratDisk)
}else{
  remotes::install_github("mojaveazure/seurat-disk")
  library(SeuratDisk)
}



#for deconvolution SCDC library
library(pheatmap)
library(foreach)
library(doParallel)
library(Seurat)
library(fpc)
library(tidyverse)
library(fpc)
library(stringr)
library(dbscan)
library(slam)
library(dplyr)
library(ggplot2)
library(reshape2)
library(DESeq2)
library(BiocGenerics)
library(Matrix)
library(SeuratDisk)
library(methylKit)
library(gplots)
```

# 0. Save and load environment
Save and load environment
```{r save.load.environment}

file_name <- '/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/figures_manuscript/myEnvironment_27_07_2023.RData'
save.image(file=file_name)
#load(file_name)
```


# 1. Single-cell data importing and analysis

1. Download the data from: https://drive.google.com/drive/folders/1XiVwOaTIxERE5Kf2T2lAfuW8sLL3IS8u
Using the scRNA-seq from the paper: "Development of double-positive thymocytes at single-cell resolution": https://genomemedicine.biomedcentral.com/articles/10.1186/s13073-021-00861-7

The generic functions have been saved in the scripting file: scripts/generic_functions.R"
```{r importing_script}
source("/Users/crhisto/Documents/GitHub/thymus_NPM-ALK_notebook/scripts/generic_functions.R", local = knitr::knit_global())
```

```{r function_plot_pdf_publication}

save_plot_as_pdf <- function(plot_object, file_name, width.parameter = NULL, height.parameter = NULL, path = NULL){
  
  #Assign the default path if is null.
  if(is.null(path)){
    path <- '/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/figures_manuscript/'
  }
  
  if(is.null(width.parameter) && is.null(height.parameter)){
    pdf(file = paste0(path, file_name))
  }else{
    pdf(file = paste0(path, file_name), width = width.parameter, height = height.parameter)
  }
  
  print(plot_object)
  dev.off()
}

```

Importing of the bulk data with the 12 samples in a ESET object type supporting sparse matrices.
```{r import_bulk_data_object}
path.data <- paste0(getwd(), '/', 'data_thymus/')
load(paste0(path.data, "eset.thymus.bulk.sparse.RData"))
eset.thymus.bulk.sparse
```

```{r importing_data}
library(Seurat)

path_sc_data <- '/Users/crhisto/Google Drive/PHD_PROJECT/UNIVERSITY/033_third_gerda_collaboration/papers/paper_3/data/T_cell_development/'

thymus.expression_matrix <- Read10X(data.dir = paste0(path_sc_data, 'cellranger_self_mm10_p5/'))
seurat_object.thymus = CreateSeuratObject(counts = thymus.expression_matrix)
seurat_object.thymus$orig.ident

```

```{r importing.clustering}
annotations_thymus.clusters <- read.table(paste0(path_sc_data, "cell_cluster15_self_modcell.txt"), 
                 header = TRUE,
                 sep = "\t")
rownames(annotations_thymus.clusters) <- annotations_thymus.clusters$cell
annotations_thymus.clusters
```

```{r extra.info.seurat}

#ordering
annotations_thymus.clusters <- annotations_thymus.clusters[match(names(seurat_object.thymus$orig.ident), annotations_thymus.clusters$cell), ] 

#Adding clustering_normalized
cluster_list.thymus.bigstage <- data.frame(bigstage = c("1DN", "2preDP", "3DPbla", "4DPre", "5DPsel", "6CD4sp", "7CD8sp", "9NCL", "10APC"), cluster_normalized_bigstage = paste0('cluster_', 1:9), cluster_order = as.numeric(c(1:9)), bigstage.top = c("DN", "DP", "DP", "DP", "DP", "CD4sp", "CD8sp", "9NCL", "10APC"))

cluster_list.thymus.stage <- data.frame(stage = c('1DN', '2preDP', '3DPbla1', '3DPbla2', '3DPbla3', '3DPbla4', '4DPre1', '4DPre2', '4DPre3', '5DPsel1', '5DPsel2', '6CD4sp',  '7CD8sp', '9NCL', '10APC'), cluster_normalized_stage = paste0('cluster_', 1:15), cluster_order = as.numeric(c(1:15)))

#let's cross and add the information to the main dataset
#I add the cluster normalized for avoiding problems with names and special characters
annotations_thymus.clusters <- annotations_thymus.clusters %>% left_join(cluster_list.thymus.bigstage, by = "bigstage")
annotations_thymus.clusters <- annotations_thymus.clusters %>% left_join(cluster_list.thymus.stage, by = "stage")

#I add the information from the annotations to the seurat object
seurat_object.thymus@meta.data$stage <- annotations_thymus.clusters$stage
seurat_object.thymus@meta.data$bigstage <- annotations_thymus.clusters$bigstage
seurat_object.thymus@meta.data$bigstage.top <- annotations_thymus.clusters$bigstage.top
seurat_object.thymus@meta.data$cluster_normalized_bigstage <- annotations_thymus.clusters$cluster_normalized_bigstage
seurat_object.thymus@meta.data$cluster_normalized_stage <- annotations_thymus.clusters$cluster_normalized_stage
seurat_object.thymus@meta.data$color <- annotations_thymus.clusters$color
seurat_object.thymus@meta.data$age <- 'sample_6W'

```

Here we will only consider cells with at least 200 detected genes and genes need to be expressed in at least 3 cells. Please note that those values are highly dependent on the library preparation method used.
```{r}


selected_c <- WhichCells(seurat_object.thymus, expression = nFeature_RNA > 200)
selected_f <- rownames(seurat_object.thymus)[Matrix::rowSums(seurat_object.thymus) > 2]

data.filt <- subset(seurat_object.thymus, features = selected_f, cells = selected_c)
dim(data.filt)
```


```{r preprocessing.seurat}

seurat_object.thymus[["percent.mt"]] <- PercentageFeatureSet(seurat_object.thymus, pattern = "^MT-")
VlnPlot(seurat_object.thymus, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
seurat_object.thymus <- NormalizeData(seurat_object.thymus)
seurat_object.thymus <- ScaleData(object = seurat_object.thymus)
seurat_object.thymus <- FindVariableFeatures(object = seurat_object.thymus)

seurat_object.thymus <- RunPCA(seurat_object.thymus, features = VariableFeatures(object = seurat_object.thymus))
DimPlot(seurat_object.thymus, reduction = "pca")

seurat_object.thymus <- RunTSNE(object = seurat_object.thymus, dims.use = 1:20, do.fast = TRUE)
seurat_object.thymus <- RunUMAP(seurat_object.thymus, dims = 1:20)

TSNEPlot(object = seurat_object.thymus)
UMAPPlot(object = seurat_object.thymus)


```

```{r plots.top.level}
Idents(seurat_object.thymus) <- seurat_object.thymus$bigstage

#Filtering for the 7 cell types of the analysis
seurat_object.thymus.filtered.7.celltypes <- WhichCells(seurat_object.thymus, idents = cluster_list.thymus.bigstage$bigstage[1:7])

#plot of the 7 celltypes in the trajectory
plot_umap_trajectory_t_cells <- DimPlot(seurat_object.thymus, reduction = "umap", label = FALSE,  pt.size = 0.5, cells = seurat_object.thymus.filtered.7.celltypes
)
plot(plot_umap_trajectory_t_cells)

#Saving the pdf
#save_plot_as_pdf(plot_umap_trajectory_t_cells, 'plot_umap_trajectory_t_cells_detailled.pdf', 8, 5)




Idents(seurat_object.thymus) <- seurat_object.thymus$bigstage.top

#Filtering for the 7 cell types of the analysis
seurat_object.thymus.filtered.4.celltypes <- WhichCells(seurat_object.thymus, idents = c("DN", "DP","CD4sp", "CD8sp"))

#plot of the 7 celltypes in the trajectory
plot_umap_trajectory_t_cells_top <- DimPlot(seurat_object.thymus, reduction = "umap", label = TRUE,  pt.size = 0.5, cells = seurat_object.thymus.filtered.4.celltypes
)
plot(plot_umap_trajectory_t_cells_top)

#Saving the pdf
#save_plot_as_pdf(plot_umap_trajectory_t_cells_top, 'plot_umap_trajectory_t_cells_top.pdf', 8, 5)





DimPlot(seurat_object.thymus, reduction = "tsne", label = TRUE, 
        pt.size = 0.5
)

```
```{r plots.detailed.level}
Idents(seurat_object.thymus) <- seurat_object.thymus$stage
DimPlot(seurat_object.thymus, reduction = "umap", label = TRUE, 
        pt.size = 0.5
)
DimPlot(seurat_object.thymus, reduction = "tsne", label = TRUE, 
        pt.size = 0.5
)
```
```{r creation.count.matrix}
table(seurat_object.thymus$bigstage)

#create the count matrix base on the seurat object
counts.seurat_object.thymus.6.8.w <- create_count_matrix(seurat_object.thymus)
```

Creation of object with the scRNA-seq data for the deconvolution
```{r create_eset_scrna_reference, echo = T, results = 'hide'}

# Function to 
create_sparse_eset_object_6_8w <- function(count, seurat_object){
  sparse_matrix <- as(count, "dgCMatrix")
  fdata_split_dataset <- rownames(sparse_matrix)
  pdata_split_dataset <- cbind(age = as.character(seurat_object@meta.data$age),
                               stage = as.character(seurat_object@meta.data$stage),
                               bigstage = as.character(seurat_object@meta.data$bigstage),
                               cluster_normalized_bigstage = as.character(seurat_object@meta.data$cluster_normalized_bigstage),
                               cluster_normalized_stage = as.character(seurat_object@meta.data$cluster_normalized_stage))
  eset.sc.sparse <- getESET(sparse_matrix, fdata = fdata_split_dataset, pdata = pdata_split_dataset)
  
  eset.sc.sparse
}

getESET <- function (exprs, fdata, pdata) 
{
  pdata <- as.data.frame(pdata)
  fdata <- as.data.frame(fdata)
  #exprs <- as.matrix(exprs)
  exprs <- Matrix(exprs, sparse = TRUE)
  rownames(pdata) <- colnames(exprs)
  rownames(fdata) <- rownames(exprs)
  eset <- ExpressionSet(exprs, AnnotatedDataFrame(pdata), 
                        AnnotatedDataFrame(fdata))
}


#Use the function to create the sparse eset object
eset.sc.thymus.6.8.w.sparse <- create_sparse_eset_object_6_8w(counts.seurat_object.thymus.6.8.w, seurat_object.thymus)
head(eset.sc.thymus.6.8.w.sparse)

```

## 1.1. Data simulation 50% 50%

```{r simulation}

#BiocManager::install("AnnotationDbi")
library(AnnotationDbi)

#Filtering the T-cells celltypes that we are interested on
thymus.keep <- which(seurat_object.thymus$bigstage %in% c("1DN", "2preDP", "3DPbla", "4DPre", "5DPsel", "6CD4sp", "7CD8sp"))
seurat_object.thymus.filtered <- subset(seurat_object.thymus, cells = thymus.keep)

create_sampling_sc <- function(sc_object, percentage_signature = .50){
  
  size_signature <- 0
  size_mixture <- 0
  if(percentage_signature >1){
    stop('percentage_signature must be 1 or lesser than 1.')
  }else if(percentage_signature == 1.0){
    #we assume that both object will have 100% of the cells in the single cell dataset
    size_signature <- ncol(sc_object)
    size_mixture <- ncol(sc_object)
    
    print(paste0('Both signature and mixture will have 100% of the single cell data.',
                 'size_signature=', size_signature, ', size_mixture=', size_mixture))
  }else{
    #Calculating the size of each subset
    size_signature = ncol(sc_object) * percentage_signature
    size_mixture = ncol(sc_object) * (1-percentage_signature)
    
    print(paste0('Signature and mixture will have: ',percentage_signature, ', ',
                 (1-percentage_signature), ' of the single cell data.',
                 'size_signature=', size_signature, ', size_mixture=', size_mixture))
  }

  
  signature.sampling <- AnnotationDbi::sample(colnames(sc_object), size = size_signature, replace = FALSE)
  
  mixture.sampling <- NULL
  if(percentage_signature == 1.0){
    mixture.sampling <- AnnotationDbi::sample(colnames(sc_object), size = size_signature, replace = FALSE)
  }else{
    mixture.sampling <- colnames(sc_object)[-which(colnames(sc_object) %in% signature.sampling)]
  }

  
  return(list(signature.sampling = signature.sampling, 
              mixture.sampling = mixture.sampling))
}

sampling.result.thymus <- create_sampling_sc(sc_object = seurat_object.thymus.filtered, percentage_signature = .65)

thymus.signature.sampling <- sampling.result.thymus$signature.sampling
thymus.mixture.sampling <- sampling.result.thymus$mixture.sampling

#creating the seurat object for the signature
seurat_object.thymus.signature <- subset(seurat_object.thymus, cells = thymus.signature.sampling)

#lenght: 961
length(thymus.signature.sampling)
length(thymus.mixture.sampling)

```

```{r random.sampling.function}
## Random sampling
create.snmeRand <- function(nMix, # number of cells to mix per sample
                            nReps, # number of samples to make
                            x, # a dataframe of single-cells
                            meta, # a dataframe of celltype labels
                            meta.columns, # columns in the dataframe to use as true labels during mixing
                            rpkm = TRUE) {
  
  # recalculate library size in the meta data
  meta$libSize <- colSums(x)
  
  # setup mixture dataframe
  mixed <- as.data.frame(matrix(nrow = nrow(x), ncol = nReps))
  rownames(mixed) <- rownames(x)
  
  # setup true-proportion dataframe
  true <- list()
  for(j in meta.columns) {
    ct <- levels(as.factor(meta[,j]))
    true[[j]] <- as.data.frame(matrix(nrow = nReps, ncol = length(ct)))
    colnames(true[[j]]) <- ct
  }
  
  # for loop for mixture generation
  for(i in 1:nReps) {
    # report progress to user
    print(paste0(i / nReps * 100, "%"))

    # sampling vector
    sampleVec <- sample(colnames(x), size = nMix, replace = FALSE)
    
    # sample these single cells, and collect:
     
      if (rpkm) {  # the average if rpkm...
        mixed[,i] <- rowMeans(x[,sampleVec])  
      } else { # and the sum if counts
        mixed[,i] <- rowSums(x[,sampleVec])  
      }
      
    # annotate the output metadata with proportions
      
      if (rpkm) { # the number in the mixture if rpkm
        
        for(j in meta.columns) {
          ct <- table(meta[sampleVec,j])
          ct <- ct / nMix
          ct <- ct[colnames(true[[j]])]
          true[[j]][i,] <- ct
        }
          
      } else { # the ratio of reads if counts
        
        for(j in meta.columns) {
          meta$temp <- meta[,j]
          ratio <- aggregate(libSize~temp, meta[sampleVec,], sum)
          ratio$libSize <- ratio$libSize / sum(ratio$libSize)
          rownames(ratio) <- ratio$temp
          ratio <- ratio[colnames(true[[j]]),]
          
          true[[j]][i,] <- ratio$libSize
          # ct <- x[,intersect(sampleVec,grep(j, colnames(x)))]
          # true[i,j] <- sum(ct) / sum(mixed[,i])  
        }
        
      }
      
  }
  
  # in the true dataframe, the absence of a celltype is coded as NA; convert this to 0
  true <- lapply(true, function(x) {
    x <- apply(x, 2, function(y) {
      z <- which(is.na(y))
      y[z] <- 0
      return(y)
    })
    return(x)
  })
  
  # create a cpm version of the mixture
  cpm <- apply(mixed, 2, function(x) {
    lib.size <- 10^6 / sum(x)
    x <- x * lib.size  
    return(x)
  })
  cpm <- as.data.frame(cpm)
  
  # function output
  output <- list()
  output$mixture <- list(counts = mixed, cpm = cpm)
  output$true <- true
  return(output)
}
```

```{r creation.mixture}
nMix <- 100 # number of cells to mix per sample
nReps <- 100 # number of samples

#count dataframe
data.thymus.mixture <- as.data.frame(seurat_object.thymus.filtered@assays$RNA@counts)
data.thymus.mixture <- data.thymus.mixture[,thymus.mixture.sampling]

#labels dataframe

bench_thymus <- create.snmeRand(x = data.thymus.mixture,
                            nMix = nMix,
                            nReps = nReps,
                            meta = seurat_object.thymus.filtered@meta.data[thymus.mixture.sampling,],
                            meta.columns = "bigstage",
                            rpkm = FALSE)

bench_thymus$mixture$counts
bench_thymus$true$bigstage

x.thymus <- data.frame(bench_thymus$true$bigstage)
colnames(x.thymus) <-   c("1DN", "2preDP", "3DPbla", "4DPre", "5DPsel", "6CD4sp", "7CD8sp")
#Adding the relative proportions in the main groups.
bench_thymus$true$first.level <- data.frame(DN = x.thymus$`1DN`,
                          DP = x.thymus$`2preDP` + x.thymus$`3DPbla` + x.thymus$`4DPre` + x.thymus$`5DPsel`,
                          CDs = x.thymus$`6CD4sp` + x.thymus$`7CD8sp`)

#sum up 1 all of them
rowSums(bench_thymus$true$first.level)

#For DP
bench_thymus$true$DP <- data.frame(x.thymus[c("2preDP", "3DPbla", "4DPre", "5DPsel")])
bench_thymus$true$DP <- bench_thymus$true$DP/rowSums(bench_thymus$true$DP)
colnames(bench_thymus$true$DP) <- c("2preDP", "3DPbla", "4DPre", "5DPsel")

#sum up 1 all of them
rowSums(bench_thymus$true$DP)


#For CDs
bench_thymus$true$CDs <- data.frame(x.thymus[c("6CD4sp", "7CD8sp")])
bench_thymus$true$CDs <- bench_thymus$true$CDs/rowSums(bench_thymus$true$CDs)
colnames(bench_thymus$true$CDs) <- c("6CD4sp", "7CD8sp")

#sum up 1 all of them
rowSums(bench_thymus$true$CDs)
```

## 1.2. Creation of data for deconvolution

```{r importing.data.preparation.pseudo.bulk.data.object.thymus}

#Mixtures input: pseudobulk data
bench_thymus$mixture$counts
#True proportions
bench_thymus$true


#Now I will create the object with the simulations of 100 pseudobulk data objects.
#I use the new counts object for exporting.
fdata_pseudobulk_thymus <- rownames(bench_thymus$mixture$counts)
pdata_pseudobulk_thymus <- cbind(subjects = colnames(bench_thymus$mixture$counts))
eset.sparse_pseudobulk_thymus <- getESET(as.matrix(bench_thymus$mixture$counts), fdata = fdata_pseudobulk_thymus, pdata = pdata_pseudobulk_thymus)
```

```{r importing.data.preparation.reference.object.thymus}

sparse_matrix_thymus <- as(as.matrix(seurat_object.thymus.signature@assays$RNA@counts), "dgCMatrix")
fdata_split_dataset_thymus <- rownames(sparse_matrix_thymus)
pdata_split_dataset_thymus <- cbind(orig.celltype = as.character(seurat_object.thymus.signature$bigstage),
                             Disorder = as.character('Control'))
eset.sc.sparse_thymus <- getESET(sparse_matrix_thymus, fdata = fdata_split_dataset_thymus, pdata = pdata_split_dataset_thymus)

```

## 1.3 Deconvolution: orig.celltype

```{r creation.hierarchy.thymus}
list_cell_types_thymus.orig.celltype <- c("1DN", "2preDP", "3DPbla", "4DPre", "5DPsel", "6CD4sp", "7CD8sp")

hierarchical_clustering_thymus.orig.celltype <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=list_cell_types_thymus.orig.celltype, 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=c("1DN"), next_level_clustering=NULL), 
             '2'=list(tree_level=1, leaf_number=2, celltype_list=c("2preDP", "3DPbla", "4DPre", "5DPsel"), next_level_clustering=NULL),
             '3'=list(tree_level=1, leaf_number=3, celltype_list=c("6CD4sp", "7CD8sp"), next_level_clustering=NULL)
           )
  )
)

hierarchical_clustering_thymus.orig.celltype.v2 <- list(
  '1'=list(tree_level=0, leaf_number=1, parameters=list(param.logfc.threshold = 1.0,
                                                        param.p_val_adj = 0.05,
                                                        minimum_markers = 4,
                                                        min_delta_cor_threshold = 0.3), 
           celltype_list=list_cell_types_thymus.orig.celltype, 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, name = 'DN', celltype_list=c("1DN"), next_level_clustering=NULL), 
             '2'=list(tree_level=1, leaf_number=2, name = 'DP', parameters=list(param.logfc.threshold = 0.2,
                                                                   param.p_val_adj = 0.05,
                                                                   minimum_markers = 40,
                                                                   min_delta_cor_threshold = 0.3),  
                      celltype_list=c("2preDP", "3DPbla", "4DPre", "5DPsel"), next_level_clustering=NULL),
             '3'=list(tree_level=1, leaf_number=3, name = 'CDs',parameters=list(param.logfc.threshold = 0.6,
                                                                   param.p_val_adj = 0.05,
                                                                   minimum_markers = 8,
                                                                   min_delta_cor_threshold = 0.5),  
                      celltype_list=c("6CD4sp", "7CD8sp"), next_level_clustering=NULL)
           )
  )
)
```

```{r deconvolution.actual.data.experiment.thymus}
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.sparse_thymus
#single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse
hierarchy = hierarchical_clustering_thymus.orig.celltype.v2$`1`
bulk_data = data.frame(as.matrix(eset.sparse_pseudobulk_thymus@assayData$exprs))
sub_clusters_var <- 'orig.celltype'
#sub_clusters_var <- 'bigstage'
sample <- 'Disorder' #just one value: Control
#sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.orig.celltype <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 1.0,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 4,
                                          min_delta_cor_threshold = 0.0,
                                          #percentile_markers.min_corr = 0.0,
                                          #max_iterations = 15000,
                                          #delta_threshold = 1e-15,
                                          verbose = TRUE)
#  mins
end_time <- Sys.time()
end_time - start_time

#root.dir <- '/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/figures_manuscript/'
#save(deco.actual.data.thymus.orig.celltype, file = paste0(root.dir, "deco.actual.data.thymus.orig.celltype.rDAta"))

```

## 1.3. Results of simulation

```{r real.vs.calculated.hierarchi.thymus.orig.celltype}
list_cell_types_thymus.orig.celltype <- c("1DN", "2preDP", "3DPbla", "4DPre", "5DPsel", "6CD4sp", "7CD8sp")

prop.thymus <- deco.actual.data.thymus.orig.celltype$back_propagation_proportions_top_detailed
rownames(prop.thymus) <- list_cell_types_thymus.orig.celltype

cor.calc.vs.true.thymus.orig.celltype <- cor(x=t(prop.thymus)[, list_cell_types_thymus.orig.celltype], y=bench_thymus$true$bigstage[,list_cell_types_thymus.orig.celltype], method='pearson')

cor.calc.vs.true.thymus.orig.celltype

#       reference, mixture
#V1. R=0.639 (50% 50%) for DecoFlex
#V2. R=0.646 (50% 100%) for DecoFlex
#V3. R=0.621 (100% 100%) for DecoFlex
#V4. R=0.668 (65% 35%) for DecoFlex
#V5. R=0.585 (75% 25%) for DecoFlex
#v6. R=0.649 (70% 30%) for DecoFlex
#v7. R=0.659 (65% 25%) for DecoFlex with mixtures: 100/200
#v8. R=0.65 (65% 25%) for DecoFlex with mixtures: 100/300
#v9. R=0.605 (65% 25%) for DecoFlex with mixtures: 100/400
#v10. R=0.638 (65% 25%) for DecoFlex with mixtures: 100/500
#v11. R=0.647 (65% 25%) for DecoFlex with mixtures: 100/50
round(mean(diag(cor.calc.vs.true.thymus.orig.celltype)), 3)

```
Top level: proportions
```{r real.vs.calculated.hierarchi.thymus.first.level}
list_cell_types_thymus.first.level <- c("DN", "DP", "CDs")

prop.thymus.first.level <- deco.actual.data.thymus.orig.celltype$back_propagation_proportions_top
prop.thymus.first.level <- prop.thymus.first.level[paste0('subcluster_level_1_leaf_', 1:3), ]
rownames(prop.thymus.first.level) <- list_cell_types_thymus.first.level

cor.calc.vs.true.thymus.first.level <- cor(x=t(prop.thymus.first.level)[, list_cell_types_thymus.first.level], y=bench_thymus$true$first.level[,list_cell_types_thymus.first.level], method='pearson')

cor.calc.vs.true.thymus.first.level

#reference, mixture:0.815
round(mean(diag(cor.calc.vs.true.thymus.first.level)), 3)

```

DP level: proportions
```{r real.vs.calculated.hierarchi.thymus.DP}
list_cell_types_thymus.DP <- c("2preDP", "3DPbla", "4DPre", "5DPsel")

prop.thymus.DP <- deco.actual.data.thymus.orig.celltype$deco_results_list$subcluster_level_1_leaf_2$back_propagation_proportions_top
prop.thymus.DP <- prop.thymus.DP[c("X2preDP", "X3DPbla", "X4DPre", "X5DPsel"), ]
rownames(prop.thymus.DP) <- list_cell_types_thymus.DP

cor.calc.vs.true.thymus.DP <- cor(x=t(prop.thymus.DP)[, list_cell_types_thymus.DP], y=bench_thymus$true$DP[,list_cell_types_thymus.DP], method='pearson')

cor.calc.vs.true.thymus.DP

#reference, mixture: 0.611
round(mean(diag(cor.calc.vs.true.thymus.DP)), 3)

```
CDs level: proportions
```{r real.vs.calculated.hierarchi.thymus.CDs}
list_cell_types_thymus.CDs <- c("6CD4sp", "7CD8sp")

prop.thymus.CDs <- deco.actual.data.thymus.orig.celltype$deco_results_list$subcluster_level_1_leaf_3$back_propagation_proportions_top
prop.thymus.CDs <- prop.thymus.CDs[c("X6CD4sp", "X7CD8sp"), ]
rownames(prop.thymus.CDs) <- list_cell_types_thymus.CDs

cor.calc.vs.true.thymus.CDs <- cor(x=t(prop.thymus.CDs)[, list_cell_types_thymus.CDs], y=bench_thymus$true$CDs[,list_cell_types_thymus.CDs], method='pearson')

cor.calc.vs.true.thymus.CDs

#reference, mixture: 0.17
round(mean(diag(cor.calc.vs.true.thymus.CDs)), 3)

```


## 1.4 Proportions

```{r functions.performance}

## Mean absolute error (MAE) 
mae <- function(true, est) {
  mean(abs(true - est))
}


## Normalised mean absolute error (nmae)
nmae <- function(true, est) {
  mean(abs(true - est)) / mean(true)
}


## Mean absolute error percentage error (nmae)
mape <- function(true, est) {
  if(length(which(true == 0)) != 0) {
  zeroes <- which(true == 0)
  true <- true[-zeroes]
  est <- est[-zeroes]
  }
  mean(abs((true - est) / true))
}


## Root mean squared error (rmse)
rmse <- function(true, est) {
  sqrt(mean((true - est)^2))
}


## Normalised root mean squared error (nrmse)
nrmse <- function(true, est) {
  rmse(true, est) / mean(true)
}

## General stats function
write.stats <- function(t, e, alg, error) {
  # t for true
  # e for estimate
  # alg for algorithm
  # error is a logical indicating whether an error statistic should be calculated
  
  print('Variables...t')
  print(t)
  print(colnames(t))
  print('Variables...e')
  print(e)
  print(colnames(e))
  
  #Since t and e have the same order, but e change special characters for dot(.) we could use the column names of t.
  colnames(e) <- colnames(t)
  
  # setup
  e <- e[,which(colnames(e) %in% colnames(t))]
  stats <- matrix(NA, 6, length(e))
  rownames(stats) <- c("rho", "r", "rmse", "nrmse", "mae", "nmae")
  colnames(stats) <- colnames(e)
  # if(!(error)) stats <- stats[1:2,] # it is handy to see these rows as NA

  # loop
  for (ct in colnames(e)) {
    print(ct)
      stats["rho",ct] <- cor(t[,ct], e[,ct], method = "s")
      stats["r",ct] <- cor(t[,ct], e[,ct], method = "p")  
    
    
    if (error) {
      stats["rmse",ct] <- rmse(t[,ct], e[,ct])
      stats["nrmse",ct] <- nrmse(t[,ct], e[,ct])
      stats["mae",ct] <- mae(t[,ct], e[,ct])
      stats["nmae",ct] <- nmae(t[,ct], e[,ct])
    }
  }
  
  # final formatting    
  rownames(stats) <- paste0(rownames(stats), "_", alg)
  stats <- signif(stats, 3)
  
  # output
  return(stats)
}



plot.formal.nmae <- function(merge, errors, dataset_name, fills.colours, celltype_order=NULL) {
  
  
  # parameters: based on merge
  if (merge == "merge1") {
    l <- m1.order
    nrow <- 2
    leg <- "right"
  } else {
    l <- m2.order
    nrow <- 1
    leg <- "right"
  }
  
  # parameters
  b <- c(0,0.2,0.5,0.995,2,100)
  lab <- c("< 0.2", "0.2 - 0.5", "0.5 - 1", "1 - 2", "> 2")
  fills <- fills.colours

  
  
  plot.data <- melt(errors)
  plot.data <- plot.data[which(plot.data$L2 == merge),]
  plot.data <- plot.data[which(plot.data$L1 == dataset_name),]
  plot.data <- plot.data[which(plot.data$Var2 == paste0("nmae_Alg")),]
  colnames(plot.data) <- c("Celltype", "Metric", "Value", "Algorithm", "merge", "Signature")
  
    # ...and reorder the x-axis
  if(!is.null(celltype_order)){
    plot.data$Celltype <- factor(plot.data$Celltype, levels = celltype_order)
  }
  
  plot.data$Value <- round(plot.data$Value,3)
  plot.data$nmae <- plot.data$Value
  
  
  plot.data$nmae <- cut(plot.data$nmae, 
                            breaks = b,
                            labels = lab)
  
  # plot
  ggplot(plot.data, aes(x = Celltype, y = Algorithm, fill = nmae, label = Value)) +
    geom_tile(colour = "black") +
    geom_text(size = 2.8) +
    scale_fill_manual(values = fills) +
    theme_bw() +
    theme(legend.position = leg, panel.border = element_blank(), axis.text.x = element_text(angle = 30, hjust = 1),
          axis.title.x = element_blank()) 
}

```

```{r error.thymus.orig.celltype}
list_cell_types_thymus.orig.celltype.order <- c("1DN", "2preDP", "3DPbla", "4DPre", "5DPsel", "6CD4sp", "7CD8sp")

true.thymus <- list()
true.thymus$orig.celltype <- as.data.frame(bench_thymus$true$bigstage)   
  

## Parameters
algs.thymus.orig.celltype <- c("DecoFlex")
sigs.thymus.orig.celltype <- c('thymus')
m1.order.thymus.orig.celltype <- sigs.thymus.orig.celltype
m2.order.thymus.orig.celltype <- c("thymus")

#creating the element est
est.thymus.orig.celltype <- list()
est.thymus.orig.celltype$thymus <- list()

calc.prop.thymus.orig.celltype <- t(prop.thymus)[ ,list_cell_types_thymus.orig.celltype.order]
est.thymus.orig.celltype$thymus$orig.celltype <- list()
est.thymus.orig.celltype$thymus$orig.celltype$DecoFlex <- data.frame(calc.prop.thymus.orig.celltype)
colnames(est.thymus.orig.celltype$thymus$orig.celltype$DecoFlex) <- list_cell_types_thymus.orig.celltype.order



#creating the element errors
errors.thymus.orig.celltype <- list()
for(k in sigs.thymus.orig.celltype) {
  errors.thymus.orig.celltype[[k]] <- list()
  for (j in names(est.thymus.orig.celltype[[k]])) {
    errors.thymus.orig.celltype[[k]][[j]] <- lapply(est.thymus.orig.celltype[[k]][[j]], function(x) {
      return(t(write.stats(t = true.thymus[[j]], e = x, "Alg", TRUE)))
    })
  }  
}
colMeans(errors.thymus.orig.celltype$thymus$orig.celltype$DecoFlex)

```


```{r nmae.thymus.orig.celltype, fig.width=8, fig.height=1.5}
m2.order <- list_cell_types_thymus.orig.celltype.order

#pdf(file = "NMAE - orig.celltype.pdf", height = 3.5, width = 3.5)
plot.formal.nmae(merge='orig.celltype', errors = errors.thymus.orig.celltype, dataset_name = "thymus",
                 fills.colours = rev(c("#008080","#70a494","#b4c8a8","#de8a5a","#ca562c")), 
                 celltype_order = list_cell_types_thymus.orig.celltype.order) + theme(legend.position = "none")
#dev.off()
```

## 1.5 Barplot r values true vs est

```{r scatterplot.mismatch.function}
  ## Scatterplots
  ## Function
  plot.formal.mismatch.scatter <- function(sig, alg, merge, est.object, true.object, plot.information, no.xlab = TRUE, no.ylab = TRUE) {

    e <- est.object[[sig]][[merge]][[alg]]
    t <- true.object[[merge]]
    t <- t[,colnames(e)]
    
    # reformat for plotting
    e <- melt(e)
    t <- melt(t)
    
    plot.data <- data.frame(Celltype = e$variable,
                            Estimate = e$value,
                            True = t$value)
    # add colouring information
    m <- match(plot.data$Celltype, plot.information[[merge]])
    plot.data$Class <- names(plot.information[[merge]][m])
    
    # shuffle order
    plot.data <- plot.data[sample(rownames(plot.data), nrow(plot.data), replace = FALSE),]
    
    # add extra annotation to the title
    lab <- sig
    #if (sig == "CA") lab <- paste0(lab, " (Matched)")
    
    # merge-specific parameters
    if (merge == "merge1") {
      sigma <- 0.5
      annot.x <- 5
      annot.y <- 80
    } else {
      sigma <- 5 
      annot.x <- 20
      annot.y <- 95
    }
    
    # plot
    plot <- ggplot(plot.data, aes(x = True*100, y = Estimate*100, colour = Class)) +
      geom_point(alpha = 1, size = 1) +
      theme_bw() +
      annotate("text", x = annot.x, y = annot.y, label = lab) +
      scale_colour_manual(values = plot.information$universal.palette) +
      scale_x_continuous(trans = pseudo_log_trans(sigma = sigma), limits = c(0, 120), expand = c(0,0), breaks = c(2, 5, 10, 25, 50, 100)) +
      scale_y_continuous(trans = pseudo_log_trans(sigma = sigma), limits = c(0, 120), expand = c(0,0), breaks = c(2, 5, 10, 25, 50, 100)) +
      geom_abline(intercept = 0, slope = 1, linetype = "dotted", color = 'red') +
      theme(legend.position = "none", panel.grid = invis, panel.border = invis,
            axis.line = element_line(), plot.title = element_text(hjust = 0.5), panel.background = element_rect(fill = "grey80")) +
      labs(y = paste0("Estimated Proportion"), x = "True Proportion")
    
    if (no.xlab) plot <- plot + theme(axis.title.x = invis, axis.text.x = invis, axis.ticks.x = invis)
    if (no.ylab) plot <- plot + theme(axis.title.y = invis, axis.text.y = invis, axis.ticks.y = invis)
    
    return(plot)
  }

```

```{r barplot.function}
library(ggplot2)
## Barplot
  plot.formal.barplot <- function(sig, merge, true, est.object, plot.information, celltype_order=NULL, add.enrich.algs = TRUE, ncol = 1, lower.ylim = NA) {
    dat <- sapply(est.object[[sig]][[merge]], function(x) { diag(cor(x, true[[merge]][,colnames(x)])) })    
    dat <- as.data.frame(dat)
    
    dat$Celltype <- rownames(dat)
    dat <- melt(dat)
    
    colnames(dat)[2] <- "Algorithm"
    dat$Algorithm <- factor(dat$Algorithm, levels = rev(c("DecoFlex")))
    levels(dat$Algorithm) <- c("DecoFlex")
    
    # recolour...
    m <- match(dat$Celltype, plot.information[[merge]])
    dat$Class <- names(plot.information[[merge]][m])
    
    # ...and reorder the x-axis
    if(!is.null(celltype_order)){
      dat$Celltype <- factor(dat$Celltype, levels = celltype_order)
    }

    # now plot!
    ggplot(dat, aes(x = Celltype, y = value, fill = Class)) +
      geom_col(position = "dodge", width = 0.7) +
      theme_bw() +
      geom_hline(yintercept = 0) +
      facet_wrap(~Algorithm, ncol = ncol, strip.position = "top") +
      scale_y_continuous(limits = c(lower.ylim, 1), expand = c(0,0)) +
      labs(y = "Estimated vs. True (r)") +
      scale_fill_manual(values = plot.information$universal.palette) +
      geom_hline(yintercept = 0.8, linetype = 2) +
      # theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), panel.border = element_blank(), axis.line.y = element_line(),
      #       axis.title.x = element_blank(), legend.position = "none", axis.ticks.x = element_blank())
      theme(axis.text.x = element_text(angle = 45, hjust = 1), panel.border = element_blank(), axis.line.y = element_line(),
            axis.title.x = element_blank(), legend.position = "none", axis.ticks.x = element_blank())
    
  }
  
```

```{r plot.information.thymus}

    plot.information.thymus.orig.celltype <- lapply(est.thymus.orig.celltype$thymus, function(w) {
    x <- colnames(w[[1]])
    
    names(x)[grep("1DN", x)] <- "1DN"
    names(x)[grep("2preDP", x)] <- "2preDP"
    names(x)[grep("3DPbla", x)] <- "3DPbla"
    names(x)[grep("4DPre", x)] <- "4DPre"
    names(x)[grep("5DPsel", x)] <- "5DPsel"
    names(x)[grep("6CD4sp", x)] <- "6CD4sp"
    names(x)[grep("7CD8sp", x)] <- "7CD8sp"
    
    x <- x[order(names(x))]
    return(x)
  })

  plot.information.thymus <- list()
  plot.information.thymus$orig.celltype <- plot.information.thymus.orig.celltype$orig.celltype
    
  plot.information.thymus$universal.order <- c("1DN", "2preDP", "3DPbla", "4DPre", "5DPsel", "6CD4sp", "7CD8sp")
  plot.information.thymus$universal.palette <- c("#9ccb86", "#f6edbd", "#e9e29c", "#eeb479", "#e88471", "#cf597e", "#e88471")  # this is 
  names(plot.information.thymus$universal.palette) <- plot.information.thymus$universal.order
  
```


```{r barplots_thymus.orig.celltype, fig.width=8, fig.height=3}
y <- -0.05
#pdf(file = "Correlation Barplot - orig.celltype.pdf", height = 6.16, width = 2.3)
plot.formal.barplot(sig="thymus", merge = "orig.celltype", est.object= est.thymus.orig.celltype, true = true.thymus, plot.information = plot.information.thymus, celltype_order = list_cell_types_thymus.orig.celltype.order, add.enrich.algs = FALSE, lower.ylim = y) + labs(y = "") + theme(axis.ticks.y = element_blank()) 
#dev.off()
```


## 1.6 Scatterplot mismatch

```{r plot.mismathc.thymus.orig.celltype, fig.width=5, fig.height=3}
library(scales)
library(cowplot)

## A quick function
invis <- element_blank() # essentially: less to type. this removes an element from a ggplot!

#pdf(file = "NMAE - merge1.pdf", height = 3.5, width = 3.5)
plot.formal.mismatch.scatter(sig = "thymus", alg = "DecoFlex", merge = "orig.celltype", est.object = est.thymus.orig.celltype, true.object = true.thymus, plot.information = plot.information.thymus, no.xlab = FALSE, no.ylab = FALSE) + theme(legend.position = "right") + theme_light()
#dev.off()
```

## 1.7 Scatterplot by celltype


```{r scatterplot.by.celltype.function}
## A formal scatterplot...
   plot.formal.scatter <- function(e = NA, t = NA, sig, alg, merge, est, true, plot.information, celltype_order = NULL, autopath = TRUE, nrow = NULL, calc.error = TRUE) {
    if (autopath) {
      e <- est[[sig]][[merge]][[alg]]
      t <- true[[merge]]
    }
  
    t <- t[,colnames(e)]
    
    # get correlations!
    cor <- diag(cor(e, t))
    cor <- round(cor, 3)
    
    # get nmae
    if (calc.error) {
      err <- list()
      for (j in colnames(e)) { err[[j]] <- nmae(t[,j], e[,j]) }
      err <- do.call("c", err)
      err <- signif(err, 3)  
      err <- paste0("; nmae=", err)
    } else {
      err <- ""
    }
    
    
    # reformat for plotting
    e <- melt(e)
    t <- melt(t)
    
    plot.data <- data.frame(Celltype = e$variable,
                            Estimate = e$value,
                            True = t$value)
  
    # add colouring information
    m <- match(plot.data$Celltype, plot.information[[merge]])
    plot.data$Class <- names(plot.information[[merge]][m])
    
    # add correlation information
    levels(plot.data$Celltype) <- paste0(levels(plot.data$Celltype), "\nr=", cor, err)
    
    # ...and reorder the x-axis
    if(!is.null(celltype_order)){
      plot.data$Celltype <- factor(plot.data$Celltype, levels = celltype_order)
    }
    
    # plot
    ggplot(plot.data, aes(x = True, y = Estimate, fill = Class)) +
      geom_point(colour = "black", shape = 21) +
      facet_wrap(~Celltype, scales = "free", nrow = nrow) +
      theme_bw() +
      #lm
      geom_smooth(method = "lm", se = FALSE, colour = "red", linetype="dashed", linewidth = 0.5, span = 0.3) +
      #geom_abline(intercept = 0, slope = 1, size = 0.5, colour = "red", linetype = "dashed") +
      scale_fill_manual(values = plot.information$universal.palette) +
      # scale_x_continuous(n.breaks = 3) +
      # scale_y_continuous(n.breaks = 3) +
      theme(legend.position = "none", axis.text.x = element_text(angle = 30, hjust = 1, size = 6), strip.background = invis,
            strip.text = element_text(size = 6), axis.text.y = element_text(size = 6), panel.grid = invis) +
      labs(y = paste0("Estimated Proportion (", alg, "+", sig, ")"), y = "True Proportion")
  }
  
```

```{r scatter.plot.by.celltype.orig.celltype.thymus, fig.width=4, fig.height=7}
  # plot all algorithms using orig.clusters.average 
  #pdf(file = "Final Scatterplot - All Celltypes.pdf", height = 5.5, width = 8)

print(plot.formal.scatter(sig = "thymus", alg = 'DecoFlex', merge = "orig.celltype", est = est.thymus.orig.celltype, true=true.thymus, plot.information = plot.information.thymus, nrow = 5) + labs(y = paste0('DecoFlex', " Proportion")))  

  #dev.off()
```


# 2. Pipeline for deconvolutions

# 2.1. Manual hierarchy analysis 

```{r correlation.thymus, fig.width=10, fig.height=10}
#I create the reference of all celltypes
reference_w.9.celltypes.thymus <- create_basis_one(x = eset.sc.thymus.6.8.w.sparse,
                                            ct.sub = paste0('cluster_', c(1:8)),
                                            ct.varname = 'cluster_normalized_bigstage',
                                            sample = 'age')

#TODO check if this is the same function...
reference.thymus <- decoflex_build_cell_reference(x = eset.sc.thymus.6.8.w.sparse, 
                                                  ct.varname = 'cluster_normalized_bigstage', 
                                                  sample = 'age')

color_gradient <- colorRampPalette(c("white","steelblue"))

reference_w.9.celltypes.thymus.with.names <- reference_w.9.celltypes.thymus$basis[, paste0('cluster_', c(1:8))]
colnames(reference_w.9.celltypes.thymus.with.names) <- cluster_list.thymus.bigstage$bigstage[c(1:8)]

cor.reference_matrix_w.9.celltypes.thymus <- cor(reference_w.9.celltypes.thymus.with.names)
gplots::heatmap.2(cor.reference_matrix_w.9.celltypes.thymus,
                  cellnote = round(cor.reference_matrix_w.9.celltypes.thymus, 2), 
                  trace="none",
                  col=color_gradient(10),
                  breaks=seq(0,1,0.1),
                  margins=c(12,12), 
                  cexRow = 1, cexCol = 1, 
                  dendrogram = "both", 
                  key=FALSE)

```

Let's try to see how is the hierarchy in the original dataset.
```{r hierarchy.analysis}

# Finding distance matrix
distance_mat <- dist(t(cor(reference_w.9.celltypes.thymus.with.names)), method = 'euclidean')

#distance_mat <- dist(t(log(reference_w.9.celltypes.thymus$basis + 1e-10)), method = 'euclidean')

# Fitting Hierarchical clustering Model
# to training dataset
set.seed(240)  # Setting seed,  "complete", "average"
Hierar_cl <- hclust(distance_mat, method = "complete")
#Hierar_cl
 
# Plotting dendrogram
plot(Hierar_cl)
 
# Choosing no. of clusters
# Cutting tree by height
abline(h = 110, col = "green")
 
# Cutting tree by no. of clusters
fit_9_celltypes.thymus <- cutree(Hierar_cl, k = 4 )
fit_9_celltypes.thymus
 
table(fit_9_celltypes.thymus)
rect.hclust(Hierar_cl, k = 2, border = "green")
 
```


# 2.2. Creation of manual hierarchy

```{r hierarchy.creation}

#Binary hierarchy.
hierarchical_clustering_sc_thymus.v1 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(1:7)), 
           next_level_clustering=NULL
  )
)


#Binary hierarchy.
hierarchical_clustering_sc_thymus.v2 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(1:8)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(1)), next_level_clustering=NULL), 
             '2'=list(tree_level=1, leaf_number=2, celltype_list=paste0('cluster_', c(2:5)), next_level_clustering=NULL),
             '3'=list(tree_level=1, leaf_number=3, celltype_list=paste0('cluster_', c(6)), next_level_clustering=NULL),
             '4'=list(tree_level=1, leaf_number=4, celltype_list=paste0('cluster_', c(7)), next_level_clustering=NULL)
           )
  )
)

#Binary hierarchy.
hierarchical_clustering_sc_thymus.v3 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(1:7)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(1)), next_level_clustering=NULL), 
             '2'=list(tree_level=1, leaf_number=2, celltype_list=paste0('cluster_', c(2:5)), next_level_clustering=NULL),
             '3'=list(tree_level=1, leaf_number=3, celltype_list=paste0('cluster_', c(6:7)), next_level_clustering=NULL)
           )
  )
)

```


# 2.3. Deconvolution with simulation

```{r deconvolution.simulation}
#detach(package:DecoFlex,unload=TRUE)
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse
hierarchy = hierarchical_clustering_sc_thymus.v1
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE


start_time <- Sys.time()

#let's run de simulation
deco.simulation.thymus.tree_guided.recursive.results <- 
  run_deconvolution_simulation_generic_recursive(single_cell_data_exp = single_cell_data_exp, 
                                                 hierarchy = hierarchy,
                                                 sub_clusters_var = sub_clusters_var,
                                                 sample = sample, 
                                                 use_min_cor_strategy = use_min_cor_strategy, 
                                                 delete_shared_level_markers = delete_shared_level_markers, 
                                                 delete_shared_internal_markers = delete_shared_internal_markers,
                                                 param.logfc.threshold = 1.5,
                                                 param.p_val_adj = 0.05,
                                                 verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

# 2.4. Deconvolution with manual hierarchy

Now we will run the deconvolution with the actual bulk dataset from Thymus experiment.
```{r deconvolution.manual.hierarchy}
library(DecoFlex)


order_normalized <- paste0('cluster_', c(1:7))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.00000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.00000001


#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse
hierarchy = hierarchical_clustering_sc_thymus.v3$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.results <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 0.8,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 4,
                                          min_delta_cor_threshold = 0.0,
                                          verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```


# 2.5. Plot real proportions vs WT

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion}

order_normalized <- paste0('cluster_', c(1:7))
order_samples <- c('sample_6W')
list_pseudotime <- cluster_list.thymus.bigstage$bigstage[1:7]

#Calculate the proportion for clusters for 7 clusters
real_proportion <- data.frame(deco.simulation.thymus.tree_guided.recursive.results$pseudo.bulk.data$truep)
real_proportion <- t(real_proportion)
rownames(real_proportion) <- order_samples
real_proportion <- data.frame(real_proportion)

real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]

real_proportion.pseudotime.rescaled <- NULL
for(counter in 1:nrow(real_proportion.pseudotime)){
  new_row <- real_proportion.pseudotime[counter,]/sum(real_proportion.pseudotime[counter,])
  real_proportion.pseudotime.rescaled <- rbind(real_proportion.pseudotime.rescaled, new_row)
}

#just checking. Everything should sum up 1.
rowSums(real_proportion.pseudotime.rescaled)
#Adding names
colnames(real_proportion.pseudotime.rescaled) <- list_pseudotime


#A. Data from expression, methylation: partial
wt_data <- t(deco.actual.data.thymus.results$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')])


wt_data <- data.frame(wt_data)
colnames(wt_data) <- list_pseudotime


#Joinning the bulk data wt
comparison_real_vs_deconvolution <- rbind(wt_data, real_proportion.pseudotime.rescaled)


thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))

thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))


thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)

thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_KO'] <- 'KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'Thy_ALKpos_KO'] <- 'ALKKO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_6W'] <- '6w_thymus')

##thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO', 'ALK', 'ALKKO', '4w_thymus', '8w_thymus', '24w_thymus'))

thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl','6w_thymus'))

#real proportion vs control
thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)

p <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% c('6w_thymus', 'Ctrl') & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
  geom_point(size=6, shape=20, alpha = .40, position=position_jitter(width=.3,height=.00)) +
  labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text=element_text(size=16),
        legend.title = element_text(size = 16),
          legend.text = element_text(size = 16)) + 
  ylim(0, 0.8)
 
p +  scale_color_manual(name = "Sample", breaks = c('6w_thymus', 'Ctrl'), values = c("#136c38", "red")) + theme_light()
```

# 2.6. Plot real proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion}
order_normalized <- paste0('cluster_', c(1:8))
order_samples <- c('sample_6W')
list_pseudotime <- cluster_list.thymus.bigstage$bigstage[1:8]

#Calculate the proportion for clusters for 7 clusters
real_proportion <- data.frame(deco.simulation.thymus.tree_guided.recursive.results$pseudo.bulk.data$truep)
real_proportion <- t(real_proportion)
rownames(real_proportion) <- order_samples
real_proportion <- data.frame(real_proportion)

real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]

real_proportion.pseudotime.rescaled <- NULL
for(counter in 1:nrow(real_proportion.pseudotime)){
  new_row <- real_proportion.pseudotime[counter,]/sum(real_proportion.pseudotime[counter,])
  real_proportion.pseudotime.rescaled <- rbind(real_proportion.pseudotime.rescaled, new_row)
}

#just checking. Everything should sum up 1.
rowSums(real_proportion.pseudotime.rescaled)
#Adding names
colnames(real_proportion.pseudotime.rescaled) <- list_pseudotime


# E. Data from expression, methylation: partial model
experimental_data <- t(deco.actual.data.thymus.results$back_propagation_proportions_top_detailed[order_normalized, ])



experimental_data <- data.frame(experimental_data)
colnames(experimental_data) <- list_pseudotime


#Joining the bulk data wt
comparison_real_vs_deconvolution <- rbind(experimental_data, real_proportion.pseudotime.rescaled)


thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))

thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))


thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)

thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_KO'] <- 'KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'Thy_ALKpos_KO'] <- 'ALKKO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_6W'] <- '6w_thymus')

thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO', 'ALK', 'ALKKO', '6w_thymus'))

#thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO'))

#real proportion vs control
thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)

p <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% c('Ctrl', 'KO', 'ALK', 'ALKKO') & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
  geom_point(size=6, shape=20, alpha = .50, position=position_jitter(width=.3,height=.00)) +
  labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text=element_text(size=16),
        legend.title = element_text(size = 16),
          legend.text = element_text(size = 16)) + 
  ylim(0, 0.9)
 
p +  scale_color_manual(name = "Sample", breaks = c('6w_thymus','Ctrl', 'KO', 'ALK', 'ALKKO'), values = c("turquoise3" , "#136c38", "blue", "red", "orange")) + theme_light()
```
## Fix if problemas

```{r}
load('/Users/crhisto/Google Drive/PHD_PROJECT/UNIVERSITY/033_third_gerda_collaboration/papers/paper_3/data/T_cell_development/x_object.rData')
ct.sub = 'subcluster_level_1_leaf_1'
ct.varname = 'metacluster_level_0'
sample= 'age'

create_basis_one(x = x,
                                            ct.sub = paste0('cluster_', c(1:7)),
                                            ct.varname = 'cluster_normalized_bigstage',
                                            sample = 'age')

```

```{r}

load('/Users/crhisto/Google Drive/PHD_PROJECT/UNIVERSITY/033_third_gerda_collaboration/papers/paper_3/data/T_cell_development/reference_object.rData')
load('/Users/crhisto/Google Drive/PHD_PROJECT/UNIVERSITY/033_third_gerda_collaboration/papers/paper_3/data/T_cell_development/markers_object.rData')

calculate_joint_cor <- function(reference, markers){

  cor_matrix <- stats::cor(reference[markers,])
  n_col <- ncol(reference)
  joint_cor <- (sum(cor_matrix)-sum(diag(cor_matrix)))/(n_col*n_col-n_col)
  return(joint_cor)
}
```


# 3. Model with less cell-types

# 3.1 Reduced metadata

```{r reduced.medatada}
add_metacluster_complete.v1 <- function (sc.eset){
  
  #1 "1DN", 
  sc.eset$metacluster[sc.eset$cluster_normalized_bigstage %in% c("cluster_1")] <- "cluster_1"
  
  #2 "2preDP", "3DPbla", "4DPre", "5DPsel", 
  sc.eset$metacluster[sc.eset$cluster_normalized_bigstage %in% c(paste0("cluster_", 2:5))] <- "cluster_2"
  
  #3 "6CD4sp", "7CD8sp"
  sc.eset$metacluster[sc.eset$cluster_normalized_bigstage %in% c(paste0("cluster_", 6:7))] <- "cluster_3"
  
  #4 "9NCL", "10APC"
  sc.eset$metacluster[sc.eset$cluster_normalized_bigstage %in% c(paste0("cluster_", 8:9))] <- "cluster_4"

  ############################################
  sc.eset
}

add_metacluster_complete.v2 <- function (sc.eset){
  
  #1 "1DN", 
  sc.eset$metacluster[sc.eset$cluster_normalized_bigstage %in% c("cluster_1")] <- "cluster_1"
  
  #2 "2preDP", "3DPbla"
  sc.eset$metacluster[sc.eset$cluster_normalized_bigstage %in% c(paste0("cluster_", 2:3))] <- "cluster_2"
  
  #3 , "4DPre", "5DPsel", 
  sc.eset$metacluster[sc.eset$cluster_normalized_bigstage %in% c(paste0("cluster_", 4:5))] <- "cluster_3"
  
  #3 "6CD4sp"
  sc.eset$metacluster[sc.eset$cluster_normalized_bigstage %in% c(paste0("cluster_", 6))] <- "cluster_4"
  
  #3 "7CD8sp"
  sc.eset$metacluster[sc.eset$cluster_normalized_bigstage %in% c(paste0("cluster_", 7))] <- "cluster_5"
  
  #4 "9NCL", "10APC"
  sc.eset$metacluster[sc.eset$cluster_normalized_bigstage %in% c(paste0("cluster_", 8:9))] <- "cluster_6"

  ############################################
  sc.eset
}


eset.sc.thymus.6.8.w.sparse.metacluster <- add_metacluster_complete.v1(eset.sc.thymus.6.8.w.sparse)
table(eset.sc.thymus.6.8.w.sparse.metacluster$metacluster)

```


```{r hierarchy.creation.reduced}

#Binary hierarchy: 0.6-0.8 working fine with 4 minimum with metacluster and 4 celltypes
hierarchical_clustering_sc_thymus.reduced.v1 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(1:3)), 
           next_level_clustering=NULL
  )
)

hierarchical_clustering_sc_thymus.reduced.v1 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(1:3)), 
           next_level_clustering=NULL
  )
)

#Binary hierarchy.
hierarchical_clustering_sc_thymus.reduced.v2 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(1:5)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(1)), next_level_clustering=NULL), 
             '2'=list(tree_level=1, leaf_number=2, celltype_list=paste0('cluster_', c(2:3)), next_level_clustering=NULL),
             '3'=list(tree_level=1, leaf_number=3, celltype_list=paste0('cluster_', c(4:5)), next_level_clustering=NULL)
           )
  )
)

#Only for cd4 and cd8
hierarchical_clustering_sc_thymus.reduced.v3 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(6:7)), 
           next_level_clustering=NULL
  )
)

# Only for DN
hierarchical_clustering_sc_thymus.reduced.v4 <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(2:5)), 
           next_level_clustering=NULL
  )
)

#Binary hierarchy.
hierarchical_clustering_sc_thymus.reduced.v5 <- list(
  '1'=list(tree_level=0, leaf_number=1, parameters=list(param.logfc.threshold = 1.0,
                                                        param.p_val_adj = 0.05,
                                                        minimum_markers = 4,
                                                        min_delta_cor_threshold = 0.3), 
           celltype_list=paste0('cluster_', c(1:7)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(1)), next_level_clustering=NULL), 
             '2'=list(tree_level=1, leaf_number=2, parameters=list(param.logfc.threshold = 0.2,
                                                                   param.p_val_adj = 0.05,
                                                                   minimum_markers = 40,
                                                                   min_delta_cor_threshold = 0.3),  
                      celltype_list=paste0('cluster_', c(2:5)), next_level_clustering=NULL),
             '3'=list(tree_level=1, leaf_number=3, parameters=list(param.logfc.threshold = 0.6,
                                                                   param.p_val_adj = 0.05,
                                                                   minimum_markers = 8,
                                                                   min_delta_cor_threshold = 0.5),  
                      celltype_list=paste0('cluster_', c(6:7)), next_level_clustering=NULL)
           )
  )
)

```


# 3.2. TOP MODEL

## 3.2.1 Simulation

```{r hierarchy.top}
hierarchical_clustering_sc_thymus.reduced.top <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(1:3)), 
           next_level_clustering=NULL
  )
)
```


```{r deconvolution.simulation.top}
#detach(package:DecoFlex,unload=TRUE)
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster[, eset.sc.thymus.6.8.w.sparse.metacluster$metacluster %in% paste0('cluster_', 1:3)]
hierarchy = hierarchical_clustering_sc_thymus.reduced.top
sub_clusters_var <- 'metacluster'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.simulation.thymus.tree_guided.recursive.reduced.results.top <- 
  run_deconvolution_simulation_generic_recursive(single_cell_data_exp = single_cell_data_exp, 
                                                 hierarchy = hierarchy,
                                                 sub_clusters_var = sub_clusters_var,
                                                 sample = sample, 
                                                 use_min_cor_strategy = use_min_cor_strategy, 
                                                 delete_shared_level_markers = delete_shared_level_markers, 
                                                 delete_shared_internal_markers = delete_shared_internal_markers,
                                                 param.logfc.threshold = 1.0,
                                                 param.p_val_adj = 0.05,
                                                 verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

## 3.2.2 Deconvolution with manual hierarchy

Now we will run the deconvolution with the actual bulk dataset from Thymus experiment.
```{r deconvolution.manual.hierarchy.top}
library(DecoFlex)

order_normalized <- paste0('cluster_', c(1:3))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WT_4", "Tumor_ALKpos_WT_5", "Tumor_ALKpos_WT_6", "Tumor_ALKpos_WT_7")

#Just the wt and double ko
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

standard_name_thymus <- c("Thy_KO_1", "Thy_KO_2", "Thy_KO_3")

standard_name_thymus <- c('Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

standard_name_thymus <- c("Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001


#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.top$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'metacluster'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.reduced.results.top <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 1.0,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 4,
                                          min_delta_cor_threshold = 0.3,
                                          verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

### 3.3.2.1 Proportions WT simulation

```{r function_to_plot}


plot_proportions_thymus <- function(order_normalized, order_samples, list_pseudotime, true_proportions, actual_proportions, levels, colors){

  #Calculate the proportion for clusters for 4 clusters
  real_proportion <- data.frame(true_proportions)
  real_proportion <- t(real_proportion)
  rownames(real_proportion) <- order_samples
  real_proportion <- data.frame(real_proportion)
  
  real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]
  
  real_proportion.pseudotime.rescaled <- NULL
  for(counter in 1:nrow(real_proportion.pseudotime)){
    new_row <- real_proportion.pseudotime[counter,]/sum(real_proportion.pseudotime[counter,])
    real_proportion.pseudotime.rescaled <- rbind(real_proportion.pseudotime.rescaled, new_row)
  }
  
  #just checking. Everything should sum up 1.
  rowSums(real_proportion.pseudotime.rescaled)
  #Adding names
  colnames(real_proportion.pseudotime.rescaled) <- list_pseudotime
  
  
  #A. Data from expression, methylation: partial
  wt_data <- t(actual_proportions)
  
  
  wt_data <- data.frame(wt_data)
  colnames(wt_data) <- list_pseudotime
  
  
  #Joinning the bulk data wt
  comparison_real_vs_deconvolution <- rbind(wt_data, real_proportion.pseudotime.rescaled)

  
  thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))
  
  thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))
  
  
  thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
  thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)
  
  thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)
  
  thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')
  thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_KO'] <- 'KO')
  
  thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
  thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 16) == 'Tumor_ALKpos_WTa'] <- 'ALKa')
  
  thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'Thy_ALKpos_KO'] <- 'ALKKO')

  thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 18) == 'Tumor_ALK_Hdac1_KO'] <- 'ALK_Hdac1_KO')
  
  thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_6W'] <- '6w_thymus')
  
  ##thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO', 'ALK', 'ALKKO', '4w_thymus', '8w_thymus', '24w_thymus'))
  
  thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= levels)
  
  #real proportion vs control
  thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)
  
  p <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% levels & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
    geom_point(size=6, shape=20, alpha = .40, position=position_jitter(width=.3,height=.00)) +
    labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
      theme(axis.text.x = element_text(angle = 45, hjust = 1), 
          axis.text=element_text(size=16),
          legend.title = element_text(size = 16),
            legend.text = element_text(size = 16)) + 
    ylim(0, 1.0)
   
  p +  scale_color_manual(name = "Sample", breaks = levels, values = colors) + theme_light()
}


```


Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion.reduced.top}

order_normalized <- paste0('cluster_', c(1:3))
order_samples <- c('sample_6W')
#list_pseudotime <- c('DN','DP1','DP2', 'CD4', 'CD8','Others')
list_pseudotime <- c('DN','DP','CDs','Others')
list_pseudotime<- list_pseudotime[1:3]


#Plotting the top model
plot_top.wt_vs_ctrl <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.top$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.top$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')], 
                        levels = c('Ctrl','6w_thymus'), 
                        colors = c("#136c38", "red"))
plot(plot_top.wt_vs_ctrl)


message(paste0(cor(deco.simulation.thymus.tree_guided.recursive.reduced.results.top$pseudo.bulk.data$truep, 
                  rowMeans(deco.actual.data.thymus.reduced.results.top$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')]))))

#save_plot_as_pdf(plot_top.wt_vs_ctrl, 'plot_proportions_top.wt_vs_ctrl.pdf', 8, 5)

```
### 3.3.2.2 Plot real proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r real.proportions.top}

order_normalized <- paste0('cluster_', c(1:3))
order_samples <- c('sample_6W')
#list_pseudotime <- c('DN','DP1','DP2', 'CD4', 'CD8','Others')
list_pseudotime <- c('DN','DP','CDs','Others')
list_pseudotime<- list_pseudotime[1:3]


#Plotting the top model
plot_top.all.results <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.top$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.top$back_propagation_proportions_top_detailed[order_normalized, ], 
                        levels = c('Ctrl', 'KO', 'ALK','ALKKO'), 
                        colors = c("turquoise3" , "#136c38", "blue", "red", "pink", "orange")[c(2:4, 6)])
plot(plot_top.all.results)

save_plot_as_pdf(plot_top.all.results, 'plot_proportions_top.all.results.pdf', 8, 5)


```

```{r plot_comparison_ctrl_proportion.reduced.to.manual.function}
order_normalized <- paste0('cluster_', c(1:7))
order_samples <- c('sample_6W')
#list_pseudotime <- c('DN','DP1','DP2', 'CD4', 'CD8','Others')
#list_pseudotime <- c('DN','DP','CDs','Others')
#list_pseudotime <- c('CD4','CD8')
#list_pseudotime <- c("2preDP", "3DPbla", "4DPre", "5DPsel")
list_pseudotime <- cluster_list.thymus.bigstage$bigstage[1:7]
list_pseudotime<- list_pseudotime[1:7]

#Calculate the proportion for clusters for 7 clusters
real_proportion <- NULL
real_proportion <- data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results$pseudo.bulk.data$truep)
real_proportion <- t(real_proportion)
rownames(real_proportion) <- order_samples
real_proportion <- data.frame(real_proportion)

real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]

real_proportion.pseudotime.rescaled <- NULL
for(counter in 1:nrow(real_proportion.pseudotime)){
  new_row <- real_proportion.pseudotime[counter,]/sum(real_proportion.pseudotime[counter,])
  real_proportion.pseudotime.rescaled <- rbind(real_proportion.pseudotime.rescaled, new_row)
}

#just checking. Everything should sum up 1.
rowSums(real_proportion.pseudotime.rescaled)
#Adding names
colnames(real_proportion.pseudotime.rescaled) <- list_pseudotime


# E. Data from expression, methylation: partial model
experimental_data <- NULL
experimental_data <- t(deco.actual.data.thymus.reduced.results$back_propagation_proportions_top_detailed[order_normalized, ])



experimental_data <- data.frame(experimental_data)
colnames(experimental_data) <- list_pseudotime


#Joining the bulk data wt
comparison_real_vs_deconvolution <- rbind(experimental_data, real_proportion.pseudotime.rescaled)


thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))

thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))


thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)

thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_KO'] <- 'KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 16) == 'Tumor_ALKpos_WTa'] <- 'ALKa')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'Thy_ALKpos_KO'] <- 'ALKKO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 18) == 'Tumor_ALK_Hdac1_KO'] <- 'ALK_Hdac1_KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_6W'] <- '6w_thymus')

thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO', 'ALK', 'ALKa','ALKKO', 'ALK_Hdac1_KO', '6w_thymus'))

#thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO'))

#real proportion vs control
thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)

p <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% c('Ctrl', 'KO', 'ALK', 'ALKa', 'ALKKO', 'ALK_Hdac1_KO') & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
  geom_point(size=6, shape=20, alpha = .50, position=position_jitter(width=.3,height=.00)) +
  labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text=element_text(size=16),
        legend.title = element_text(size = 16),
          legend.text = element_text(size = 16)) + 
  ylim(0, 1.0)
 
p +  scale_color_manual(name = "Sample", breaks = c('6w_thymus','Ctrl', 'KO', 'ALK', 'ALKa', 'ALKKO', 'ALK_Hdac1_KO'), values = c("turquoise3" , "#136c38", "blue", "red", "pink", "orange", "violet")) + theme_light()
```

# 3.3. DP Double-positive model

## 3.3.1 Simulation

```{r hierarchy.dp}
# Only for DN
hierarchical_clustering_sc_thymus.reduced.dp <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(2:5)), 
           next_level_clustering=NULL
  )
)
```


```{r deconvolution.simulation.dp}
#detach(package:DecoFlex,unload=TRUE)
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.dp
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.simulation.thymus.tree_guided.recursive.reduced.results.dp <- 
  run_deconvolution_simulation_generic_recursive(single_cell_data_exp = single_cell_data_exp, 
                                                 hierarchy = hierarchy,
                                                 sub_clusters_var = sub_clusters_var,
                                                 sample = sample, 
                                                 use_min_cor_strategy = use_min_cor_strategy, 
                                                 delete_shared_level_markers = delete_shared_level_markers, 
                                                 delete_shared_internal_markers = delete_shared_internal_markers,
                                                 param.logfc.threshold = 0.2,
                                                 param.p_val_adj = 0.05,
                                                 verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

## 3.3.2 Deconvolution with manual hierarchy

Now we will run the deconvolution with the actual bulk dataset from Thymus experiment.
```{r deconvolution.manual.hierarchy.dp}
library(DecoFlex)

order_normalized <- paste0('cluster_', c(2:5))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WT_4", "Tumor_ALKpos_WT_5", "Tumor_ALKpos_WT_6", "Tumor_ALKpos_WT_7")

#Just the wt and double ko
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

standard_name_thymus <- c("Thy_KO_1", "Thy_KO_2", "Thy_KO_3")

standard_name_thymus <- c('Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

standard_name_thymus <- c("Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001


#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.dp$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.reduced.results.dp <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 0.2,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 40,
                                          min_delta_cor_threshold = 0.3,
                                          verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

### 3.3.2.1 Proportions WT simulation

```{r plot_comparison_ctrl_proportion.reduced.dp}

order_normalized <- paste0('cluster_', c(2:5))
order_samples <- c('sample_6W')
list_pseudotime <- c("2preDP", "3DPbla", "4DPre", "5DPsel")
list_pseudotime<- list_pseudotime[1:4]

#Plotting the top model
plot_dp.wt_vs_ctrl <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.dp$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.dp$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')], 
                        levels = c('Ctrl','6w_thymus'), 
                        colors = c("#136c38", "red"))
print(plot_dp.wt_vs_ctrl)

true.data.dp <- deco.simulation.thymus.tree_guided.recursive.reduced.results.dp$pseudo.bulk.data$truep[order_normalized]
true.data.dp <- true.data.dp/sum(true.data.dp)
message(paste0(cor(true.data.dp, 
                  rowMeans(deco.actual.data.thymus.reduced.results.dp$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')]))))

#save_plot_as_pdf(plot_dp.wt_vs_ctrl, 'plot_proportions_dp.wt_vs_ctrl.pdf', 8, 5)


```

### 3.3.2.2 Plot real proportions

```{r real.proportions.dp}

order_normalized <- paste0('cluster_', c(2:5))
order_samples <- c('sample_6W')
list_pseudotime <- c("2preDP", "3DPbla", "4DPre", "5DPsel")
list_pseudotime<- list_pseudotime[1:4]

#Plotting the top model
plot_dp.all.results <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.dp$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.dp$back_propagation_proportions_top_detailed[order_normalized, ], 
                        levels = c('Ctrl', 'KO', 'ALK','ALKKO'), 
                        colors = c("turquoise3" , "#136c38", "blue", "red", "pink", "orange")[c(2:4, 6)])
plot(plot_dp.all.results)

save_plot_as_pdf(plot_dp.all.results, 'plot_proportions_dp.all.results.pdf', 8, 5)

```

# 3.4. CDs - CD4-CD8 model

## 3.4.1 Simulation

```{r hierarchy.cds}
#Only for cd4 and cd8
hierarchical_clustering_sc_thymus.reduced.cds <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(6:7)), 
           next_level_clustering=NULL
  )
)
```


```{r deconvolution.simulation.cds}
#detach(package:DecoFlex,unload=TRUE)
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.cds
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.simulation.thymus.tree_guided.recursive.reduced.results.cds <- 
  run_deconvolution_simulation_generic_recursive(single_cell_data_exp = single_cell_data_exp, 
                                                 hierarchy = hierarchy,
                                                 sub_clusters_var = sub_clusters_var,
                                                 sample = sample, 
                                                 use_min_cor_strategy = use_min_cor_strategy, 
                                                 delete_shared_level_markers = delete_shared_level_markers, 
                                                 delete_shared_internal_markers = delete_shared_internal_markers,
                                                 param.logfc.threshold = 0.6,
                                                 param.p_val_adj = 0.05,
                                                 verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

## 3.4.2 Deconvolution with manual hierarchy

Now we will run the deconvolution with the actual bulk dataset from Thymus experiment.
```{r deconvolution.manual.hierarchy.cds}
library(DecoFlex)

order_normalized <- paste0('cluster_', c(6:7))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WT_4", "Tumor_ALKpos_WT_5", "Tumor_ALKpos_WT_6", "Tumor_ALKpos_WT_7")

#Just the wt and double ko
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

standard_name_thymus <- c("Thy_KO_1", "Thy_KO_2", "Thy_KO_3")

standard_name_thymus <- c('Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

standard_name_thymus <- c("Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001


#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.cds$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.reduced.results.cds <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 0.6,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 8,
                                          min_delta_cor_threshold = 0.5,
                                          verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

### 3.4.2.1 Proportions WT simulation

```{r plot_comparison_ctrl_proportion.reduced.cds}

order_normalized <- paste0('cluster_', c(6:7))
order_samples <- c('sample_6W')
list_pseudotime <- c('CD4','CD8')

#Plotting the top model
plot_cds.wt_vs_ctrl <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.cds$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.cds$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')], 
                        levels = c('Ctrl','6w_thymus'), 
                        colors = c("#136c38", "red"))
plot(plot_cds.wt_vs_ctrl)


true.data.cds <- deco.simulation.thymus.tree_guided.recursive.reduced.results.cds$pseudo.bulk.data$truep[order_normalized]
true.data.cds <- true.data.cds/sum(true.data.cds)
correlation.cds <- round(cor(true.data.cds, 
                  rowMeans(deco.actual.data.thymus.reduced.results.cds$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')])), 5)
message(paste0())

#save_plot_as_pdf(plot_cds.wt_vs_ctrl, 'plot_proportions_cds.wt_vs_ctrl.pdf', 8, 5)

```

### 3.4.2.2 Plot real proportions

```{r real.proportions.cds}

order_normalized <- paste0('cluster_', c(6:7))
order_samples <- c('sample_6W')
list_pseudotime <- c('CD4','CD8')

#Plotting the top model
plot_cds.all.results <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.cds$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.cds$back_propagation_proportions_top_detailed[order_normalized, ], 
                        levels = c('Ctrl', 'KO', 'ALK','ALKKO'), 
                        colors = c("turquoise3" , "#136c38", "blue", "red", "pink", "orange")[c(2:4, 6)])
plot(plot_cds.all.results)

save_plot_as_pdf(plot_cds.all.results, 'plot_proportions_cds.all.results.pdf', 8, 5)

```

# 3.5. COMPLETE MODEL

## 3.4.1 Simulation

```{r hierarchy.complete}

hierarchical_clustering_sc_thymus.reduced.flat.complete <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(1:7)), 
           next_level_clustering=NULL
  )
)

#Binary hierarchy.
hierarchical_clustering_sc_thymus.reduced.complete <- list(
  '1'=list(tree_level=0, leaf_number=1, parameters=list(param.logfc.threshold = 1.0,
                                                        param.p_val_adj = 0.05,
                                                        minimum_markers = 4,
                                                        min_delta_cor_threshold = 0.3), 
           celltype_list=paste0('cluster_', c(1:7)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(1)), next_level_clustering=NULL), 
             '2'=list(tree_level=1, leaf_number=2, parameters=list(param.logfc.threshold = 0.2,
                                                                   param.p_val_adj = 0.05,
                                                                   minimum_markers = 40,
                                                                   min_delta_cor_threshold = 0.3),  
                      celltype_list=paste0('cluster_', c(2:5)), next_level_clustering=NULL),
             '3'=list(tree_level=1, leaf_number=3, parameters=list(param.logfc.threshold = 0.6,
                                                                   param.p_val_adj = 0.05,
                                                                   minimum_markers = 8,
                                                                   min_delta_cor_threshold = 0.5),  
                      celltype_list=paste0('cluster_', c(6:7)), next_level_clustering=NULL)
           )
  )
)
```

TODO: fix the problem with top category as only one group
```{r deconvolution.simulation.complete}
#detach(package:DecoFlex,unload=TRUE)
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.complete
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.simulation.thymus.tree_guided.recursive.reduced.results.complete <- 
  run_deconvolution_simulation_generic_recursive(single_cell_data_exp = single_cell_data_exp, 
                                                 hierarchy = hierarchy,
                                                 sub_clusters_var = sub_clusters_var,
                                                 sample = sample, 
                                                 use_min_cor_strategy = use_min_cor_strategy, 
                                                 delete_shared_level_markers = delete_shared_level_markers, 
                                                 delete_shared_internal_markers = delete_shared_internal_markers,
                                                 param.logfc.threshold = 1.0,
                                                 param.p_val_adj = 0.05,
                                                 verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

## 3.4.2 Deconvolution with manual hierarchy

Now we will run the deconvolution with the actual bulk dataset from Thymus experiment.
```{r deconvolution.manual.hierarchy.complete}
library(DecoFlex)


order_normalized <- paste0('cluster_', c(1:7))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WT_4", "Tumor_ALKpos_WT_5", "Tumor_ALKpos_WT_6", "Tumor_ALKpos_WT_7")

#Just the wt and double ko
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

standard_name_thymus <- c("Thy_KO_1", "Thy_KO_2", "Thy_KO_3")

standard_name_thymus <- c('Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

standard_name_thymus <- c("Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001


#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.complete$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.reduced.results.complete <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 1.0,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 20,
                                          min_delta_cor_threshold = 0.5,
                                          verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

### 3.4.2.1 Proportions WT simulation

```{r plot_comparison_ctrl_proportion.reduced.complete}

order_normalized <- paste0('cluster_', c(1:7))
order_samples <- c('sample_6W')
list_pseudotime <- cluster_list.thymus.bigstage$bigstage[1:7]

#Plotting the top model
plot_complete_join.wt_vs_ctrl <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.complete$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.complete$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')], 
                        levels = c('Ctrl','6w_thymus'), 
                        colors = c("#136c38", "red"))
plot(plot_complete_join.wt_vs_ctrl)

correlation.complete_model <- round(cor(deco.simulation.thymus.tree_guided.recursive.reduced.results.complete$pseudo.bulk.data$truep[order_normalized], rowMeans(deco.actual.data.thymus.reduced.results.complete$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')])), 5)
message(paste0(correlation.complete_model))

#save_plot_as_pdf(plot_complete_join.wt_vs_ctrl, 'plot_proportions_complete_join.wt_vs_ctrl.pdf', 8, 5)


```

### 3.4.2.2 Plot real proportions

```{r real.proportions.complete}

order_normalized <- paste0('cluster_', c(1:7))
order_samples <- c('sample_6W')
list_pseudotime <- cluster_list.thymus.bigstage$bigstage[1:7]

#Plotting the top model
plot_complete_join.all.results <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.complete$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.complete$back_propagation_proportions_top_detailed[order_normalized, ], 
                        levels = c('Ctrl', 'KO', 'ALK','ALKKO'), 
                        colors = c("turquoise3" , "#136c38", "blue", "red", "pink", "orange")[c(2:4, 6)])
plot(plot_complete_join.all.results)


save_plot_as_pdf(plot_complete_join.all.results, 'plot_proportions_complete_join.all.results.pdf', 8, 5)


```


# 3.6 Marker analysis

```{r tpm.convertion}

# michael's version
# https://support.bioconductor.org/p/91218/
tpm_function <- function(counts,len) {
  x <- counts/len
  return(t(t(x)*1e6/colSums(x)))
}

#actual data
len.values <- colSums(eset.thymus.bulk.sparse.df.filtered)
eset.thymus.bulk.sparse.df.filtered.tpm <- tpm_function(counts=eset.thymus.bulk.sparse.df.filtered, len=len.values)

#pseudo bulk data all 7 celltypes
len.values <- colSums(deco.simulation.thymus.tree_guided.recursive.reduced.results.top$pseudo.bulk.data$pseudo_eset@assayData$exprs)
sc.pseudo.bulk.data.top <- tpm_function(counts=deco.simulation.thymus.tree_guided.recursive.reduced.results.top$pseudo.bulk.data$pseudo_eset@assayData$exprs, len=len.values)

#pseudo bulk data all dp celltypes
len.values <- colSums(deco.simulation.thymus.tree_guided.recursive.reduced.results.dp$pseudo.bulk.data$pseudo_eset@assayData$exprs)
sc.pseudo.bulk.data.dp <- tpm_function(counts=deco.simulation.thymus.tree_guided.recursive.reduced.results.dp$pseudo.bulk.data$pseudo_eset@assayData$exprs, len=len.values)

#pseudo bulk data all dp celltypes
len.values <- colSums(deco.simulation.thymus.tree_guided.recursive.reduced.results.cds$pseudo.bulk.data$pseudo_eset@assayData$exprs)
sc.pseudo.bulk.data.cds <- tpm_function(counts=deco.simulation.thymus.tree_guided.recursive.reduced.results.cds$pseudo.bulk.data$pseudo_eset@assayData$exprs, len=len.values)
```

Now, I will try to distinguist between unique markers and duplicated one
```{r duplicated.top.analysis.function}

create_dataset_markers_multiple_levels <- function(result_level_object, level_list){
  
  #all the genes por level
  top.level.marker.genes <- result_level_object$markers.top.clusters.object$total_markers
  
  top.markers.detailed_all = NULL
  top.markers.detailed_with_repetition = NULL
  for (counter_level in level_list) {
    #Getting the indivigual groups for level
    top.level.marker.genes.subcluster <- rownames(result_level_object$markers.top.clusters.object$list_markers[[counter_level]])
    #Creation of one dataframe with all genes repited
    top.markers.detailed <- data.frame(cbind(gene_name = intersect(top.level.marker.genes.subcluster, top.level.marker.genes), group = paste0('', counter_level)))
    
    
    #Version without repetition and deleting that from subcluster 2 to 1.
    top.markers.detailed.filtered <- top.markers.detailed[!(top.markers.detailed$gene_name %in% top.markers.detailed_all$gene_name), ]
    
    #without_repetition
    if(is.null(top.markers.detailed_all)){
      top.markers.detailed_all <-data.frame(top.markers.detailed.filtered)
      
    }else{
      top.markers.detailed_all <- rbind(top.markers.detailed_all, top.markers.detailed.filtered)
    }
    
    #Version with repetition to check the sharing genes between celltypes
    if(is.null(top.markers.detailed_with_repetition)){
      top.markers.detailed_with_repetition <-data.frame(top.markers.detailed)
      
    }else{
      top.markers.detailed_with_repetition <- rbind(top.markers.detailed_with_repetition, top.markers.detailed)
    }
  }
  
  
  #Checking repetition
  top.markers.detailed_all$repetition <- !duplicated(top.markers.detailed_all$gene_name)
  
  #Those genes doesn't exist in bulk data.
  delete.genes <- c()
  top.markers.detailed_all <- top.markers.detailed_all[!(top.markers.detailed_all$gene_name %in% delete.genes),]
  
  #Order of groups
  top.markers.detailed_all$group <- factor(x = top.markers.detailed_all$group, levels = unique(top.markers.detailed_all$group))
  rownames(top.markers.detailed_all) <- top.markers.detailed_all$gene_name

  return(list(top.markers.detailed_all = top.markers.detailed_all, 
              top.markers.detailed_with_repetition = top.markers.detailed_with_repetition))
}

```

```{r data.markers.top}
#Version with the marker dataset and the marker repited by celltype
top.level.1.markers.detailed_all <- create_dataset_markers_multiple_levels(
  result_level_object = deco.actual.data.thymus.reduced.results.complete,
  level_list = c('subcluster_level_1_leaf_1', 'subcluster_level_1_leaf_2', 'subcluster_level_1_leaf_3'))
```

Now we need and differencial expression analysis over the bulk data to identify the up and down-regulated genes.
```{r differential.expression.analysis.thymus}

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

countdata <- as.matrix(eset.thymus.bulk.sparse@assayData$exprs)
countdata <- countdata[,standard_name_thymus]

#I put numbers on it because other wise I wouldn't get  ko vs wt.
type <- c("real_tumor","real_tumor","real_tumor",
          "real_tumor","real_tumor","real_tumor",
          "real_tumor","real_tumor","real_tumor",
          "real_tumor","real_tumor","real_tumor")

treatment <- c("Thy_WT","Thy_WT","Thy_WT",
                 "Thy_KO","Thy_KO","Thy_KO",
                 "Thy_ALKpos_WT","Thy_ALKpos_WT","Thy_ALKpos_WT",
                 "Thy_ALKpos_KO","Thy_ALKpos_KO","Thy_ALKpos_KO"
                 )

time <- c("18w","18w","18w",
          "18w","18w","18w",
          "18w","18w","18w",
          "18w","18w","18w")

replicates  <- c("1","2","3",
                 "1","2","3",
                 "1","2","3",
                 "1","2","3")

#secondary information
sample <- paste0("count_", 1:12)

coldata <- as.data.frame(cbind(replicates, treatment, time, sample, type))
rownames(coldata) <- NULL

#building the object DESeqDataSet
ddsFullCountTable <- DESeqDataSetFromMatrix(
  countData = countdata,
  colData = coldata,
  design = ~treatment)

#giving the order and setting the control sample for the analyisis, which is - in this case - the real Tumor_ALKpos_WT.
ddsFullCountTable$treatment <- factor(ddsFullCountTable$treatment, levels = c("Thy_WT", "Thy_ALKpos_WT", "Thy_KO", "Thy_ALKpos_KO"))

  
dds <- ddsFullCountTable

## Pre-filter
dds <- dds[ rowSums(counts(dds)) > 1, ]

## The rlog and variance stabilizing transformations => homoskedastic data
rld <- rlog(dds, blind = FALSE)
vsd <- vst(dds, blind = FALSE)
dds <- estimateSizeFactors(dds)
normalized.wt.bulk <- counts(dds, normalized=TRUE)

dds <- DESeq(dds)
resultsNames(dds)

  
RES.thymus.lfc <- list(Intercept = results(dds, name = "Intercept"),
                       treatment_Thy_ALKpos_WT_vs_Thy_WT = results(dds, name = "treatment_Thy_ALKpos_WT_vs_Thy_WT"), 
                         treatment_Thy_KO_vs_Thy_WT = results(dds, name = "treatment_Thy_KO_vs_Thy_WT"), 
                         treatment_Thy_ALKpos_KO_vs_Thy_WT = results(dds, name = "treatment_Thy_ALKpos_KO_vs_Thy_WT"))


RES.thymus.lfc


#now lets check the genes that I should include
select_markers_de <- function(de_object){
  rownames(de_object[which(abs(de_object$log2FoldChange) >= 8 & de_object$padj <= 0.05),])
}

#64
de_genes.thymus <- c(select_markers_de(RES.thymus.lfc$treatment_Thy_ALKpos_WT_vs_Thy_WT),
              select_markers_de(RES.thymus.lfc$treatment_Thy_KO_vs_Thy_WT),
              select_markers_de(RES.thymus.lfc$treatment_Thy_ALKpos_KO_vs_Thy_WT))

#61 We hope that this will be enough to describe the missing celltype.
de_genes.thymus <- unique(de_genes.thymus)

```

```{r function.plot}


#Function to plot the heatmaps with the level marker genes.
plot_heatmap_markers_multiple_level <- function(
  sc.eset.metacluster.all, 
  sc.bulk.data.filtered.tpm, 
  pseudo.bulk.df.filtered.tpm,
  res.object.de, 
  top.markers.detailed_all, 
  list_cell_types,
  row_km_value = 1, 
  color_left_groups = NULL, 
  clustering_variable = 'cluster_normalized_bigstage', 
  column.clusters = NULL, scale_activated=TRUE, 
  show_legends = TRUE){
  
  ############# IMPORTING DATASETS
  
  #1.1. pseduo bulk data:p2 and p11. I have to use the filter for the marker genes unique. I use tpm
  sc.bulk.data.p2.p11 <- data.frame(pseudo.bulk.df.filtered.tpm)
  
  #1.2. bulk data
  sc.bulk.data.wt.ko <- data.frame(sc.bulk.data.filtered.tpm[, ])
  
  #1.3. DE data
  bulk.data.wt.ko.de <- data.frame(res.object.de)
  #Filtering the values with zero and NA in the differential Expression analysis.
  bulk.data.wt.ko.de <- na.omit(bulk.data.wt.ko.de)
  
  #2.1. Now we have to intersect everything, even with the total marker genes.
  pseudo.sc.bulk.vs.ko.wt.bulk <- intersect(rownames(sc.bulk.data.p2.p11), rownames(sc.bulk.data.wt.ko))
  
  #2.2. Intersection with de dataset
  bulks.vs.de.data <- intersect(pseudo.sc.bulk.vs.ko.wt.bulk, rownames(bulk.data.wt.ko.de))
  
  #2.3. FINAL INTERSECTION: with marker genes: markers
  bulks.de.vs.markers <- intersect(bulks.vs.de.data, top.markers.detailed_all$gene_name)
  
  print( (paste(top.markers.detailed_all$gene_name, collapse=', ' )))
  
  #2.4. Now I'm going to filter the main dataset with markers with the intersected markers found. I double checked the order of both datasets: they supposed to keep the order
  (paste(top.markers.detailed_all$gene_name, collapse=', ' ))
  top.markers.detailed_all <- top.markers.detailed_all[top.markers.detailed_all$gene_name %in% bulks.de.vs.markers, ]
  (paste(top.markers.detailed_all$gene_name, collapse=', ' ))
  
  ########### STEPS TO PLOT THE HEATMAP BY CELLTYPE WITH CORRESPONDING MARKER GENES.
  

  #################DATA
  #################SINGLE CELL PSEUDO BULK DATA
  #I have to use the filter for the marker genes unique. I use tpm
  
  #ordering with duplicates
  sc.bulk.data.p2.p11.temp <- sc.bulk.data.p2.p11[top.markers.detailed_all$gene_name,]
  sc.bulk.data.p2.p11.temp <- as.data.frame(sc.bulk.data.p2.p11.temp)
  colnames(sc.bulk.data.p2.p11.temp) <- colnames(sc.bulk.data.p2.p11)
  rownames(sc.bulk.data.p2.p11.temp) <- top.markers.detailed_all$gene_name
  sc.bulk.data.p2.p11 <- sc.bulk.data.p2.p11.temp
  
  #log1p
  sc.bulk.data.p2.p11.scaled <- log1p(sc.bulk.data.p2.p11)
  sc.bulk.data.p2.p11.scaled$gene_name <- rownames(sc.bulk.data.p2.p11)
  
  
  #DNMT1 BULK DATA
  
  #ordering with duplicates
  sc.bulk.data.wt.ko <- sc.bulk.data.wt.ko[match(top.markers.detailed_all$gene_name, rownames(sc.bulk.data.wt.ko)), ] 
  sc.bulk.data.wt.ko.scaled <- log1p(sc.bulk.data.wt.ko)
  sc.bulk.data.wt.ko.scaled$gene_name <- rownames(sc.bulk.data.wt.ko)
  
  
  sc.bulk.data <- cbind(sc.bulk.data.p2.p11, sc.bulk.data.wt.ko)
  sc.bulk.data.scaled <- cbind(sc.bulk.data.p2.p11.scaled, sc.bulk.data.wt.ko.scaled)

  #I could use the function scale but lets try with the original tpm
  sc.bulk.data <- data.frame(sc.bulk.data)
  sc.bulk.data.scaled <- data.frame(sc.bulk.data.scaled)
  rownames(sc.bulk.data) <- (top.markers.detailed_all$gene_name)
  rownames(sc.bulk.data.scaled) <- (top.markers.detailed_all$gene_name)
  
  
  #adding differential analysis result
  bulk.data.wt.ko.de$gene_name <- rownames(bulk.data.wt.ko.de)
  bulk.data.wt.ko.de.filtered <- bulk.data.wt.ko.de[rownames(bulk.data.wt.ko.de) %in% top.markers.detailed_all$gene_name,]
  
  
  #######SINGLE CELL CONFIGURATION
  
  #1. Filter cells for just three cell-types: 
  cells.collection.complete <- sc.eset.metacluster.all[,sc.eset.metacluster.all[[clustering_variable]] %in% paste0('cluster_', list_cell_types)]
  
  cells.collection.matrix <- as.matrix(cells.collection.complete@assayData$exprs)
  rownames(cells.collection.matrix) <- rownames(cells.collection.complete)
  cells.collection.matrix <- data.frame(cells.collection.matrix)
  

  ##########NORMAL CONFIGURATION
  
  level_list <- unique(top.markers.detailed_all$group)
  sc.data.duplicated.all <- NULL
  for(counter_level in 1:length(level_list)){
    #let's filter with the markers
    cells.collection.matrix.filtered <- filter(cells.collection.matrix, rownames(cells.collection.matrix) %in% top.markers.detailed_all[top.markers.detailed_all$group == level_list[counter_level],]$gene_name)
    
    sc.data.duplicated.all <- rbind(sc.data.duplicated.all,
                                    as.matrix(cells.collection.matrix.filtered))
  }
  
  ############# COLUMNS
  
  if(!is.null(column.clusters)){
    
    library(RColorBrewer)
    n <- length(column.clusters)
    qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
    col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

    colors_list_parametric <- sample(col_vector, n)
    colour.columns.list <- c(colors_list_parametric)
    names(colour.columns.list) <- column.clusters
    
    # Define color for the cell type variable
    colour.columns <- list(cell_type = colour.columns.list)
    
    #Define the columns and levels for the celltypes
    column.values <- data.frame(column.names = cells.collection.complete[[clustering_variable]])
    column.values$column.names <- factor(x = column.values$column.names, levels = column.clusters)
    
  }else{
    # Define colors for each levels of qualitative variables
    color.clusters.1.to.7 <- c("#F8766D", "#C49A00", "#53B400", "#00C094", "#00B6EB", "#A58AFF", "#FB61D7")
    # Define color for the cell type variable
    colour.columns <- list(cell_type = c("cluster_1" = color.clusters.1.to.7[1], 
                                         "cluster_2" = color.clusters.1.to.7[2], 
                                         "cluster_3" = color.clusters.1.to.7[3], 
                                         "cluster_4" = color.clusters.1.to.7[4], 
                                         "cluster_5" = color.clusters.1.to.7[5], 
                                         "cluster_6" = color.clusters.1.to.7[6],
                                         "cluster_7" = color.clusters.1.to.7[7]))
    
    column.values <- data.frame(column.names = cells.collection.complete[[clustering_variable]])
    column.values$column.names <- factor(x = column.values$column.names, levels = paste0('cluster_', c(1:7)))
  }
  
  library(ComplexHeatmap)
  
  # Create the heatmap annotation columns
  ha.columns <- HeatmapAnnotation(
    cell_type = column.values$column.names,
    col = colour.columns
  )
  
  
  ################# ROWS
  
  
  ################# ROWS
  
  # Define gradient color for each level
  colour.rows.left_list <- NULL
  for(couter_level in 1:length(level_list)){
    
    #To get the color coding of the left annotation right.
    if(is.null(color_left_groups)){
      colour.rows.left_list <- c(colour.rows.left_list, color.clusters.1.to.7[couter_level])
    }else{
      colour.rows.left_list <- c(colour.rows.left_list, color_left_groups[couter_level])
    }

  }
  names(colour.rows.left_list) <- level_list
  
  colour.rows.left <- list(marker_type = colour.rows.left_list)
  top.markers.detailed_all$group <- factor(x = top.markers.detailed_all$group, levels = unique(top.markers.detailed_all$group))
  
  # Create the heatmap annotation rows
  ha.rows.left <- rowAnnotation(
    marker_type = top.markers.detailed_all$group,
    col = colour.rows.left
  )
  
  
  
  ########### ROW RIGHT
  
  
  #new approach of color coding
  #########################
  
  sc.bulk.cols.6.colors <-function(n) {
    colorRampPalette(rev(c("red4","red2","tomato2","orange","gold1","forestgreen")))(6)                                
  }
  
  min_value.sc <- min(sc.bulk.data.scaled$sample_6W)
  max_value.sc <- max(sc.bulk.data.scaled$sample_6W)
  
  min_value.bulk <- min(sc.bulk.data.scaled$Thy_WT_1, sc.bulk.data.scaled$Thy_WT_2, sc.bulk.data.scaled$Thy_WT_3,
                        sc.bulk.data.scaled$Thy_KO_1, sc.bulk.data.scaled$Thy_KO_12, sc.bulk.data.scaled$Thy_KO_3,
                        sc.bulk.data.scaled$Tumor_ALKpos_WT_1, sc.bulk.data.scaled$Tumor_ALKpos_WT_2, sc.bulk.data.scaled$Tumor_ALKpos_WT_3,
                        sc.bulk.data.scaled$Thy_ALKpos_KO_1, sc.bulk.data.scaled$Thy_ALKpos_KO_2, sc.bulk.data.scaled$Thy_ALKpos_KO_3)
  
  max_value.bulk <- max(sc.bulk.data.scaled$Thy_WT_1, sc.bulk.data.scaled$Thy_WT_2, sc.bulk.data.scaled$Thy_WT_3,
                        sc.bulk.data.scaled$Thy_KO_1, sc.bulk.data.scaled$Thy_KO_12, sc.bulk.data.scaled$Thy_KO_3,
                        sc.bulk.data.scaled$Tumor_ALKpos_WT_1, sc.bulk.data.scaled$Tumor_ALKpos_WT_2, sc.bulk.data.scaled$Tumor_ALKpos_WT_3,
                        sc.bulk.data.scaled$Thy_ALKpos_KO_1, sc.bulk.data.scaled$Thy_ALKpos_KO_2, sc.bulk.data.scaled$Thy_ALKpos_KO_3)
  
  calculate_range <- function(min, max, number){
  step <- (max-min)/(number-1)
  
  result <- c(min)
  for (counter in 1:(number)) {
    result <- c(result, result[counter-1]+step)
  }
  
  result
}
  
  values.sc <- circlize::colorRamp2(calculate_range(min_value.sc, max_value.sc, 6), sc.bulk.cols.6.colors(6))
  values.bulk <- circlize::colorRamp2(calculate_range(min_value.bulk, max_value.bulk, 6), sc.bulk.cols.6.colors(6))
  
  #limit based on the limit set as minimum
  values.de.min <- min((bulk.data.wt.ko.de.filtered$log2FoldChange), na.rm = TRUE)
  values.de.max <- max(c(max((bulk.data.wt.ko.de.filtered$log2FoldChange), na.rm = TRUE),
                         abs(min(bulk.data.wt.ko.de.filtered$log2FoldChange, na.rm = TRUE))))
  print(paste0('min: ', values.de.min, 'max: ', values.de.max))
  values.de <- circlize::colorRamp2(calculate_range(values.de.min,
                                                    values.de.max, 6),
                                    sc.bulk.cols.6.colors(6))
  
  
  colour.rows.right.v2 <- list(sample_6W = values.sc,
                               Thy_WT_1 = values.bulk, Thy_WT_2 = values.bulk, Thy_WT_3 = values.bulk,
                               Thy_KO_1 = values.bulk, Thy_KO_2 = values.bulk, Thy_KO_3 = values.bulk,
                               Tumor_ALKpos_WT_1 = values.bulk, Tumor_ALKpos_WT_2 = values.bulk, Tumor_ALKpos_WT_3 = values.bulk,
                               Thy_ALKpos_KO_1 = values.bulk, Thy_ALKpos_KO_2 = values.bulk, Thy_ALKpos_KO_3 = values.bulk,
                               de =   values.de)
  
  ###################
  ha.rows.right.v2 <- rowAnnotation(
    sample_6W =   sc.bulk.data.scaled$sample_6W, 
    Thy_WT_1 = sc.bulk.data.scaled$Thy_WT_1, 
    Thy_WT_2 = sc.bulk.data.scaled$Thy_WT_2, 
    Thy_WT_3 = sc.bulk.data.scaled$Thy_WT_3, 
    Thy_KO_1 = sc.bulk.data.scaled$Thy_KO_1, 
    Thy_KO_2 = sc.bulk.data.scaled$Thy_KO_2, 
    Thy_KO_3 = sc.bulk.data.scaled$Thy_KO_3, 
    Tumor_ALKpos_WT_1 = sc.bulk.data.scaled$Tumor_ALKpos_WT_1, 
    Tumor_ALKpos_WT_2 = sc.bulk.data.scaled$Tumor_ALKpos_WT_2, 
    Tumor_ALKpos_WT_3 = sc.bulk.data.scaled$Tumor_ALKpos_WT_3, 
    Thy_ALKpos_KO_1 = sc.bulk.data.scaled$Thy_ALKpos_KO_1, 
    Thy_ALKpos_KO_2 = sc.bulk.data.scaled$Thy_ALKpos_KO_2, 
    Thy_ALKpos_KO_3 = sc.bulk.data.scaled$Thy_ALKpos_KO_3, 
    de = bulk.data.wt.ko.de.filtered[match(top.markers.detailed_all$gene_name, rownames(bulk.data.wt.ko.de.filtered)), 'log2FoldChange'],
    col = colour.rows.right.v2,
    show_legend = c(rep(show_legends, 14))
  )
  
  
  
  #NORMAL CONFIGURATION
  if(scale_activated){
    data <- t(scale(t(as.matrix(sc.data.duplicated.all)), center = TRUE, scale = TRUE))
    data[is.nan(data)] <- 0
  }else{
    data <- t((t(as.matrix(sc.data.duplicated.all))))
  }


  # Combine the heatmap and the annotation
  heatmap.two.groups  <- Heatmap(data, name = "Markers",
                                 cluster_columns = FALSE,
                                 column_dend_reorder = FALSE,
                                 cluster_rows = TRUE,#
                                 row_dend_reorder = TRUE,#
                                 show_column_names = FALSE,
                                 row_km = row_km_value,
                                 column_split = column.values$column.names,
                                 row_split = top.markers.detailed_all$group,
                                 row_labels = top.markers.detailed_all$gene_name,
                                 row_names_gp = gpar(fontsize = 9),
                                 column_names_gp = gpar(fontsize = 7),
                                 left_annotation = ha.rows.left, 
                                 right_annotation = ha.rows.right.v2,
                                 top_annotation = ha.columns,
                                 column_dend_height = unit(90, "mm"), 
                                 row_dend_width =  unit(60, "mm"), 
                                 column_title_rot = 90,
                                 row_title = 'Marker genes'
  )
  
  print(heatmap.two.groups)
  
  return(list(sc.bulk.data = sc.bulk.data,
              sc.bulk.data.scaled = sc.bulk.data.scaled,
              bulk.data.wt.ko.de.filtered = bulk.data.wt.ko.de.filtered, 
              sc.data = data, 
              plot = heatmap.two.groups))
}
```


## 3.6.1 Top model


```{r heatmap.level.top, fig.height=8, fig.width=15}
#Plot with heatmap level 1
plot.level.1 <- plot_heatmap_markers_multiple_level(
                     sc.eset.metacluster.all = eset.sc.thymus.6.8.w.sparse.metacluster,
                     sc.bulk.data.filtered.tpm = eset.thymus.bulk.sparse.df.filtered.tpm,
                     pseudo.bulk.df.filtered.tpm = sc.pseudo.bulk.data.top,
                     res.object.de = RES.thymus.lfc$treatment_Thy_ALKpos_WT_vs_Thy_WT, 
                     top.markers.detailed_all = top.level.1.markers.detailed_all$top.markers.detailed_all,
                     clustering_variable = 'cluster_normalized_bigstage',
                     list_cell_types = c(1:7), 
                     row_km_value = 2,
                     column.clusters = paste0('cluster_', 1:7),
                     color_left_groups = c("#D55E00", "#CC79A7", "skyblue"), 
                     scale_activated = TRUE
                     )

save_plot_as_pdf(plot.level.1$plot, 'plot.level.top_normal_model.pdf', 20, 9)


```


## 3.6.2 DN model


```{r heatmap.level.1.2.dn, fig.height=20, fig.width=15}
#Version with the marker dataset and the marker repited by celltype
top.level.1.2.markers.detailed_all <- create_dataset_markers_multiple_levels(
  result_level_object = deco.actual.data.thymus.reduced.results.complete$deco_results_list$subcluster_level_1_leaf_2,
  level_list = paste0('cluster_', 2:5))

#Plot with heatmap level 1.2
plot.level.1.2 <- plot_heatmap_markers_multiple_level(
                     sc.eset.metacluster.all = eset.sc.thymus.6.8.w.sparse.metacluster,
                     sc.bulk.data.filtered.tpm = eset.thymus.bulk.sparse.df.filtered.tpm,
                     pseudo.bulk.df.filtered.tpm = sc.pseudo.bulk.data.dp,
                     res.object.de = RES.thymus.lfc$treatment_Thy_ALKpos_WT_vs_Thy_WT, 
                     top.markers.detailed_all = top.level.1.2.markers.detailed_all$top.markers.detailed_all,
                     clustering_variable = 'cluster_normalized_bigstage',
                     list_cell_types = c(2:5), 
                     row_km_value = ,
                     column.clusters = paste0('cluster_', 2:5),
  color_left_groups = c("#D55E00", "#CC79A7", "skyblue", "brown"))

save_plot_as_pdf(plot.level.1.2$plot, 'plot.level.dn_normal_model.pdf', 20, 22)


```

## 3.6.3 CDs - CD4 CD8

```{r heatmap.level.1.3.cds, fig.height=7, fig.width=14}
#Version with the marker dataset and the marker repited by celltype
top.level.1.3.markers.detailed_all <- create_dataset_markers_multiple_levels(
  result_level_object = deco.actual.data.thymus.reduced.results.complete$deco_results_list$subcluster_level_1_leaf_3,
  level_list = paste0('cluster_', 6:7))

#Plot with heatmap level 1.2
plot.level.1.3 <- plot_heatmap_markers_multiple_level(
                     sc.eset.metacluster.all = eset.sc.thymus.6.8.w.sparse.metacluster,
                     sc.bulk.data.filtered.tpm = eset.thymus.bulk.sparse.df.filtered.tpm,
                     pseudo.bulk.df.filtered.tpm = sc.pseudo.bulk.data.cds,
                     res.object.de = RES.thymus.lfc$treatment_Thy_ALKpos_WT_vs_Thy_WT, 
                     top.markers.detailed_all = top.level.1.3.markers.detailed_all$top.markers.detailed_all,
                     clustering_variable = 'cluster_normalized_bigstage',
                     list_cell_types = c(6:7), 
                     row_km_value = 1,
                     column.clusters = paste0('cluster_', 6:7),
  color_left_groups = c("#D55E00", "#CC79A7", "skyblue", "brown"))

save_plot_as_pdf(plot.level.1.3$plot, 'plot.level.cds_normal_model.pdf', 15, 6)

```

# 3. Deconvolution with methylation data

## 3.1 Methylation data

Now I will import the methylation data. Check this: https://nbis-workshop-epigenomics.readthedocs.io/en/latest/content/tutorials/methylationSeq/Seq_Tutorial.html
```{r import.methylation.data}

load('data_thymus/meth/MethylKitDiffs.rData')

# Now I will get the object with all samples, filter it and join the samples
methylation.filtered <- filterByCoverage(myobj, lo.count=10, lo.perc=NULL, hi.count=NULL, hi.perc=99.9)
methylation.filtered.norm <- normalizeCoverage(methylation.filtered, method = "median")
methylation.filtered.united <- methylKit::unite(methylation.filtered.norm, destrand=FALSE)
perc.meth.thymus <- percMethylation(methylation.filtered.united)/100

# Adding identifiers to be able to create Z matrix and make comparisons 
# with other references
rownames(perc.meth.thymus) <- paste0('cg_', methylation.filtered.united$start)
perc.meth.thymus <- data.frame(perc.meth.thymus)
perc.meth.thymus$chr <- methylation.filtered.united$chr
perc.meth.thymus$start <- methylation.filtered.united$start
perc.meth.thymus$end <- methylation.filtered.united$end
perc.meth.thymus$strand <- methylation.filtered.united$strand

# Let's rename the samples to be compatible with the bulk data
# The original order: "C1","C2","C3","KO1","KO2","KO3","Tu1","Tu2","Tu3","AlkKO1","AlkKO2","AlkKO3"
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")
                     
colnames(perc.meth.thymus) <- c(standard_name_thymus, c('chr', 'start', 'end', 'strand'))

#Finally I have the methylation level for each CpG and each sample
summary(perc.meth.thymus)
nrow(perc.meth.thymus)
ncol(perc.meth.thymus)

#Lets save the data in the final state.
#save(perc.meth.thymus, file = "data_thymus/meth/methylation_thymus_12_samples.rData")
#load(file = "data_thymus/meth/methylation_thymus_12_samples.rData")

hist(as.matrix(perc.meth.thymus[,standard_name_thymus]), main = 'Histogram Methylation')

```
Filtering of the methylation data
```{r methylation.filters}

load(file = "data_thymus/meth/methylation_thymus_12_samples.rData")

perc.meth.thymus.df <- data.frame(perc.meth.thymus)

nrow(perc.meth.thymus.df) #92884

filter_activated <- FALSE

if(filter_activated){
  # 1. filter rows with zero and ones
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df %>% filter(rowSums(across(where(is.numeric)))!=0) # 33678 rows
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df.filtered %>% filter(rowSums(across(where(is.numeric)))!=1) # 33678 rows
  
  # 2. filter rows with at least 1 zero: 28.296
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df.filtered[apply(perc.meth.thymus.df.filtered,1, function(x) all(x!=0)),]
  
  
  # 3. filter if four have zero 29.244
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df.filtered[apply(perc.meth.thymus.df.filtered,1, function(x) sum(x==0, na.rm=TRUE) < 4),]
  
  # 4.filtering of values iqual zero and values equal 1.
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df.filtered[apply(perc.meth.thymus.df.filtered,1, function(x) sum(x==0, na.rm=TRUE) <= 0),] # 27.296 rows
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df.filtered[apply(perc.meth.thymus.df.filtered,1, function(x) sum(x==1, na.rm=TRUE) <= 0),]# 8.042 rows
  
}else{
  perc.meth.thymus.df.filtered <- perc.meth.thymus.df
}

```

Now I will take the methylation data and relate it with genes.
```{r methylation.join.genes}
check_install_load_library('BSgenome.Mmusculus.UCSC.mm10')
check_install_load_library('org.Mm.eg.db')
check_install_load_library('GenomicFeatures')
check_install_load_library("TxDb.Mmusculus.UCSC.mm10.knownGene")
check_install_load_library("biovizBase")
check_install_load_library("genomation")

###
# let's check the genes

# 1. I can also download the database as library.
mm10KG <- TxDb.Mmusculus.UCSC.mm10.knownGene

# Importing just genes for normal chromosomes and with the gene_id
chromosome_list <- c(paste0('chr', 1:19), 'chrX', 'chrY')
filter <- list(tx_chrom = chromosome_list)
genes.gr <- genes(mm10KG, filter = filter, columns=c("gene_id"))
# Droping the chromosomes that are not used. https://support.bioconductor.org/p/95879/
seqlevels(genes.gr) <- seqlevelsInUse(genes.gr)

# Let's try to create a different version of the gene list but with some base pair added
# at the beginning in the promoter region (between 100bp and 1000bp)
genes.gr.df <- data.frame(genes.gr)
bp.to.add <- 2000
genes.extended.gr <- GRanges(genes.gr.df$seqnames, 
                              IRanges(start = genes.gr.df$start-bp.to.add, 
                                      end = genes.gr.df$end),
                              strand = genes.gr.df$strand, 
                              gene_id = genes.gr.df$gene_id)

analysis_type <- 'only_gene'
analysis_type <- 'gene_plus_promotor_region'
if(analysis_type !='only_gene'){
  print(paste0('Extension of gene + promotor region of ', bp.to.add, ' bp.'))
  genes.gr <- genes.extended.gr
}

# I need the gene names
feature.maping.symbol <- mapIds(org.Mm.eg.db, unique(genes.gr$gene_id), 'SYMBOL', 'ENTREZID')
feature.maping.symbol.df <- data.frame(ID_REF = unique(genes.gr$gene_id), gene_name=feature.maping.symbol)



#2. Importing promoters and reducing the segments that can be joined.
promoters <- promoters(mm10KG,upstream = 2000, downstream = 100)
promoters <- GenomicRanges::reduce(promoters)

#3. Importing different parts 
FiveUTR <- GenomicRanges::reduce(flatGrl(fiveUTRsByTranscript(mm10KG)))
ThreeUTR <- GenomicRanges::reduce(flatGrl(threeUTRsByTranscript(mm10KG)))
CDS <- GenomicRanges::reduce(cds(mm10KG))
Introns <- GenomicRanges::reduce(flatGrl(intronsByTranscript(mm10KG)))



################
# now the methylation

# I create the GRanges object for the methylation, thinking about the contend.
perc.meth.thymus.gr <- makeGRangesFromDataFrame(perc.meth.thymus.df)
# Another method
perc.meth.thymus.gr <- GRanges(perc.meth.thymus.df$chr, 
                              IRanges(start = perc.meth.thymus.df$start, 
                                      end = perc.meth.thymus.df$end),
                              strand = perc.meth.thymus.df$strand, 
                              ID_METH = rownames(perc.meth.thymus.df))


perc.meth.thymus.gr <- perc.meth.thymus.gr[perc.meth.thymus.gr@seqnames %in% chromosome_list]
# Droping the chromosomes that are not used. https://support.bioconductor.org/p/95879/
seqlevels(perc.meth.thymus.gr) <- seqlevelsInUse(perc.meth.thymus.gr)


# Now I will see the overlapping with genes
overlaps.genes.cpgs <- findOverlaps(genes.gr, perc.meth.thymus.gr)

# Now I will create a dataset with the summary
overlaps.genes.cpgs.df <- data.frame(overlaps.genes.cpgs)
# Assign the actual values
overlaps.genes.cpgs.df$ID_REF <- genes.gr[overlaps.genes.cpgs.df$queryHits]$gene_id
overlaps.genes.cpgs.df$ID_METH <- perc.meth.thymus.gr[overlaps.genes.cpgs.df$subjectHits]$ID_METH


# Add cpg names
perc.meth.thymus$ID_METH <- rownames(perc.meth.thymus)

# 4. join the data with gene names
expression.CpGs.hits <- overlaps.genes.cpgs.df %>% left_join(feature.maping.symbol.df, by="ID_REF")
#with methylation data
expression.CpGs.hits.meth <- expression.CpGs.hits %>% left_join(perc.meth.thymus, by="ID_METH")

```

Let's take the marker genes for all the hierarchy.
```{r filtering.marker.genes}

#Adding top groups
all_markers.thymus <- c(
  #First the main leaf and the next level
  rownames(deco.actual.data.thymus.reduced.results.complete$result_deco_top_cluster$w), #top level
  rownames(deco.actual.data.thymus.reduced.results.complete$deco_results_list$subcluster_level_1_leaf_2$result_deco_top_cluster$w),
  rownames(deco.actual.data.thymus.reduced.results.complete$deco_results_list$subcluster_level_1_leaf_3$result_deco_top_cluster$w)
)

#150
length(all_markers.thymus)
#Unique markers: 150
all_markers.thymus <- unique(all_markers.thymus)
length(all_markers.thymus)

#For each part of the model I have to choose different parts of the CpGs

#TOP MODEL: 14
all_markers.thymus.top <- c(
  #First the main leaf and the next level
  rownames(deco.actual.data.thymus.reduced.results.complete$result_deco_top_cluster$w)
)

#DP 132
all_markers.thymus.dp <- c(
  rownames(deco.actual.data.thymus.reduced.results.complete$deco_results_list$subcluster_level_1_leaf_2$result_deco_top_cluster$w)
)
all_markers.thymus.dp <- unique(all_markers.thymus.dp)

#DN: 8
all_markers.thymus.cds <- c(
  rownames(deco.actual.data.thymus.reduced.results.complete$deco_results_list$subcluster_level_1_leaf_3$result_deco_top_cluster$w)
)
all_markers.thymus.cds <- unique(all_markers.thymus.cds)

```

After that I can filter the CpGs based on the markers
```{r filter.methylation.just.markers.genes}

# ALL MARKERS
# First filter cpgs associated with marker genes.
expression.CpGs.hits.meth.filtered.marker.genes.all <- expression.CpGs.hits.meth[expression.CpGs.hits.meth$gene_name %in% all_markers.thymus,]
#I filtered the CpGs that are associated with the marker genes.
perc.meth.thymus.filtered.marker.genes.all <- perc.meth.thymus[unique(expression.CpGs.hits.meth.filtered.marker.genes.all$ID_METH),]

#TOP
# First filter cpgs associated with marker genes.
expression.CpGs.hits.meth.filtered.marker.genes.top <- expression.CpGs.hits.meth[expression.CpGs.hits.meth$gene_name %in% all_markers.thymus.top,]
#I filtered the CpGs that are associated with the marker genes.
perc.meth.thymus.filtered.marker.genes.top <- perc.meth.thymus[unique(expression.CpGs.hits.meth.filtered.marker.genes.top$ID_METH),]

#DP
# First filter cpgs associated with marker genes.
expression.CpGs.hits.meth.filtered.marker.genes.dp <- expression.CpGs.hits.meth[expression.CpGs.hits.meth$gene_name %in% all_markers.thymus.dp,]
#I filtered the CpGs that are associated with the marker genes.
perc.meth.thymus.filtered.marker.genes.dp <- perc.meth.thymus[unique(expression.CpGs.hits.meth.filtered.marker.genes.dp$ID_METH),]

#CDs
# First filter cpgs associated with marker genes.
expression.CpGs.hits.meth.filtered.marker.genes.cds <- expression.CpGs.hits.meth[expression.CpGs.hits.meth$gene_name %in% all_markers.thymus.cds,]
#I filtered the CpGs that are associated with the marker genes.
perc.meth.thymus.filtered.marker.genes.cds <- perc.meth.thymus[unique(expression.CpGs.hits.meth.filtered.marker.genes.cds$ID_METH),]

```


## 3.2. Deconvolution with methylation.
Now I will run the deconvolution with both: expression and methylation data
One of the options it to fix the H proportion matrix.
```{r oligo.decoflex.deconvolution.expression.methylation.reference.actual.data}

order_normalized <- paste0('cluster_', c(1:3))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")


#standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3")
#standard_name_thymus <- c("Thy_KO_1", "Thy_KO_2", "Thy_KO_3")
#standard_name_thymus <- c("Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3") 
standard_name_thymus <- c("Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3") 


#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.00000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.00000001

#lets find the genes shared between single cell reference and bulk data
inter.bulk.sc.thymus <- intersect(rownames(eset.thymus.bulk.sparse.df.filtered), 
                                  rownames(deco.actual.data.thymus.reduced.results.top$result_deco_top_cluster$w)) 

#8
inter.bulk.sc.thymus.vs.markers <- intersect(inter.bulk.sc.thymus, all_markers.thymus.top)
length(inter.bulk.sc.thymus.vs.markers)

filter_cpgs_with_genes <- 'filter_group'
if(filter_cpgs_with_genes=='filter_group'){
  #Replacing zeros and nulls with a small value.
  perc.meth.thymus <- data.frame(perc.meth.thymus.filtered.marker.genes.top) # 2,290
  perc.meth.thymus[is.na(perc.meth.thymus)] <- 0
}else if(filter_cpgs_with_genes=='all_grous'){
perc.meth.thymus <- data.frame(perc.meth.thymus.filtered.marker.genes.all) # 2,290
perc.meth.thymus[is.na(perc.meth.thymus)] <- 0
}else{
  perc.meth.thymus <- data.frame(expression.CpGs.hits.meth) # 2,290
  perc.meth.thymus[is.na(perc.meth.thymus)] <- 0
}


alpha_values <- c(0.001, 0.01, 0.1, 0.3, 0.5, 0.8)

start_time <- Sys.time()

bulk_data_expr <- eset.thymus.bulk.sparse.df.filtered[inter.bulk.sc.thymus.vs.markers, standard_name_thymus]
bulk_data_meth <- perc.meth.thymus[, standard_name_thymus]
fixed_w <- data.frame(deco.actual.data.thymus.reduced.results.top$result_deco_top_cluster$w[inter.bulk.sc.thymus.vs.markers, order_normalized])

grid_search_deco.dnmt1.ko.expr.meth.thymus <- run_grid_search(
  bulk_data_methylation = data.frame(bulk_data_meth),
  bulk_data_expression = data.frame(bulk_data_expr),
  data_expression_auxiliary = NULL,
  k = as.integer(3),
  alpha_list = alpha_values, beta_list = NULL,
  delta_threshold = 1e-10,
  max_iterations = as.integer(1000),
  threads = as.integer(0),
  fixed_h = data.frame(deco.actual.data.thymus.reduced.results.top$back_propagation_proportions_top_detailed[order_normalized, standard_name_thymus]),
  fixed_w = fixed_w,
  proportion_constraint_h = as.logical(TRUE),
  #constraint_type_a = 'sigmoid',
  #constraint_value_a = as.double('0.50'),
  model_type = 'core_expression'
  )

#10 iterations: Time difference of 18.698 mins -> all genes
end_time <- Sys.time()
end_time - start_time
```

## 3.2.1 Performance of the deconvolution

Let's analyze the behavior and performance of the grid search algorithm to gain insights into its effectiveness.
```{r decoflex.gridsearch.thymus.plots.performance, fig.width=5, fig.height=3}

grid_search_deco.dnmt1.ko.expr.meth.thymus.df <- create_dataframe_results_multiple_deconvolutions(grid_search_deco.dnmt1.ko.expr.meth.thymus)

#Performance plots
performance_plot_multiple_deconvolutions(grid_search_deco.dnmt1.ko.expr.meth.thymus.df)
performance_plot_multiple_deconvolutions(grid_search_deco.dnmt1.ko.expr.meth.thymus.df, main_parameter = 'beta')
performance_plot_multiple_deconvolutions(grid_search_deco.dnmt1.ko.expr.meth.thymus.df, main_parameter = 'alpha')
```

```{r decoflex.gridsearch.thymus.plots, fig.width=7, fig.height=4}

plot_heatmap_alpha_beta(grid_search_deco.dnmt1.ko.expr.meth.thymus.df, fill_value = 'log_divergence_value')
plot_heatmap_alpha_beta(grid_search_deco.dnmt1.ko.expr.meth.thymus.df, fill_value = 'log_delta_divergence_value')
```

```{r histogram.methylation}

better_model.thymus <- choose_model_from_grid_search_object(grid_search_deco.dnmt1.ko.expr.meth.thymus, alpha = 0.001, beta=0)

hist(as.matrix(better_model.thymus$a), main = 'Histogram Thymus DecoFlex W - Meth profile')
heatmap(as.matrix(better_model.thymus$a))
heatmap(as.matrix(better_model.thymus$y))
```

```{r}
better_model.thymus.wt <- better_model.thymus
better_model.thymus.dnmt1.ko <- better_model.thymus
better_model.thymus.tumor <- better_model.thymus
better_model.thymus.doubleko <- better_model.thymus
```

```{r}
library("scales")
################# TOP


#Scale the deconvolution result to be comparable with the actual methylation bulk data
data.a <- cbind(rescale(as.matrix(better_model.thymus.wt$a)),
                rescale(as.matrix(better_model.thymus.dnmt1.ko$a[rownames(better_model.thymus.wt$a),])),
                rescale(as.matrix(better_model.thymus.tumor$a[rownames(better_model.thymus.wt$a),])),
                rescale(as.matrix(better_model.thymus.doubleko$a[rownames(better_model.thymus.wt$a),])),
                
                (better_model.thymus.wt$y[rownames(better_model.thymus.wt$a),]), 
                (better_model.thymus.dnmt1.ko$y[rownames(better_model.thymus.wt$a),]), 
                (better_model.thymus.tumor$y[rownames(better_model.thymus.wt$a),]),
                (better_model.thymus.doubleko$y[rownames(better_model.thymus.wt$a),]))
colnames(data.a) <- c('DN_WT','DP_WT','CDs_WT', 
                      'DN_KO','DP_KO','CDs_KO',
                      'DN_tumor','DP_tumor', 'CDs_tumor',
                      'DN_double_ko','DP_double_ko','CDs_double_ko',
                      'Bulk_Thy_WT_1', 'Bulk_Thy_WT_2', 'Bulk_Thy_WT_3',
                      'Bulk_Thy_KO_1', 'Bulk_Thy_KO_2', 'Bulk_Thy_KO_3', 
                      'Bulk_Thy_tumor_1', 'Bulk_Thy_tumor_2', 'Bulk_Thy_tumor_3',
                      "Bulk_ALKpos_KO_1", "Bulk_ALKpos_KO_2", "Bulk_ALKpos_KO_3")




################# CDs

#Scale the deconvolution result to be comparable with the actual methylation bulk data
data.a <- cbind(rescale(as.matrix(better_model.thymus.wt$a)),
                rescale(as.matrix(better_model.thymus.dnmt1.ko$a[rownames(better_model.thymus.wt$a),])),
                rescale(as.matrix(better_model.thymus.tumor$a[rownames(better_model.thymus.wt$a),])),
                rescale(as.matrix(better_model.thymus.doubleko$a[rownames(better_model.thymus.wt$a),])),
                
                (better_model.thymus.wt$y[rownames(better_model.thymus.wt$a),]), 
                (better_model.thymus.dnmt1.ko$y[rownames(better_model.thymus.wt$a),]), 
                (better_model.thymus.tumor$y[rownames(better_model.thymus.wt$a),]),
                (better_model.thymus.doubleko$y[rownames(better_model.thymus.wt$a),]))
colnames(data.a) <- c('CD4_WT','CD8_WT','CD4_KO','CD8_KO','CD4_tumor','CD8_tumor','CD4_double_ko','CD8_double_ko',
                      'Bulk_Thy_WT_1', 'Bulk_Thy_WT_2', 'Bulk_Thy_WT_3',
                      'Bulk_Thy_KO_1', 'Bulk_Thy_KO_2', 'Bulk_Thy_KO_3', 
                      'Bulk_Thy_tumor_1', 'Bulk_Thy_tumor_2', 'Bulk_Thy_tumor_3')

#reordering
reorder.list.all <- c('CD4_WT', 'CD4_KO', 'CD4_tumor', 
                      'CD8_tumor', 'CD8_WT', 'CD8_KO',
                      'Bulk_Thy_WT_1', 'Bulk_Thy_WT_2', 'Bulk_Thy_WT_3',
                      'Bulk_Thy_KO_1', 'Bulk_Thy_KO_2', 'Bulk_Thy_KO_3', 
                      'Bulk_Thy_tumor_1', 'Bulk_Thy_tumor_2', 'Bulk_Thy_tumor_3')

reorder.list.CD4 <- c('CD4_WT', 'CD4_KO', 'CD4_tumor', 
                  'Bulk_Thy_tumor_1', 'Bulk_Thy_tumor_2', 'Bulk_Thy_tumor_3',
                  'Bulk_Thy_WT_1', 'Bulk_Thy_WT_2', 'Bulk_Thy_WT_3',
                  'Bulk_Thy_KO_1', 'Bulk_Thy_KO_2', 'Bulk_Thy_KO_3')

reorder.list.CD8 <- c('CD8_tumor', 'CD8_WT', 'CD8_KO',
                  'Bulk_Thy_tumor_1', 'Bulk_Thy_tumor_2', 'Bulk_Thy_tumor_3',
                  'Bulk_Thy_WT_1', 'Bulk_Thy_WT_2', 'Bulk_Thy_WT_3',
                  'Bulk_Thy_KO_1', 'Bulk_Thy_KO_2', 'Bulk_Thy_KO_3')

#Plots 
heatmap(as.matrix(data.a[, reorder.list.all]), 
        main = 'CD4 and CD8 - CpGs',
        Colv = NA, 
        margins = c(8, 8))

heatmap(as.matrix(data.a[, reorder.list.CD4]), 
        main = 'CD4 - CpGs',
        Colv = NA, 
        margins = c(8, 8))

heatmap(as.matrix(data.a[, reorder.list.CD8]), 
        main = 'CD8 - CpGs',
        Colv = NA, 
        margins = c(8, 8))




heatmap.2(as.matrix(data.a[, reorder.list.all]), 
          main = 'CD4 and CD8 - CpGs',
          Colv = FALSE)

```

Page to solve the problem of sorting and names of genes with the latest version of complexHeatmap: https://jokergoo.github.io/2021/03/11/control-labels-in-anno_block/
```{r improve.plot.a.methylation.pattern, fig.width=10, fig.height=8}
#join with the cpg/gene information
data.a$ID_METH <- rownames(data.a)
data.a.extended <- data.a %>% left_join(expression.CpGs.hits.meth, by = "ID_METH")
rownames(data.a.extended) <- paste0(data.a.extended$ID_METH, '_', data.a.extended$gene_name)
#marker_genes_list.cds <- c('CpR162', 'Cd4', 'Cd8b1', 'Runx3')
marker_genes_list.top <- c("Cd8b1", "Shisa5", "Il2ra", "Ms4a4b",  "Cd52", "Crybg2", "Endou", "Ap3s1","Atg12", "9330179D12Rik", "Ccnd2","Hes1")
marker_genes_list <- marker_genes_list.top

#Generating the colors for genes.
library(RColorBrewer)
n <- length(marker_genes_list)
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

colors_list_parametric <- sample(col_vector, n)
colors_list_parametric <- rep('white', n)
colour.columns.list <- c(colors_list_parametric)
names(colour.columns.list) <- marker_genes_list

# Define color for the cell type variable
colour.rows.left_list <- list(colour = colour.columns.list)


colour.columns.list.v2 <- rep('white', length(colour.columns.list))
colour.rows.left_list.v2 <- list(colour = colour.columns.list.v2)

# Create the heatmap annotation rows
ha.rows.left <- rowAnnotation(
  marker_gene_code = anno_mark(at = c(1:length(data.a.extended$ID_METH)),
                               labels = data.a.extended$gene_name,
                               labels_gp = gpar(col = "black", fontsize = 8)
                               ),
  marker_gene = data.a.extended$gene_name,
  col = colour.rows.left_list
)

# Create the heatmap annotation rows
ha.rows.left.v2 <- rowAnnotation(
  'marker gene' = anno_block(gp = gpar(fill = 'white'),
                               labels = marker_genes_list,
                               labels_gp = gpar(col = "black", fontsize = 8),
                               labels_rot = 0, show_name=TRUE
                               )
)


list_columns_plot.cds <- c('CD4_WT','CD8_WT','CD4_KO','CD8_KO','CD4_tumor','CD8_tumor', 
                    'Bulk_Thy_WT_1', 'Bulk_Thy_WT_2', 'Bulk_Thy_WT_3',
                    'Bulk_Thy_KO_1', 'Bulk_Thy_KO_2', 'Bulk_Thy_KO_3', 
                    'Bulk_Thy_tumor_1', 'Bulk_Thy_tumor_2', 'Bulk_Thy_tumor_3', 
                    "Bulk_ALKpos_KO_1", "Bulk_ALKpos_KO_2", "Bulk_ALKpos_KO_3")

list_columns_plot.top <- c('DN_WT','DP_WT','CDs_WT', 
                      'DN_KO','DP_KO','CDs_KO',
                      'DN_tumor','DP_tumor', 'CDs_tumor',
                      'DN_double_ko','DP_double_ko','CDs_double_ko',
                      'Bulk_Thy_WT_1', 'Bulk_Thy_WT_2', 'Bulk_Thy_WT_3',
                      'Bulk_Thy_KO_1', 'Bulk_Thy_KO_2', 'Bulk_Thy_KO_3', 
                      'Bulk_Thy_tumor_1', 'Bulk_Thy_tumor_2', 'Bulk_Thy_tumor_3',
                      "Bulk_ALKpos_KO_1", "Bulk_ALKpos_KO_2", "Bulk_ALKpos_KO_3")

list_columns_plot <- list_columns_plot.top


# Combine the heatmap and the annotation
heatmap.celltypes.methylation  <- Heatmap(as.matrix(data.a.extended[, list_columns_plot]), name = "Markers",
                                          cluster_columns = FALSE,
                                          column_dend_reorder = FALSE,
                                          cluster_rows = TRUE,#
                                          row_dend_reorder = FALSE,#
                                          #row_km = 2,
                                          #column_split = column.values$column.names,
                                          row_split = data.a.extended$gene_name,
                                          row_labels = rownames(data.a.extended),
                                          row_names_gp = gpar(fontsize = 9),
                                          show_column_names = TRUE,
                                          column_names_gp = gpar(fontsize = 9),
                                          #right_annotation = ha.rows.right.v2,
                                          #top_annotation = ha.columns,
                                          #column_dend_height = unit(90, "mm"), 
                                          left_annotation = ha.rows.left.v2,
                                          row_dend_width =  unit(40, "mm"), 
                                          row_names_side ="right",
                                          show_row_names = TRUE,
                                          column_title_rot = 90,
                                          row_title = 'Marker CpGs'
)

print(heatmap.celltypes.methylation)



#Summarize condition
```


Convert from BAM to wg
```{bash convert.bam.wg}

#Create the bw files base on the bam files (-p = --numberOfProcessors)
#https://deeptools.readthedocs.io/en/develop/content/tools/bamCoverage.html
#conda install -c bioconda deeptools
mkdir bw_files
bamCoverage -b Thy_WT_1.bam -o bw_files/Thy_WT_1.bw --numberOfProcessors 20
bamCoverage -b Thy_WT_2.bam -o bw_files/Thy_WT_2.bw --numberOfProcessors 20
bamCoverage -b Thy_WT_3.bam -o bw_files/Thy_WT_3.bw --numberOfProcessors 20

bamCoverage -b Thy_KO_1.bam -o bw_files/Thy_KO_1.bw --numberOfProcessors 20
bamCoverage -b Thy_KO_2.bam -o bw_files/Thy_KO_2.bw --numberOfProcessors 20
bamCoverage -b Thy_KO_3.bam -o bw_files/Thy_KO_3.bw --numberOfProcessors 20

bamCoverage -b Tumor_ALKpos_WT_1.bam -o bw_files/Tumor_ALKpos_WT_1.bw --numberOfProcessors 20
bamCoverage -b Tumor_ALKpos_WT_2.bam -o bw_files/Tumor_ALKpos_WT_2.bw --numberOfProcessors 20
bamCoverage -b Tumor_ALKpos_WT_3.bam -o bw_files/Tumor_ALKpos_WT_3.bw --numberOfProcessors 20

bamCoverage -b Thy_ALKpos_KO_1.bam -o bw_files/Thy_ALKpos_KO_1.bw --numberOfProcessors 20
bamCoverage -b Thy_ALKpos_KO_2.bam -o bw_files/Thy_ALKpos_KO_2.bw --numberOfProcessors 20
bamCoverage -b Thy_ALKpos_KO_3.bam -o bw_files/Thy_ALKpos_KO_3.bw --numberOfProcessors 20

```

```{bash methylation.bw}

mv GSM4947044_RRBS_B372.bw Thy_WT_1_RRBS.bw
mv GSM4947045_RRBS_B387.bw Thy_WT_2_RRBS.bw
mv GSM4947046_RRBS_B436.bw Thy_WT_3_RRBS.bw

mv GSM4947047_RRBS_B312.bw Thy_KO_1_RRBS.bw
mv GSM4947048_RRBS_B344.bw Thy_KO_2_RRBS.bw
mv GSM4947049_RRBS_B390.bw Thy_KO_3_RRBS.bw

mv GSM4947050_RRBS_B057.bw Tumor_ALKpos_WT_1_RRBS.bw
mv GSM4947051_RRBS_B098.bw Tumor_ALKpos_WT_2_RRBS.bw	
mv GSM4947052_RRBS_B371.bw Tumor_ALKpos_WT_3_RRBS.bw	

mv GSM4947053_RRBS_B370.bw Thy_ALKpos_KO_1_RRBS.bw
mv GSM4947054_RRBS_B389.bw Thy_ALKpos_KO_2_RRBS.bw 
mv GSM4947055_RRBS_B474.bw Thy_ALKpos_KO_3_RRBS.bw 	
```


Tracks in genome browser
```{bash tracks.genome.browser}

#structure of the line
name=wt_1.bw bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Thy_WT_1.bw type=bigWig

#Expression data as bw files
http://129.70.51.139:8080/thymus_tracks/expression/Thy_WT_1.bw
http://129.70.51.139:8080/thymus_tracks/expression/Thy_WT_2.bw
http://129.70.51.139:8080/thymus_tracks/expression/Thy_WT_3.bw

http://129.70.51.139:8080/thymus_tracks/expression/Thy_KO_1.bw
http://129.70.51.139:8080/thymus_tracks/expression/Thy_KO_2.bw
http://129.70.51.139:8080/thymus_tracks/expression/Thy_KO_3.bw

http://129.70.51.139:8080/thymus_tracks/expression/Tumor_ALKpos_WT_1.bw
http://129.70.51.139:8080/thymus_tracks/expression/Tumor_ALKpos_WT_2.bw
http://129.70.51.139:8080/thymus_tracks/expression/Tumor_ALKpos_WT_3.bw

http://129.70.51.139:8080/thymus_tracks/expression/Thy_ALKpos_KO_1.bw
http://129.70.51.139:8080/thymus_tracks/expression/Thy_ALKpos_KO_2.bw
http://129.70.51.139:8080/thymus_tracks/expression/Thy_ALKpos_KO_3.bw

#soft link for folder and file for sharing the directory with all files in the apache server.
ln -s /mnt_volumen/www_apache/html/thymus_tracks /var/www/html/thymus_tracks

#tracks for expression data Bulk RNA-SEQ
track type=bigWig name="Thymus WT 1" description="Thymus WT 1" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Thy_WT_1.bw
track type=bigWig name="Thymus WT 2" description="Thymus WT 2" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Thy_WT_2.bw
track type=bigWig name="Thymus WT 3" description="Thymus WT 3" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Thy_WT_3.bw

track type=bigWig name="Thymus KO 1" description="Thymus KO 1" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Thy_KO_1.bw
track type=bigWig name="Thymus KO 2" description="Thymus KO 2" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Thy_KO_2.bw
track type=bigWig name="Thymus KO 3" description="Thymus KO 3" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Thy_KO_3.bw

track type=bigWig name="Thymus ALKpos WT 1" description="Thymus ALKpos WT 1" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Tumor_ALKpos_WT_1.bw
track type=bigWig name="Thymus ALKpos WT 2" description="Thymus ALKpos WT 2" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Tumor_ALKpos_WT_2.bw
track type=bigWig name="Thymus ALKpos WT 3" description="Thymus ALKpos WT 3" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Tumor_ALKpos_WT_3.bw

track type=bigWig name="Thymus ALKpos KO 1" description="Thymus ALKpos KO 1" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Thy_ALKpos_KO_1.bw
track type=bigWig name="Thymus ALKpos KO 2" description="Thymus ALKpos KO 2" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Thy_ALKpos_KO_2.bw
track type=bigWig name="Thymus ALKpos KO 3" description="Thymus ALKpos KO 3" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/expression/Thy_ALKpos_KO_3.bw

#Tracks for Methylation data
track type=bigWig name="Thymus WT 1 RRBS" description="Thymus WT 1 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Thy_WT_1_RRBS.bw
track type=bigWig name="Thymus WT 2 RRBS" description="Thymus WT 2 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Thy_WT_2_RRBS.bw
track type=bigWig name="Thymus WT 3 RRBS" description="Thymus WT 3 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Thy_WT_3_RRBS.bw

track type=bigWig name="Thymus KO 1 RRBS" description="Thymus KO 1 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Thy_KO_1_RRBS.bw
track type=bigWig name="Thymus KO 2 RRBS" description="Thymus KO 2 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Thy_KO_2_RRBS.bw
track type=bigWig name="Thymus KO 3 RRBS" description="Thymus KO 3 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Thy_KO_3_RRBS.bw

track type=bigWig name="Thymus ALKpos WT 1 RRBS" description="Thymus ALKpos WT 1 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Tumor_ALKpos_WT_1_RRBS.bw
track type=bigWig name="Thymus ALKpos WT 2 RRBS" description="Thymus ALKpos WT 2 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Tumor_ALKpos_WT_2_RRBS.bw
track type=bigWig name="Thymus ALKpos WT 3 RRBS" description="Thymus ALKpos WT 3 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Tumor_ALKpos_WT_3_RRBS.bw

track type=bigWig name="Thymus ALKpos KO 1 RRBS" description="Thymus ALKpos KO 1 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Thy_ALKpos_KO_1_RRBS.bw
track type=bigWig name="Thymus ALKpos KO 2 RRBS" description="Thymus ALKpos KO 2 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Thy_ALKpos_KO_2_RRBS.bw
track type=bigWig name="Thymus ALKpos KO 3 RRBS" description="Thymus ALKpos KO 3 RRBS" bigDataUrl=http://129.70.51.139:8080/thymus_tracks/RRBS/Thy_ALKpos_KO_3_RRBS.bw

```

# 4. Complete deconvolution: expr, meth and Z matrix

## 4.1. Creation of Z matrix

Let's construct the auxiliary matrix corresponding to the Z matrix. During this research phase, we need to develop the following strategies:

1. In this dataset, each row corresponds to a gene, and each column represents a sample. It's essential to aggregate the methylation values for each gene-sample pair. The objective here is to assess the methylation value within each gene, along with an adjacent 1000 base pairs (bp) region preceding the CpG site. This preceding region, known as the promoter region, typically consists of a high concentration of CpG sites (forming CpG islands) and is the primary target for methylation.


Now I will create the first Z matrix without scaling
```{r creation.auxiliary.matrix.expression.methylation.z.data}
# After the steps 1,2,3,4 from the chunck named: "methylation.join.genes" I will complete the Z matrix
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

# 5. I have the matrix that I will use in the deconvolution with Generalized Kullback Leibler convergence based on mutual information
expression.CpGs.hits.meth.by.gene <- expression.CpGs.hits.meth %>% group_by(gene_name) %>% 
  dplyr::summarise(Thy_WT_1= sum(Thy_WT_1),
            Thy_WT_2= sum(Thy_WT_2),
            Thy_WT_3= sum(Thy_WT_3),
            
            Thy_KO_1= sum(Thy_KO_1),
            Thy_KO_2= sum(Thy_KO_2),
            Thy_KO_3= sum(Thy_KO_3),
            
            Tumor_ALKpos_WT_1= sum(Tumor_ALKpos_WT_1),
            Tumor_ALKpos_WT_2= sum(Tumor_ALKpos_WT_2),
            Tumor_ALKpos_WT_3= sum(Tumor_ALKpos_WT_3),
            
            Thy_ALKpos_KO_1= sum(Thy_ALKpos_KO_1),
            Thy_ALKpos_KO_2= sum(Thy_ALKpos_KO_2),
            Thy_ALKpos_KO_3= sum(Thy_ALKpos_KO_3),
            .groups = 'drop') %>% 
  as.data.frame()

#6. Finally I have to scale from 0 to 1
scale_matrix_z <- function(matrix){
  library("scales")
  print('Original: ')
  print(colMeans(matrix, na.rm = TRUE))
  matrix.scaled <- apply(matrix, 2, rescale)
  print('Scaled: ')
  print(colMeans(matrix.scaled, na.rm = TRUE))
  message(paste0('Rows: ', nrow(matrix.scaled),
               ', Columns:', ncol(matrix.scaled)))
  return(matrix.scaled)
}

#Finally I get the matrix scaled
expression.CpGs.hits.meth.by.gene.scaled <- scale_matrix_z(expression.CpGs.hits.meth.by.gene[standard_name_thymus])
rownames(expression.CpGs.hits.meth.by.gene.scaled) <- expression.CpGs.hits.meth.by.gene$gene_name

#non scaled version
expression.CpGs.hits.meth.by.gene.final <- as.matrix(expression.CpGs.hits.meth.by.gene)
rownames(expression.CpGs.hits.meth.by.gene.final) <- expression.CpGs.hits.meth.by.gene.final[, c('gene_name')]
expression.CpGs.hits.meth.by.gene.final <- expression.CpGs.hits.meth.by.gene.final[,standard_name_thymus]

```

Additionally, we can create an auxiliary matrix, Z, that summarizes the information by calculating the expression divided by methylation as a factor or score.
```{r creation.auxiliary.matrix.expression.methylation.z.data.summarizing}

# I also can create an score expresion/methylation or the other way around.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
#11599
shared_genes <- intersect(rownames(eset.thymus.bulk.sparse.df.filtered), expression.CpGs.hits.meth.by.gene$gene_name) 


##### SCORES

#lets order the datasets 
expression.CpGs.hits.meth.by.gene.ordered <- expression.CpGs.hits.meth.by.gene[match(shared_genes, expression.CpGs.hits.meth.by.gene$gene_name),standard_name_thymus]
eset.thymus.bulk.sparse.df.filtered.ordered <- eset.thymus.bulk.sparse.df.filtered[match(shared_genes, rownames(eset.thymus.bulk.sparse.df.filtered)),standard_name_thymus]


###### Score A: gene_expression / sum(neighboring CpGs methylation)

# Calculation of the score A
expression.CpGs.hits.meth.by.gene.score.a <- expression.CpGs.hits.meth.by.gene.ordered / eset.thymus.bulk.sparse.df.filtered.ordered
#7.1 Let's replace the NAs values with a value almost 0 (1e20), however in the future the library has to be able to use the NA as advantage.
expression.CpGs.hits.meth.by.gene.score.a[is.na(expression.CpGs.hits.meth.by.gene.score.a)] <- 0.0000000001
expression.CpGs.hits.meth.by.gene.score.a[sapply(expression.CpGs.hits.meth.by.gene.score.a, is.infinite)] <- 0.0000000001



######### Score B: sum(neighboring CpGs methylation)/gene_expression 
expression.CpGs.hits.meth.by.gene.score.b <- eset.thymus.bulk.sparse.df.filtered.ordered / expression.CpGs.hits.meth.by.gene.ordered
#7.1 Let's replace the NAs values with a value almost 0 (1e20), however in the future the library has to be able to use the NA as advantage.
expression.CpGs.hits.meth.by.gene.score.b[is.na(expression.CpGs.hits.meth.by.gene.score.b)] <- 0.0000000001
expression.CpGs.hits.meth.by.gene.score.b[sapply(expression.CpGs.hits.meth.by.gene.score.b, is.infinite)] <- 0.0000000001


#6. Finally I have to scale from 0 to 1
expression.CpGs.hits.meth.by.gene.score.a.scaled <- scale_matrix_z(expression.CpGs.hits.meth.by.gene.score.a[standard_name_thymus])
expression.CpGs.hits.meth.by.gene.score.b.scaled <- scale_matrix_z(expression.CpGs.hits.meth.by.gene.score.b[standard_name_thymus])

```

We could add the missing marker genes in the Z matrix with zero or near to zero values.

```{r missing.markers.z.matrix}

# 1. 8 shared marker genes with the input
inter.bulk.sc.thymus.vs.markers <- intersect(inter.bulk.sc.thymus, all_markers.thymus)
length(inter.bulk.sc.thymus.vs.markers)

# 2. Also shared with the z matrix: 3
inter.bulk.sc.thymus.vs.markers.vs.z.matrix <- intersect(inter.bulk.sc.thymus.vs.markers, rownames(expression.CpGs.hits.meth.by.gene.final))
length(inter.bulk.sc.thymus.vs.markers.vs.z.matrix)

# 3. 5 Now I will calculate what is missing
diff_markers <- setdiff(inter.bulk.sc.thymus.vs.markers, rownames(expression.CpGs.hits.meth.by.gene.final))
length(diff_markers)

# 4. I create a matrix with the missing genes in order to add them to the Z matrix.
temp_matrix <- matrix(nrow = length(diff_markers), ncol = ncol(expression.CpGs.hits.meth.by.gene.final), 0.0000000001)
rownames(temp_matrix) <- diff_markers 
colnames(temp_matrix) <- colnames(expression.CpGs.hits.meth.by.gene.final)

# 5. Creation of the Z matrix with the genes with some methylated CpGs and the rest with zero values.
expression.CpGs.hits.meth.by.gene.final.complete <- rbind(expression.CpGs.hits.meth.by.gene.final[,], 
                                                          temp_matrix)

```


## 4.2. Deconvolution

We will calculate the B matrix using the Z matrix, incorporating the scores for all seven cell types. I need to fix a possible problem with marker genes, since it get reduced when I tried to recover information about methylation. Maybe I can add zeros to the genes that are not present.
```{r decoflex.gridsearch.thymus.plus.z}

order_normalized <- paste0('cluster_', c(1:3))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#let's choose the better model
better_model.thymus <- choose_model_from_grid_search_object(grid_search_deco.dnmt1.ko.expr.meth.thymus, alpha = 0.001, beta=0)

#8 shared marker genes with the input
inter.bulk.sc.thymus.vs.markers <- intersect(inter.bulk.sc.thymus, all_markers.thymus.top)
length(inter.bulk.sc.thymus.vs.markers)

#Also shared with the z matrix: 8 (With the missing fix)
inter.bulk.sc.thymus.vs.markers.vs.z.matrix <- intersect(inter.bulk.sc.thymus.vs.markers, rownames(expression.CpGs.hits.meth.by.gene.final.complete))
length(inter.bulk.sc.thymus.vs.markers.vs.z.matrix)

#I got the actual proportions fixed for the best
W_expression<- data.frame(better_model.thymus$w[inter.bulk.sc.thymus.vs.markers.vs.z.matrix, order_normalized])
A_methylation <- data.frame(better_model.thymus$a[, order_normalized])
H_proportions <- data.frame(deco.actual.data.thymus.results$back_propagation_proportions_top_detailed[order_normalized, standard_name_thymus])


bulk_data_expr <- eset.thymus.bulk.sparse.df.filtered[inter.bulk.sc.thymus.vs.markers.vs.z.matrix, standard_name_thymus]
bulk_data_meth <- perc.meth.thymus[, standard_name_thymus]

matrix_z_auxiliary_data <- data.frame(expression.CpGs.hits.meth.by.gene.final.complete[inter.bulk.sc.thymus.vs.markers.vs.z.matrix, standard_name_thymus])

alpha_values.list <- c(0.0, 0.00001, 0.0001, 0.001, 0.01, 0.1, 1)
beta_values.list <-  c(0.0, 0.00001, 0.0001, 0.001, 0.01, 0.1, 1)

start_time <- Sys.time()

grid_search_deco.fixed.w.a.h.alpha.list.thymus <- run_grid_search(
  bulk_data_expression = data.frame(bulk_data_expr[inter.bulk.sc.thymus.vs.markers.vs.z.matrix, standard_name_thymus]),
  bulk_data_methylation = data.frame(bulk_data_meth[,standard_name_thymus]),
  data_expression_auxiliary = matrix_z_auxiliary_data[inter.bulk.sc.thymus.vs.markers.vs.z.matrix, standard_name_thymus],
  k = 3,
  alpha_list = alpha_values.list, 
  beta_list = beta_values.list,
  max_iterations = as.integer(1000),
  threads = 0,
  delta_threshold=1e-10,
  proportion_constraint_h = as.logical(TRUE),  
  fixed_w = data.frame(W_expression),
  #fixed_a = data.frame(A_methylation), 
  #fixed_h = data.frame(H_proportions), 
  model_type = 'core_expression'
)

end_time <- Sys.time()
end_time - start_time
```

## 4.2.1. Performance of the deconvolution.

Let's analyze the behavior and performance of the grid search algorithm to gain insights into its effectiveness.
```{r decoflex.gridsearch.thymus.plus.z.plots.performance, fig.width=5, fig.height=3}

grid_search_deco.fixed.w.a.h.alpha.list.thymus.df <- create_dataframe_results_multiple_deconvolutions(grid_search_deco.fixed.w.a.h.alpha.list.thymus)

#Performance plots
performance_plot_multiple_deconvolutions(grid_search_deco.fixed.w.a.h.alpha.list.thymus.df)
performance_plot_multiple_deconvolutions(grid_search_deco.fixed.w.a.h.alpha.list.thymus.df, main_parameter = 'beta')
performance_plot_multiple_deconvolutions(grid_search_deco.fixed.w.a.h.alpha.list.thymus.df, main_parameter = 'alpha')
```

```{r decoflex.gridsearch.thymus.plus.z.plots, fig.width=7, fig.height=4}

plot_heatmap_alpha_beta(grid_search_deco.fixed.w.a.h.alpha.list.thymus.df, fill_value = 'log_divergence_value')
plot_heatmap_alpha_beta(grid_search_deco.fixed.w.a.h.alpha.list.thymus.df, fill_value = 'log_delta_divergence_value')
```

## 4.3 Plot of B matrix: relation expression. -> methylation

Now, we are prepared to visually examine both A matrices
```{r  decoflex.gridsearch.thymus.plus.z.b.matrix.analysis, fig.width=20, fig.height=7}

model.alpha.beta.op.thymus <- choose_model_from_grid_search_object(
  grid_search_deco.fixed.w.a.h.alpha.list.thymus,
  alpha = 1.0, beta = 0.1)

list_pseudotime.thymus <- c('DN', 'DP_1', 'DP_2', 'DP_3', 'DP_4', 'CD8+T', 'CD4+T')
list_pseudotime.thymus <- list_pseudotime.thymus[6:7]
list_pseudotime.thymus <- c('DN', 'DP', 'CDs')
model.alpha.beta.op.thymus.b <- model.alpha.beta.op.thymus$b
#To avoid the problem of using log(x)
model.alpha.beta.op.thymus.b <- model.alpha.beta.op.thymus.b+1
rownames(model.alpha.beta.op.thymus.b) <- list_pseudotime.thymus

palette.v1 <- colorRampPalette(c("red", "black", "green"))(n = 1000)
palette.v2 <- colorRampPalette(c("red", "green"))(n = 100)
color_scheme <- gplots::redgreen(75)

Colv  <- (as.matrix(model.alpha.beta.op.thymus.b)) %>% t %>% dist %>% hclust %>% as.dendrogram %>%
   set("branches_k_color", k = 2) %>% set("branches_lwd", 1) %>%
   rotate_DendSer(ser_weight = dist(t(x)))

par(cex.main=1)
gplots::heatmap.2((as.matrix(model.alpha.beta.op.thymus.b)),
                  trace="none",
                  margins=c(13,12), 
                  cexRow =2, cexCol = 2, 
                  dendrogram='column',     
                  Rowv=FALSE,
                  Colv=Colv,
                  col = palette.v1,
                  main = "Cell types vs samples: thymus")

Colv  <- log(as.matrix(model.alpha.beta.op.thymus.b)) %>% t %>% dist %>% hclust %>% as.dendrogram %>%
   set("branches_k_color", k = 2) %>% set("branches_lwd", 1) %>%
   rotate_DendSer(ser_weight = dist(t(x)))

par(cex.main=1)
plot.1 <- gplots::heatmap.2(log(as.matrix(model.alpha.beta.op.thymus.b)),
                  trace="none",
                  margins=c(13,12), 
                  cexRow = 2, cexCol = 2, 
                  dendrogram='column',     
                  Rowv=FALSE,
                  Colv=Colv,
                  col = palette.v2,
                  main = "Cell types vs samples in thymus")
print(plot.1$colDendrogram)

```


# 5 Partial referenced model: Semireference model with top 3 group

The idea is to see if we are missing some kind of unidentified celltype in the top group, using the differential expressed genes
With this setup we want to fix one proportion line: 
1. WT with the average values of single cell data.
2. The first 7 cell-types, leaving one cell-type uncover and therefore possible to be optimized.


## 5.0. Differential expression analysis

Now we need and differencial expression analysis over the bulk data to identify the up and down-regulated genes.
```{r differential.expression.analysis.thymus}

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

countdata <- as.matrix(eset.thymus.bulk.sparse@assayData$exprs)
countdata <- countdata[,standard_name_thymus]

#I put numbers on it because other wise I wouldn't get  ko vs wt.
type <- c("real_tumor","real_tumor","real_tumor",
          "real_tumor","real_tumor","real_tumor",
          "real_tumor","real_tumor","real_tumor",
          "real_tumor","real_tumor","real_tumor")

treatment <- c("Thy_WT","Thy_WT","Thy_WT",
                 "Thy_KO","Thy_KO","Thy_KO",
                 "Thy_ALKpos_WT","Thy_ALKpos_WT","Thy_ALKpos_WT",
                 "Thy_ALKpos_KO","Thy_ALKpos_KO","Thy_ALKpos_KO"
                 )

time <- c("18w","18w","18w",
          "18w","18w","18w",
          "18w","18w","18w",
          "18w","18w","18w")

replicates  <- c("1","2","3",
                 "1","2","3",
                 "1","2","3",
                 "1","2","3")

#secondary information
sample <- paste0("count_", 1:12)

coldata <- as.data.frame(cbind(replicates, treatment, time, sample, type))
rownames(coldata) <- NULL

#building the object DESeqDataSet
ddsFullCountTable <- DESeqDataSetFromMatrix(
  countData = countdata,
  colData = coldata,
  design = ~treatment)

#giving the order and setting the control sample for the analyisis, which is - in this case - the real Tumor_ALKpos_WT.
ddsFullCountTable$treatment <- factor(ddsFullCountTable$treatment, levels = c("Thy_WT", "Thy_ALKpos_WT", "Thy_KO", "Thy_ALKpos_KO"))

  
dds <- ddsFullCountTable

## Pre-filter
dds <- dds[ rowSums(counts(dds)) > 1, ]

## The rlog and variance stabilizing transformations => homoskedastic data
rld <- rlog(dds, blind = FALSE)
vsd <- vst(dds, blind = FALSE)
dds <- estimateSizeFactors(dds)
normalized.wt.bulk <- counts(dds, normalized=TRUE)

dds <- DESeq(dds)
resultsNames(dds)

  
RES.thymus.lfc <- list(Intercept = results(dds, name = "Intercept"),
                       treatment_Thy_ALKpos_WT_vs_Thy_WT = results(dds, name = "treatment_Thy_ALKpos_WT_vs_Thy_WT"), 
                       treatment_Thy_KO_vs_Thy_WT = results(dds, name = "treatment_Thy_KO_vs_Thy_WT"), 
                       treatment_Thy_ALKpos_KO_vs_Thy_WT = results(dds, name = "treatment_Thy_ALKpos_KO_vs_Thy_WT"))


RES.thymus.lfc


#now lets check the genes that I should include
select_markers_de <- function(de_object, log2FoldChange = 7.5){
  rownames(de_object[which(abs(de_object$log2FoldChange) >= log2FoldChange & de_object$padj <= 0.05),])
}

#61
de_genes.thymus <- c(select_markers_de(RES.thymus.lfc$treatment_Thy_KO_vs_Thy_WT, 5.1226535),
                     select_markers_de(RES.thymus.lfc$treatment_Thy_ALKpos_WT_vs_Thy_WT, 5.506788817),
                     select_markers_de(RES.thymus.lfc$treatment_Thy_ALKpos_KO_vs_Thy_WT, 4.5012223))
length(de_genes.thymus)

#All genes
de_genes.thymus.treatment_Thy_KO_vs_Thy_WT <- c(select_markers_de(RES.thymus.lfc$treatment_Thy_KO_vs_Thy_WT, 5.1226535)) #6
paste(shQuote(de_genes.thymus.treatment_Thy_KO_vs_Thy_WT, type="sh"), collapse=", ")


de_genes.thymus.treatment_Thy_ALKpos_WT_vs_Thy_WT <- c(select_markers_de(RES.thymus.lfc$treatment_Thy_ALKpos_WT_vs_Thy_WT, 8.016101030))#8
paste(shQuote(de_genes.thymus.treatment_Thy_ALKpos_WT_vs_Thy_WT, type="sh"), collapse=", ")
length(de_genes.thymus.treatment_Thy_ALKpos_WT_vs_Thy_WT)

de_genes.thymus.treatment_Thy_ALKpos_KO_vs_Thy_WT <- c(select_markers_de(RES.thymus.lfc$treatment_Thy_ALKpos_KO_vs_Thy_WT, 6.8832673))
paste(shQuote(de_genes.thymus.treatment_Thy_ALKpos_KO_vs_Thy_WT, type="sh"), collapse=", ")

#144. We hope that this will be enough to describe the missing celltype.
de_genes.thymus <- unique(de_genes.thymus)
length(de_genes.thymus)
paste(shQuote(de_genes.thymus, type="sh"), collapse=", ")

```

https://www.bioconductor.org/packages/release/bioc/vignettes/VennDetail/inst/doc/VennDetail.html
```{r shared_genes.de, fig.width=10, fig.height=10}

#BiocManager::install("VennDetail")
library(VennDetail)

ven.plot <- venndetail(list(Thy_KO_vs_Thy_WT = de_genes.thymus.treatment_Thy_KO_vs_Thy_WT,
                            Thy_ALKpos_WT_vs_Thy_WT = de_genes.thymus.treatment_Thy_ALKpos_WT_vs_Thy_WT,
                            Thy_ALKpos_KO_vs_Thy_WT = de_genes.thymus.treatment_Thy_ALKpos_KO_vs_Thy_WT))
plot(ven.plot)
plot(ven.plot, type = "vennpie")
plot_upset_shared_genes <- plot(ven.plot, type = "upset")
vennpie(ven.plot, any = 1, revcolor = "lightgrey")
vennpie(ven.plot, log = TRUE)
dplot(ven.plot, order = TRUE, textsize = 4)

save_plot_as_pdf(plot_upset_shared_genes, 'plot_upset_shared_genes.top.semireference_de_Thy_ALKpos_WT_vs_Thy_WT.pdf', 8, 4)

#See all shared genes
data.genes.shared <- result(ven.plot, wide = TRUE)
print(data.genes.shared)
#exporting to Latex
xtable::xtable(data.genes.shared)

```


Let's have the volcano plots for each pair of conditions with different cuts. I will use the percentile 99.9% of the log2FoldChange value
https://www.bioconductor.org/packages/devel/bioc/vignettes/EnhancedVolcano/inst/doc/EnhancedVolcano.html
```{r volcano_plot, fig.width=10, fig.height=9}
#BiocManager::install('EnhancedVolcano')
library(EnhancedVolcano)


treatment_Thy_KO_vs_Thy_WT_res <- results(dds, name = "treatment_Thy_KO_vs_Thy_WT")
quantile(abs(as.data.frame(treatment_Thy_KO_vs_Thy_WT_res)$log2FoldChange), c(.25, .50, .75, .90, .95, .995), na.rm = TRUE) 
volcano_plot_treatment_Thy_KO_vs_Thy_WT <- EnhancedVolcano(treatment_Thy_KO_vs_Thy_WT_res,
  lab = rownames(treatment_Thy_KO_vs_Thy_WT_res),
  #FCcutoff = c(-6.5093589, 6.5093589),
  FCcutoff = -6.5093589,
  title = 'treatment_Thy_KO_vs_Thy_WT',
  x = 'log2FoldChange',
  y = 'pvalue')
print(volcano_plot_treatment_Thy_KO_vs_Thy_WT)

save_plot_as_pdf(volcano_plot_treatment_Thy_KO_vs_Thy_WT, 'volcano_plot_treatment_Thy_KO_vs_Thy_WT.pdf', 8, 6)

res_treatment_Thy_ALKpos_WT_vs_Thy_WT <- results(dds, name = "treatment_Thy_ALKpos_WT_vs_Thy_WT")
quantile(as.data.frame(res_treatment_Thy_ALKpos_WT_vs_Thy_WT)$log2FoldChange, c(.25, .50, .75, .90, .95, .995), na.rm = TRUE) 
volcano_plot_treatment_Thy_ALKpos_WT_vs_Thy_WT <- EnhancedVolcano(res_treatment_Thy_ALKpos_WT_vs_Thy_WT,
  lab = rownames(res_treatment_Thy_ALKpos_WT_vs_Thy_WT),
  FCcutoff = 8.016101030,
  title = 'treatment_Thy_ALKpos_WT_vs_Thy_WT',
  x = 'log2FoldChange',
  y = 'pvalue')
print(volcano_plot_treatment_Thy_KO_vs_Thy_WT)

save_plot_as_pdf(volcano_plot_treatment_Thy_ALKpos_WT_vs_Thy_WT, 'volcano_plot_treatment_Thy_ALKpos_WT_vs_Thy_WT.pdf', 8, 6)

treatment_Thy_ALKpos_KO_vs_Thy_WT_res <- results(dds, name = "treatment_Thy_ALKpos_KO_vs_Thy_WT")
quantile(abs(as.data.frame(treatment_Thy_ALKpos_KO_vs_Thy_WT_res)$log2FoldChange), c(.25, .50, .75, .90, .95, .995), na.rm = TRUE) 
volcano_plot_treatment_Thy_ALKpos_KO_vs_Thy_WT <- EnhancedVolcano(treatment_Thy_ALKpos_KO_vs_Thy_WT_res,
  lab = rownames(treatment_Thy_ALKpos_KO_vs_Thy_WT_res),
  FCcutoff = 6.8832673,
  title = 'treatment_Thy_ALKpos_KO_vs_Thy_WT',
  x = 'log2FoldChange',
  y = 'pvalue')
print(volcano_plot_treatment_Thy_KO_vs_Thy_WT)

save_plot_as_pdf(volcano_plot_treatment_Thy_ALKpos_KO_vs_Thy_WT, 'volcano_plot_treatment_Thy_ALKpos_KO_vs_Thy_WT.pdf', 8, 6)

```

## 5.1. Partial deconvolution: TOP

Let's put together the marker genes from the flat deconvolution and the differential expressed genes.
```{r final.list.genes}
black_list_genes <- c() #Xist?
de_genes.thymus.total <- de_genes.thymus.treatment_Thy_ALKpos_WT_vs_Thy_WT
#de_genes.thymus <- de_genes.thymus.total[de_genes.thymus.total %in% black_list_genes == FALSE]

#Let's create the w reference with all the genes and then we could see which are shared with the final_markers_partial_model
# I don't use the one in the model becasue only has the marker genes in the reference and I need those  plus the Differential
# expressed ons
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
top_clusters_list = paste0('cluster_', c(1:3))
bulk_data = eset.thymus.bulk.sparse.df.filtered
sub_clusters_var <- 'metacluster'
sample <- 'age'

w_matrix_reference <- decoflex_build_cell_reference(
  x = single_cell_data_exp,
  ct.sub = top_clusters_list,
  ct.varname = sub_clusters_var,
  sample = sample,
  verbose = TRUE)

# sorting the results by columns
w_matrix_reference.basics <- w_matrix_reference$basis[, paste0('cluster_', c(1:3))]



#75
final_markers_partial_model <- c(de_genes.thymus, rownames(deco.actual.data.thymus.reduced.results.complete$result_deco_top_cluster$w))

#75
final_markers_partial_model <- unique(final_markers_partial_model)
length(final_markers_partial_model)

diff.1 <- setdiff(de_genes.thymus, final_markers_partial_model)

#46 (what???? why???)
shared.final.vs.w <- intersect(final_markers_partial_model, rownames(as.matrix(w_matrix_reference.basics)))
length(shared.final.vs.w)

#This are additional factors in the W matrix semireference
extra_marker_genes_semireference <- setdiff(de_genes.thymus, shared.final.vs.w)

final_markers_partial_model <- shared.final.vs.w


```

### 5.1.2. Creation of partial references: W and H

Now we can create the partial references with ONE fixed cell-type
```{r creation.mask.matrices.h.w.one.celltype}

# I have n genes as rows and m+1 columns, being the last one the unknown one. 
mask_h <- matrix(FALSE, nrow = (3+1), ncol = 12)
colnames(mask_h) <- standard_name_thymus
rownames(mask_h) <- paste0('cluster_', c(1:3, 'unknown_1'))

# In this case, I can do two things: 1. Fix just the celltypes that I have as reference and the unknown leave it as black. 2. Assign the unknown cell-type as zero, since it suppose to be a WT, and then in the other conditions it will appear a proportion. Also the Tumor DNMT1 KO, will be similar to WT.
version <- 'two'
if(version=='one'){
  #Version 1.
  mask_h[1:3,1:3] <- TRUE
}else if(version=='two'){
  #Version 1.
  mask_h[1:4,1:3] <- TRUE
}




#Now let's put the proportions that I needed, filling with zeros the rest
partial_h_fixed <- matrix(0, nrow = 4, ncol = 12)
colnames(partial_h_fixed) <- standard_name_thymus
rownames(partial_h_fixed) <- paste0('cluster_', c(1:3, 'unknown_1'))
#let's take the proportion
proportions_wt_single_cell <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.top$pseudo.bulk.data$truep) 
colnames(proportions_wt_single_cell) <- c('sample_6_8W')
proportions_wt_single_cell <- t(proportions_wt_single_cell)
proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ]

#Since I have three replicates I have to fix the proportions three times
partial_h_fixed[1:3,1] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ])
partial_h_fixed[1:3,2] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ])
partial_h_fixed[1:3,3] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ])





#Now I will create the W
mask_w <- matrix(TRUE, 
                 nrow = (length(final_markers_partial_model) + length(extra_marker_genes_semireference)), 
                 ncol = 4)
colnames(mask_w) <- paste0('cluster_', c(1:3, 'unknown_1'))
rownames(mask_w) <- c(final_markers_partial_model, extra_marker_genes_semireference)
mask_w[(length(final_markers_partial_model)+1):nrow(mask_w), 1:4] <- FALSE
mask_w[1:length(final_markers_partial_model), 4] <- FALSE

# I have k cell-types rows by m samples. I want to add the same proportions to the first three wild-type samples corresponding to the 
# '6_8W' time points
partial_w_fixed <- matrix(0, 
                          nrow = (length(final_markers_partial_model) + length(extra_marker_genes_semireference)), 
                          ncol = 4)
colnames(partial_w_fixed) <- paste0('cluster_', c(1:3, 'unknown_1'))
rownames(partial_w_fixed) <-  c(final_markers_partial_model, extra_marker_genes_semireference)

#Let's filter the w matrix reference (partially)
w_matrix_reference_basis_fixed <- as.data.frame(w_matrix_reference$basis)
w_matrix_reference_basis_fixed <- w_matrix_reference_basis_fixed[final_markers_partial_model, ]

partial_w_fixed[1:length(final_markers_partial_model), 1:3] <- as.matrix(w_matrix_reference_basis_fixed)

```

Now we can create the partial references with TWO OR MORE fixed cell-type
```{r creation.mask.matrices.h.w.one.celltype}

extra_unknown_celltypes <- 2

# I have n genes as rows and m+1 columns, being the last one the unknown one. 
mask_h <- matrix(FALSE, nrow = (3+extra_unknown_celltypes), ncol = 12)
colnames(mask_h) <- standard_name_thymus
rownames(mask_h) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes)))

# In this case, I can do two things: 1. Fix just the celltypes that I have as reference and the unknown leave it as black. 2. Assign the unknown cell-type as zero, since it suppose to be a WT, and then in the other conditions it will appear a proportion. Also the Tumor DNMT1 KO, will be similar to WT.
version <- 'two'
if(version=='one'){
  #Version 1.
  mask_h[1:3,1:3] <- TRUE
}else if(version=='two'){
  #Version 1.
  mask_h[1:(3+extra_unknown_celltypes),1:3] <- TRUE
}




#Now let's put the proportions that I needed, filling with zeros the rest
partial_h_fixed <- matrix(0, nrow = (3+extra_unknown_celltypes), ncol = 12)
colnames(partial_h_fixed) <- standard_name_thymus
rownames(partial_h_fixed) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes)))
#let's take the proportion
proportions_wt_single_cell <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.top$pseudo.bulk.data$truep) 
colnames(proportions_wt_single_cell) <- c('sample_6_8W')
proportions_wt_single_cell <- t(proportions_wt_single_cell)
proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ]

#Since I have three replicates I have to fix the proportions three times
partial_h_fixed[1:3,1] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ])
partial_h_fixed[1:3,2] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ])
partial_h_fixed[1:3,3] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ])





#Now I will create the W
mask_w <- matrix(TRUE, 
                 nrow = (length(final_markers_partial_model) + length(extra_marker_genes_semireference)), 
                 ncol = (3+extra_unknown_celltypes))
colnames(mask_w) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes)))
rownames(mask_w) <- c(final_markers_partial_model, extra_marker_genes_semireference)
mask_w[1:length(final_markers_partial_model), (3+1):(3+extra_unknown_celltypes)] <- FALSE
mask_w[(length(final_markers_partial_model)+1):nrow(mask_w), 1:(3+extra_unknown_celltypes)] <- FALSE

# I have k cell-types rows by m samples. I want to add the same proportions to the first three wild-type samples corresponding to the 
# '6_8W' time points
partial_w_fixed <- matrix(0, 
                          nrow = (length(final_markers_partial_model) + length(extra_marker_genes_semireference)), 
                          ncol = (3+extra_unknown_celltypes))
colnames(partial_w_fixed) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes)))
rownames(partial_w_fixed) <-  c(final_markers_partial_model, extra_marker_genes_semireference)

#Let's filter the w matrix reference (partially)
w_matrix_reference_basis_fixed <- as.data.frame(w_matrix_reference$basis)
w_matrix_reference_basis_fixed <- w_matrix_reference_basis_fixed[final_markers_partial_model, ]

partial_w_fixed[1:length(final_markers_partial_model), 1:3] <- as.matrix(w_matrix_reference_basis_fixed)

```

Now we can create the partial references with TWO OR MORE fixed cell-type but fixing the proportion results of the original model and the actual wt.
```{r creation.mask.matrices.h.w.one.celltype}

extra_unknown_celltypes <- 2

# I have n genes as rows and m+1 columns, being the last one the unknown one. 
mask_h <- matrix(FALSE, nrow = (3+extra_unknown_celltypes), ncol = 12)
colnames(mask_h) <- standard_name_thymus
rownames(mask_h) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes)))

# In this case, I can do two things: 1. Fix just the celltypes that I have as reference and the unknown leave it as black. 2. Assign the unknown cell-type as zero, since it suppose to be a WT, and then in the other conditions it will appear a proportion. Also the Tumor DNMT1 KO, will be similar to WT.
version <- 'two'
if(version=='one'){
  #Version 1.
  mask_h[1:3,1:3] <- TRUE
}else if(version=='two'){
  #Version 1.
  mask_h[1:(3+extra_unknown_celltypes),1:3] <- TRUE
  
  #Fixing all the proportions
  #mask_h[1:3,4:12] <- TRUE
}




#Now let's put the proportions that I needed, filling with zeros the rest
partial_h_fixed <- matrix(0, nrow = (3+extra_unknown_celltypes), ncol = 12)
colnames(partial_h_fixed) <- standard_name_thymus
rownames(partial_h_fixed) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes)))
#let's take the proportion
proportions_wt_single_cell <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.top$pseudo.bulk.data$truep) 
colnames(proportions_wt_single_cell) <- c('sample_6_8W')
proportions_wt_single_cell <- t(proportions_wt_single_cell)
proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ]

#Since I have three replicates I have to fix the proportions three times
partial_h_fixed[1:3,1] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ])
partial_h_fixed[1:3,2] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ])
partial_h_fixed[1:3,3] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(1:3)) ])



###################### Using data from the standard model.
#Without any mask constraint it will be the inicialization.
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Getting the proportions from the model
proportions.normal.model <- deco.actual.data.thymus.reduced.results.top$back_propagation_proportions_top_detailed[paste0('cluster_', 1:3), standard_name_thymus]


#Adding the proportions for the first three cell types: normal deconvolution
partial_h_fixed[1:3,1:12] <- as.matrix(proportions.normal.model)





#Now I will create the W
mask_w <- matrix(TRUE, 
                 nrow = (length(final_markers_partial_model) + length(extra_marker_genes_semireference)), 
                 ncol = (3+extra_unknown_celltypes))
colnames(mask_w) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes)))
rownames(mask_w) <- c(final_markers_partial_model, extra_marker_genes_semireference)
mask_w[1:length(final_markers_partial_model), (3+1):(3+extra_unknown_celltypes)] <- FALSE
mask_w[(length(final_markers_partial_model)+1):nrow(mask_w), 1:(3+extra_unknown_celltypes)] <- FALSE

# I have k cell-types rows by m samples. I want to add the same proportions to the first three wild-type samples corresponding to the 
# '6_8W' time points
partial_w_fixed <- matrix(0, 
                          nrow = (length(final_markers_partial_model) + length(extra_marker_genes_semireference)), 
                          ncol = (3+extra_unknown_celltypes))
colnames(partial_w_fixed) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes)))
rownames(partial_w_fixed) <-  c(final_markers_partial_model, extra_marker_genes_semireference)

#Let's filter the w matrix reference (partially)
w_matrix_reference_basis_fixed <- as.data.frame(w_matrix_reference$basis)
w_matrix_reference_basis_fixed <- w_matrix_reference_basis_fixed[final_markers_partial_model, ]

partial_w_fixed[1:length(final_markers_partial_model), 1:3] <- as.matrix(w_matrix_reference_basis_fixed)

```


### 5.1.3. Running deconvolution with partial reference model

```{r}
#Top calculation
# First filter cpgs associated with marker genes.
expression.CpGs.hits.meth.filtered.marker.genes.partial.top <- expression.CpGs.hits.meth[expression.CpGs.hits.meth$gene_name %in% c(final_markers_partial_model, extra_marker_genes_semireference),]
#I filtered the CpGs that are associated with the marker genes.
perc.meth.thymus.filtered.marker.genes.partial.top <- perc.meth.thymus[unique(expression.CpGs.hits.meth.filtered.marker.genes.partial.top$ID_METH),]
```


Finally we can put together the model and run the partial conditioned deconvolution model to see if that work
```{r flat.deconvolution.partial.references}

order_normalized <- paste0('cluster_', c(1:3))


#Only WT and tumor
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001

#Replacing zeros and nulls with a small value.
perc.meth.thymus.temp <- data.frame(perc.meth.thymus.filtered.marker.genes.partial.top) # 2,290
perc.meth.thymus.temp[is.na(perc.meth.thymus.temp)] <- 0.00000000001
bulk_data_meth <- perc.meth.thymus.temp[, standard_name_thymus]

proportion_constraint_h = TRUE

start_time <- Sys.time()

# I run the deconvolution without any other parameter
deco.alpha.beta.zero.results.partial.top <- run_complete_deconvolution(
  x_matrix = data.frame(eset.thymus.bulk.sparse.df.filtered[c(final_markers_partial_model, extra_marker_genes_semireference), standard_name_thymus]),
  y_matrix = data.frame(bulk_data_meth),
  z_matrix = NULL,
  k = (3+extra_unknown_celltypes),
  alpha = 0.00001, 
  beta = 0,
  delta_threshold=1e-10, 
  max_iterations=100, 
  #I have to deactivate the sum 1 because that is just for the 3 cell types
  proportion_constraint_h = proportion_constraint_h,
  partial_w_fixed=data.frame(partial_w_fixed[c(final_markers_partial_model, extra_marker_genes_semireference), ]),
  partial_h_fixed=data.frame(partial_h_fixed[, standard_name_thymus]),
  w_mask_fixed=data.frame(mask_w[,]),
  h_mask_fixed=data.frame(mask_h[, standard_name_thymus]),
  batches_partial_fixed=1)

end_time <- Sys.time()
end_time - start_time
```

Saving models
```{r saving_models}
 # save(deco.alpha.beta.zero.results.partial.top, file = paste0(
 #   '/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/figures_manuscript/', 
 #   'deco.alpha.beta.zero.results.partial.top_Thy_KO_vs_Thy_WT.Rdata'))
```


Analysis of proportions
```{r proportions.assignment}
colSums(deco.alpha.beta.zero.results.partial.top$h[1:3,])

prop_recal <- deco.alpha.beta.zero.results.partial.top$h

sum(prop_recal[1:3,1:3])

if(proportion_constraint_h){
  
}else{
  prop_recal[1:3, ] <- prop_recal[1:3, ]/colSums(prop_recal[1:3, ])
}

prop_recal.recal <- sweep(prop_recal,2,colSums(prop_recal),FUN="/")
colSums(prop_recal.recal)
prop_recal <- prop_recal.recal

prop_recal
```


### 5.1.4. Plot with semireference model proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion.flat.model}

order_normalized <- paste0('cluster_', c('1','2','3', paste0('unknown_', 1:extra_unknown_celltypes)))
order_samples <- c('sample_6_8W')
list_pseudotime <- c('DN', 'DP','CDs', paste0('unknown_', 1:extra_unknown_celltypes))

#Calculate the proportion for clusters for 3 clusters
real_proportion <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.top$pseudo.bulk.data$truep)
real_proportion <- t(real_proportion)
rownames(real_proportion) <- c('sample_6_8W')

#Initialization of extra clusters unknown
for(extra in 1:extra_unknown_celltypes){
  names_temp <- c(colnames(real_proportion), paste0('cluster_unknown_', extra))
  real_proportion <- cbind(real_proportion, 0)
  colnames(real_proportion) <- names_temp
}

real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]
real_proportion.pseudotime.rescaled <- real_proportion.pseudotime

#just checking. Everything should sum up 1.
sum(real_proportion.pseudotime.rescaled)
#Adding names
names(real_proportion.pseudotime.rescaled) <- list_pseudotime
real_proportion.pseudotime.rescaled <- data.frame(real_proportion.pseudotime.rescaled)
real_proportion.pseudotime.rescaled <- t(real_proportion.pseudotime.rescaled)
rownames(real_proportion.pseudotime.rescaled) <-  c('sample_6_8W')

# All experiments
experimental_data <- t(prop_recal[order_normalized, ])
experimental_data <- data.frame(experimental_data)
colnames(experimental_data) <- list_pseudotime


#Joining the bulk data wt
comparison_real_vs_deconvolution <- rbind(experimental_data, real_proportion.pseudotime.rescaled)


thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))

thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))


thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)

thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_KO'] <- 'KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'Thy_ALKpos_KO'] <- 'ALKKO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_6_8W'] <- '6_8w_thymus')

thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO', 'ALK', 'ALKKO', '6_8w_thymus'))

#thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl'))

#real proportion vs control
thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)

# assign values to zero
#thymus.proportions.deconvolution.summarized.melt$value[thymus.proportions.deconvolution.summarized.melt$value < 0.01] = 0.01

plot_proportions_top_semireference.2.unknown <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% c('Ctrl', 'KO', 'ALK', 'ALKKO', '6_8w_thymus') & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
  geom_point(size=4, shape=20, alpha = .30, position=position_jitter(width=.3,height=.00)) +
  labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text=element_text(size=16),
        legend.title = element_text(size = 16),
          legend.text = element_text(size = 16)) + 
  ylim(-0.1, 1.0)
 
plot_proportions_top_semireference.2.unknown <- plot_proportions_top_semireference.2.unknown +  scale_color_manual(name = "Sample", breaks = c('6_8w_thymus', 'Ctrl', 'KO', 'ALK', 'ALKKO'), values = c("darkgrey", "#136c38", "blue", "red", "orange")) + theme_light()

p

save_plot_as_pdf(plot_proportions_top_semireference.2.unknown, 'plot_proportions_top_semireference_de_Thy_ALKpos_KO_vs_Thy_WT.pdf', 8, 5)

```

Normal version
```{r heatmap.level.top.semireference, fig.height=40, fig.width=15}

#Creation of genes for the new unknown celltype
top.level.1.markers.detailed_all.unknown <- data.frame(cbind(extra_marker_genes_semireference, 'subcluster_level_1_leaf_4', TRUE))
colnames(top.level.1.markers.detailed_all.unknown) <- colnames(top.level.1.markers.detailed_all$top.markers.detailed_all)
rownames(top.level.1.markers.detailed_all.unknown) <- top.level.1.markers.detailed_all.unknown$gene_name

#Adding those to the new one
top.level.1.markers.detailed_all.plus.unknow <- rbind(top.level.1.markers.detailed_all$top.markers.detailed_all,
                                                      top.level.1.markers.detailed_all.unknown)

#Plot with heatmap level 1
plot.level.top.semireference <- plot_heatmap_markers_multiple_level(
                     sc.eset.metacluster.all = eset.sc.thymus.6.8.w.sparse.metacluster,
                     sc.bulk.data.filtered.tpm = eset.thymus.bulk.sparse.df.filtered.tpm,
                     pseudo.bulk.df.filtered.tpm = sc.pseudo.bulk.data.top,
                     res.object.de = RES.thymus.lfc$treatment_Thy_ALKpos_KO_vs_Thy_WT, 
                     top.markers.detailed_all = top.level.1.markers.detailed_all.plus.unknow,
                     clustering_variable = 'cluster_normalized_bigstage',
                     list_cell_types = c(1:7), 
                     row_km_value = 1,
                     column.clusters = paste0('cluster_', 1:7),
                     color_left_groups = c("#D55E00", "#CC79A7", "skyblue", "darkgreen"), 
                     scale_activated = TRUE, 
                     show_legends = TRUE
                     ) 

plot(plot.level.top.semireference$plot)

save_plot_as_pdf(plot.level.top.semireference$plot, 'plot.level.top.semireference_de_Thy_ALKpos_KO_vs_Thy_WT.pdf', 15, 40)

#Saving the extra marker genes.
library("writexl")
path <- '/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/figures_manuscript/'
write_xlsx(top.level.1.markers.detailed_all.plus.unknow,paste0(path, "top.level.1.markers.detailed_all.plus.unknow.xlsx"))

```

```{r heatmap.bulk.data, fig.width=7, fig.height=30}

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

data_filtered_bulk <- plot.level.top.semireference$sc.bulk.data.scaled[extra_marker_genes_semireference,standard_name_thymus]
data_filtered_bulk <- na.omit(data_filtered_bulk)

plot.level.top.semireference_semireference <- Heatmap(data_filtered_bulk, name = "Markers",
                                 use_raster = FALSE,
                                 cluster_columns = FALSE,
                                 column_dend_reorder = TRUE,
                                 cluster_rows = TRUE,#
                                 row_dend_reorder = TRUE,#
                                 show_column_names = TRUE,
                                 row_km = 2,
                                 clustering_distance_rows = "pearson",
                                 column_split = c(rep('Thy_WT', 3),
                                                  rep('Thy_KO', 3),
                                                  rep('Tumor_ALKpos_WT', 3),
                                                  rep('Thy_ALKpos_KO', 3)),
                                 #row_split = top.markers.detailed_all$group,
                                 #row_labels = top.markers.detailed_all$gene_name,
                                 row_names_gp = gpar(fontsize = 8),
                                 column_names_gp = gpar(fontsize = 7),
                                 #left_annotation = ha.rows.left, 
                                 #right_annotation = ha.rows.right.v2,
                                 #top_annotation = ha.columns,
                                 column_dend_height = unit(90, "mm"), 
                                 row_dend_width =  unit(60, "mm"), 
                                 column_title_rot = 90,
                                 row_title = 'Marker genes'
)

plot(plot.level.top.semireference_semireference)


row_dendrogram_order <- row_dend(plot.level.top.semireference_semireference)
order_groups <- lapply(row_order(plot.level.top.semireference_semireference), function(x) list(x))

group.1 <- unlist(order_groups$'1')
group.2 <- unlist(order_groups$'2')

group.1.names <- plot.level.top.semireference_semireference@row_names_param$labels[group.1]

paste(shQuote(group.1.names, type="sh"), collapse=", ")

group.2.names <- plot.level.top.semireference_semireference@row_names_param$labels[group.2]
paste(shQuote(group.2.names, type="sh"), collapse=", ")

##Real groups

Group_real_1 <- c('Ace', 'Xist', 'Cfap70', 'Tuba3b', 'Gm16572', 'Serpinb1c', 'Lnp1', 'Wdr49',
                  'Pla2g4e', 'Ccnb3', 'Gm31135', 'Olfr1054', 'Gm38947', 'Gm30835', 'Gm45627', 'BC048559', 'Gm11751', 'Gm364', 'Gm45121', 'Tuba3a', '4930550L24Rik', 'Tex19.2', 'Tex13b', 'Nutm1', 'Dpep3', 'Gm16004', 'Gm6268', 'Tex19.1', '1700112J05Rik', 'Gm16206', 'Pnma5')


save_plot_as_pdf(plot.level.top.semireference_semireference, 'plot.level.top.bulkdata.extra_marker_semireference.pdf', 7, 30)


```
Version with unknown subclusters ordered
```{r heatmap.level.top.semireference.unknown.clusters, fig.height=35, fig.width=15}

#Creation of genes for the new unknown celltype
top.level.1.markers.detailed_all.unknown.1 <- data.frame(cbind(group.1.names, 'unknown_1', TRUE))
colnames(top.level.1.markers.detailed_all.unknown.1) <- colnames(top.level.1.markers.detailed_all$top.markers.detailed_all)
top.level.1.markers.detailed_all.unknown.2 <- data.frame(cbind(group.2.names, 'unknown_2', TRUE))
colnames(top.level.1.markers.detailed_all.unknown.2) <- colnames(top.level.1.markers.detailed_all$top.markers.detailed_all)

top.level.1.markers.detailed_all.unknown <-rbind(top.level.1.markers.detailed_all.unknown.1,
                                                 top.level.1.markers.detailed_all.unknown.2)

colnames(top.level.1.markers.detailed_all.unknown) <- colnames(top.level.1.markers.detailed_all$top.markers.detailed_all)
rownames(top.level.1.markers.detailed_all.unknown) <- top.level.1.markers.detailed_all.unknown$gene_name

#Adding those to the new one
top.level.1.markers.detailed_all.plus.unknow <- rbind(top.level.1.markers.detailed_all$top.markers.detailed_all,
                                                      top.level.1.markers.detailed_all.unknown)

#Plot with heatmap level 1
plot.level.top.semireference <- plot_heatmap_markers_multiple_level(
                     sc.eset.metacluster.all = eset.sc.thymus.6.8.w.sparse.metacluster,
                     sc.bulk.data.filtered.tpm = eset.thymus.bulk.sparse.df.filtered.tpm,
                     pseudo.bulk.df.filtered.tpm = sc.pseudo.bulk.data.top,
                     res.object.de = RES.thymus.lfc$treatment_Thy_ALKpos_KO_vs_Thy_WT, 
                     top.markers.detailed_all = top.level.1.markers.detailed_all.plus.unknow,
                     clustering_variable = 'cluster_normalized_bigstage',
                     list_cell_types = c(1:7), 
                     row_km_value = 1,
                     column.clusters = paste0('cluster_', 1:7),
                     color_left_groups = c("#D55E00", "#CC79A7", "skyblue", "darkgreen", "green"), 
                     scale_activated = TRUE, 
                     show_legends = TRUE
                     ) 

save_plot_as_pdf(plot.level.top.semireference$plot, 'plot.level.top.semireference_de_Thy_ALKpos_KO_vs_Thy_WT.pdf', 20, 15)


#Saving the extra marker genes.
library("writexl")
path <- '/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/figures_manuscript/'
write_xlsx(top.level.1.markers.detailed_all.plus.unknow,paste0(path, "top.level.1.markers.detailed_all.plus.unknow.xlsx"))

```

```{r matrix.w, fig.width=6, fig.height=50}

data.matrix.w <- deco.alpha.beta.zero.results.partial.top$w
data.matrix.w <- log1p((data.matrix.w))


bulkdata.extra_marker <- Heatmap(data.matrix.w, name = "Cell-type signature",
                                 use_raster = FALSE,
                                 cluster_columns = FALSE,
                                 column_dend_reorder = TRUE,
                                 cluster_rows = TRUE,#
                                 row_dend_reorder = TRUE,#
                                 show_column_names = TRUE,
                                 row_km = 5,
                                 clustering_distance_rows = "pearson",
                                 #column_split = column.values$column.names,
                                 #row_split = top.markers.detailed_all$group,
                                 #row_labels = top.markers.detailed_all$gene_name,
                                 row_names_gp = gpar(fontsize = 8),
                                 column_names_gp = gpar(fontsize = 7),
                                 #left_annotation = ha.rows.left, 
                                 #right_annotation = ha.rows.right.v2,
                                 #top_annotation = ha.columns,
                                 column_dend_height = unit(90, "mm"), 
                                 row_dend_width =  unit(60, "mm"), 
                                 column_title_rot = 90,
                                 row_title = 'Marker genes'
)

plot(bulkdata.extra_marker)

```


Finally, let's calculate the relative proportions based on the unknown celltype to correct everything...
```{r}

```


## 5.2. Partial deconvolution: CDs

Let's put together the marker genes from the flat deconvolution and the differential expressed genes.
```{r final.list.genes.cds}
black_list_genes <- c() #Xist?
de_genes.thymus.total <- de_genes.thymus.treatment_Thy_ALKpos_KO_vs_Thy_WT
de_genes.thymus <- de_genes.thymus.total[de_genes.thymus.total %in% black_list_genes == FALSE]

#Let's create the w reference with all the genes and then we could see which are shared with the final_markers_partial_model
# I don't use the one in the model becasue only has the marker genes in the reference and I need those  plus the Differential
# expressed ons
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
top_clusters_list = paste0('cluster_', c(6:7))
bulk_data = eset.thymus.bulk.sparse.df.filtered
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'

w_matrix_reference <- decoflex_build_cell_reference(
  x = single_cell_data_exp,
  ct.sub = top_clusters_list,
  ct.varname = sub_clusters_var,
  sample = sample,
  verbose = TRUE)

# sorting the results by columns
w_matrix_reference.basics <- w_matrix_reference$basis[, paste0('cluster_', c(6:7))]



#75
final_markers_partial_model <- c(de_genes.thymus, rownames(deco.actual.data.thymus.reduced.results.complete$deco_results_list$subcluster_level_1_leaf_3$result_deco_top_cluster$w))

#75
final_markers_partial_model <- unique(final_markers_partial_model)
length(final_markers_partial_model)

diff.1 <- setdiff(de_genes.thymus, final_markers_partial_model)

#46 (what???? why???)
shared.final.vs.w <- intersect(final_markers_partial_model, rownames(as.matrix(w_matrix_reference.basics)))
length(shared.final.vs.w)

#This are additional factors in the W matrix semireference
extra_marker_genes_semireference <- setdiff(de_genes.thymus, shared.final.vs.w)

final_markers_partial_model <- shared.final.vs.w


```

### 5.2.2. Creation of partial references: W and H

Now we can create the partial references with ONE fixed cell-type
```{r creation.mask.matrices.h.w.one.celltype}

# I have n genes as rows and m+1 columns, being the last one the unknown one. 
mask_h <- matrix(FALSE, nrow = (2+1), ncol = 12)
colnames(mask_h) <- standard_name_thymus
rownames(mask_h) <- paste0('cluster_', c(6:7, 'unknown'))

# In this case, I can do two things: 1. Fix just the celltypes that I have as reference and the unknown leave it as black. 2. Assign the unknown cell-type as zero, since it suppose to be a WT, and then in the other conditions it will appear a proportion. Also the Tumor DNMT1 KO, will be similar to WT.
version <- 'two'
if(version=='one'){
  #Version 1.
  mask_h[1:2,1:3] <- TRUE
}else if(version=='two'){
  #Version 1.
  mask_h[1:3,1:3] <- TRUE
}




#Now let's put the proportions that I needed, filling with zeros the rest
partial_h_fixed <- matrix(0, nrow = (2+1), ncol = 12)
colnames(partial_h_fixed) <- standard_name_thymus
rownames(partial_h_fixed) <- paste0('cluster_', c(6:7, 'unknown'))
#let's take the proportion
proportions_wt_single_cell <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.cds$pseudo.bulk.data$truep) 
colnames(proportions_wt_single_cell) <- c('sample_6_8W')
proportions_wt_single_cell <- t(proportions_wt_single_cell)
proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(6:7)) ]

#Scale to 1
proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(6:7))] <- proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(6:7))]/sum(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(6:7))])

#Since I have three replicates I have to fix the proportions three times
partial_h_fixed[1:2,1] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(6:7)) ])
partial_h_fixed[1:2,2] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(6:7)) ])
partial_h_fixed[1:2,3] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(6:7)) ])





#Now I will create the W
mask_w <- matrix(TRUE, 
                 nrow = (length(final_markers_partial_model) + length(extra_marker_genes_semireference)), 
                 ncol = 3)
colnames(mask_w) <- paste0('cluster_', c(6:7, 'unknown'))
rownames(mask_w) <- c(final_markers_partial_model, extra_marker_genes_semireference)
mask_w[(length(final_markers_partial_model)+1):nrow(mask_w), 1:3] <- FALSE
mask_w[1:length(final_markers_partial_model), 3] <- FALSE

# I have k cell-types rows by m samples. I want to add the same proportions to the first three wild-type samples corresponding to the 
# '6_8W' time points
partial_w_fixed <- matrix(0, 
                          nrow = (length(final_markers_partial_model) + length(extra_marker_genes_semireference)), 
                          ncol = 3)
colnames(partial_w_fixed) <- paste0('cluster_', c(6:7, 'unknown'))
rownames(partial_w_fixed) <-  c(final_markers_partial_model, extra_marker_genes_semireference)

#Let's filter the w matrix reference (partially)
w_matrix_reference_basis_fixed <- as.data.frame(w_matrix_reference$basis)
w_matrix_reference_basis_fixed <- w_matrix_reference_basis_fixed[final_markers_partial_model, ]

partial_w_fixed[1:length(final_markers_partial_model), 1:2] <- as.matrix(w_matrix_reference_basis_fixed)

```

### 5.2.3. Running deconvolution with partial reference model

```{r}
#Top calculation
# First filter cpgs associated with marker genes.
expression.CpGs.hits.meth.filtered.marker.genes.partial.cds <- expression.CpGs.hits.meth[expression.CpGs.hits.meth$gene_name %in% c(final_markers_partial_model, extra_marker_genes_semireference),]
#I filtered the CpGs that are associated with the marker genes.
perc.meth.thymus.filtered.marker.genes.partial.cds <- perc.meth.thymus[unique(expression.CpGs.hits.meth.filtered.marker.genes.partial.cds$ID_METH),]
```


Finally we can put together the model and run the partial conditioned deconvolution model to see if that work
```{r flat.deconvolution.partial.references}

order_normalized <- paste0('cluster_', c(6:7))


#Only WT and tumor
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001

#Replacing zeros and nulls with a small value.
perc.meth.thymus.temp <- data.frame(perc.meth.thymus.filtered.marker.genes.partial.cds) # 2,290
perc.meth.thymus.temp[is.na(perc.meth.thymus.temp)] <- 0.00000000001
bulk_data_meth <- perc.meth.thymus.temp[, standard_name_thymus]

proportion_constraint_h = TRUE

start_time <- Sys.time()

# I run the deconvolution without any other parameter
deco.alpha.beta.zero.results.partial.cds <- run_complete_deconvolution(
  x_matrix = data.frame(eset.thymus.bulk.sparse.df.filtered[c(final_markers_partial_model, extra_marker_genes_semireference), standard_name_thymus]),
  y_matrix = data.frame(bulk_data_meth),
  z_matrix = NULL,
  k = 3,
  alpha = 0.00001, 
  beta = 0,
  delta_threshold=1e-10, 
  max_iterations=8000, 
  #I have to deactivate the sum 1 because that is just for the 3 cell types
  proportion_constraint_h = proportion_constraint_h,
  partial_w_fixed=data.frame(partial_w_fixed[c(final_markers_partial_model, extra_marker_genes_semireference), ]),
  partial_h_fixed=data.frame(partial_h_fixed[, standard_name_thymus]),
  w_mask_fixed=data.frame(mask_w[,]),
  h_mask_fixed=data.frame(mask_h[, standard_name_thymus]),
  batches_partial_fixed=1)

end_time <- Sys.time()
end_time - start_time
```
Analysis of proportions
```{r proportions.assignment}
colSums(deco.alpha.beta.zero.results.partial.cds$h[1:2,])

prop_recal <- deco.alpha.beta.zero.results.partial.cds$h

sum(prop_recal[1:2,1:3])

if(proportion_constraint_h){
  
}else{
  prop_recal[1:2, ] <- prop_recal[1:2, ]/colSums(prop_recal[1:2, ])
}

prop_recal.recal <- sweep(prop_recal,2,colSums(prop_recal),FUN="/")
colSums(prop_recal.recal)
prop_recal <- prop_recal.recal

prop_recal
```


### 5.1.4. Plot with semireference model proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion.flat.model}
order_normalized <- paste0('cluster_', c('6','7', 'unknown'))
order_samples <- c('sample_6_8W')
list_pseudotime <- c('CD4', 'CD8', 'unknown')

#Calculate the proportion for clusters for 2 clusters
real_proportion <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.cds$pseudo.bulk.data$truep)
real_proportion <- t(real_proportion)
rownames(real_proportion) <- c('sample_6_8W')
real_proportion <- cbind(real_proportion, 'cluster_unknown'=0)



real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]
real_proportion.pseudotime.rescaled <- real_proportion.pseudotime/sum(real_proportion.pseudotime)

#just checking. Everything should sum up 1.
sum(real_proportion.pseudotime.rescaled)
#Adding names
names(real_proportion.pseudotime.rescaled) <- list_pseudotime
real_proportion.pseudotime.rescaled <- data.frame(real_proportion.pseudotime.rescaled)
real_proportion.pseudotime.rescaled <- t(real_proportion.pseudotime.rescaled)
rownames(real_proportion.pseudotime.rescaled) <-  c('sample_6_8W')

# All experiments
experimental_data <- t(prop_recal[order_normalized, ])
experimental_data <- data.frame(experimental_data)
colnames(experimental_data) <- list_pseudotime


#Joining the bulk data wt
comparison_real_vs_deconvolution <- rbind(experimental_data, real_proportion.pseudotime.rescaled)


thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))

thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))


thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)

thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_KO'] <- 'KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'Thy_ALKpos_KO'] <- 'ALKKO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_6_8W'] <- '6_8w_thymus')

thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO', 'ALK', 'ALKKO', '6_8w_thymus'))

#thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl'))

#real proportion vs control
thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)

# assign values to zero
#thymus.proportions.deconvolution.summarized.melt$value[thymus.proportions.deconvolution.summarized.melt$value < 0.01] = 0.01

p <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% c('Ctrl', 'KO', 'ALK', 'ALKKO', '6_8w_thymus') & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
  geom_point(size=4, shape=20, alpha = .30, position=position_jitter(width=.3,height=.00)) +
  labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text=element_text(size=16),
        legend.title = element_text(size = 16),
          legend.text = element_text(size = 16)) + 
  ylim(-0.1, 1.0)
 
p <- p +  scale_color_manual(name = "Sample", breaks = c('6_8w_thymus', 'Ctrl', 'KO', 'ALK', 'ALKKO'), values = c("darkgrey", "#136c38", "blue", "red", "orange")) + theme_light()

p

save_plot_as_pdf(p, 'plot_proportions_cds_semireference_de_Thy_ALKpos_KO_vs_Thy_WT.pdf', 8, 5)

```
```{r data.markers.top}
#Version with the marker dataset and the marker repited by celltype
top.level.1.markers.detailed_cds <- create_dataset_markers_multiple_levels(
  result_level_object = deco.actual.data.thymus.reduced.results.complete$deco_results_list$subcluster_level_1_leaf_3,
  level_list = c('cluster_6', 'cluster_7'))
```

```{r heatmap.level.top.semireference, fig.height=8, fig.width=15}

#Creation of genes for the new unknown celltype
top.level.1.markers.detailed_cds.unknown <- data.frame(cbind(extra_marker_genes_semireference, 'cluster_unknown', TRUE))
colnames(top.level.1.markers.detailed_cds.unknown) <- colnames(top.level.1.markers.detailed_cds$top.markers.detailed_all)
rownames(top.level.1.markers.detailed_cds.unknown) <- top.level.1.markers.detailed_cds.unknown$gene_name

#Adding those to the new one
top.level.1.markers.detailed_cds.plus.unknown <- rbind(top.level.1.markers.detailed_cds$top.markers.detailed_all,
                                                      top.level.1.markers.detailed_cds.unknown)

#Plot with heatmap level 1
plot.level.cds.semireference <- plot_heatmap_markers_multiple_level(
                     sc.eset.metacluster.all = eset.sc.thymus.6.8.w.sparse.metacluster,
                     sc.bulk.data.filtered.tpm = eset.thymus.bulk.sparse.df.filtered.tpm,
                     pseudo.bulk.df.filtered.tpm = sc.pseudo.bulk.data.cds,
                     res.object.de = RES.thymus.lfc$treatment_Thy_ALKpos_KO_vs_Thy_WT, 
                     top.markers.detailed_all = top.level.1.markers.detailed_cds.plus.unknown,
                     clustering_variable = 'cluster_normalized_bigstage',
                     list_cell_types = c(6:7), 
                     row_km_value = 2,
                     column.clusters = paste0('cluster_', 6:7),
                     color_left_groups = c("#D55E00", "#CC79A7", "skyblue", "darkgreen"), 
                     scale_activated = TRUE, 
                     show_legends = TRUE
                     )

save_plot_as_pdf(plot.level.cds.semireference$plot, 'plot.level.cds.semireference_de_Thy_ALKpos_KO_vs_Thy_WT.pdf', 20, 15)

#Saving the extra marker genes.
library("writexl")
path <- '/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/figures_manuscript/'
write_xlsx(top.level.1.markers.detailed_cds.plus.unknown,paste0(path, "top.level.1.markers.detailed_cds.unknown.xlsx"))

```

## 5.3. Partial deconvolution: DP

Let's put together the marker genes from the flat deconvolution and the differential expressed genes.
```{r final.list.genes.dp}
black_list_genes <- c() #Xist?
de_genes.thymus.total <- de_genes.thymus.treatment_Thy_KO_vs_Thy_WT
de_genes.thymus <- de_genes.thymus.total[de_genes.thymus.total %in% black_list_genes == FALSE]

#Let's create the w reference with all the genes and then we could see which are shared with the final_markers_partial_model
# I don't use the one in the model becasue only has the marker genes in the reference and I need those  plus the Differential
# expressed ons
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
top_clusters_list = paste0('cluster_', c(2:5))
bulk_data = eset.thymus.bulk.sparse.df.filtered
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'

w_matrix_reference <- decoflex_build_cell_reference(
  x = single_cell_data_exp,
  ct.sub = top_clusters_list,
  ct.varname = sub_clusters_var,
  sample = sample,
  verbose = TRUE)

# sorting the results by columns
w_matrix_reference.basics <- w_matrix_reference$basis[, paste0('cluster_', c(2:5))]



#75
final_markers_partial_model <- c(de_genes.thymus, rownames(deco.actual.data.thymus.reduced.results.complete$deco_results_list$subcluster_level_1_leaf_2$result_deco_top_cluster$w))

#75
final_markers_partial_model <- unique(final_markers_partial_model)
length(final_markers_partial_model)

diff.1 <- setdiff(de_genes.thymus, final_markers_partial_model)

#46 (what???? why???)
shared.final.vs.w <- intersect(final_markers_partial_model, rownames(as.matrix(w_matrix_reference.basics)))
length(shared.final.vs.w)

#This are additional factors in the W matrix semireference
extra_marker_genes_semireference <- setdiff(de_genes.thymus, shared.final.vs.w)

final_markers_partial_model <- shared.final.vs.w


```

### 5.2.2. Creation of partial references: W and H

Now we can create the partial references with ONE fixed cell-type
```{r creation.mask.matrices.h.w.one.celltype.dp}

# I have n genes as rows and m+1 columns, being the last one the unknown one. 
mask_h <- matrix(FALSE, nrow = (4+1), ncol = 12)
colnames(mask_h) <- standard_name_thymus
rownames(mask_h) <- paste0('cluster_', c(2:5, 'unknown'))

# In this case, I can do two things: 1. Fix just the celltypes that I have as reference and the unknown leave it as black. 2. Assign the unknown cell-type as zero, since it suppose to be a WT, and then in the other conditions it will appear a proportion. Also the Tumor DNMT1 KO, will be similar to WT.
version <- 'two'
if(version=='one'){
  #Version 1.
  mask_h[1:4,1:3] <- TRUE
}else if(version=='two'){
  #Version 1.
  mask_h[1:5,1:3] <- TRUE
}




#Now let's put the proportions that I needed, filling with zeros the rest
partial_h_fixed <- matrix(0, nrow = (4+1), ncol = 12)
colnames(partial_h_fixed) <- standard_name_thymus
rownames(partial_h_fixed) <- paste0('cluster_', c(2:5, 'unknown'))
#let's take the proportion
proportions_wt_single_cell <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.cds$pseudo.bulk.data$truep) 
colnames(proportions_wt_single_cell) <- c('sample_6_8W')
proportions_wt_single_cell <- t(proportions_wt_single_cell)
proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(2:5)) ]

#Scale to 1
proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(2:5))] <- proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(2:5))]/sum(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(2:5))])

#Since I have three replicates I have to fix the proportions three times
partial_h_fixed[1:4,1] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(2:5)) ])
partial_h_fixed[1:4,2] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(2:5)) ])
partial_h_fixed[1:4,3] <- as.matrix(proportions_wt_single_cell['sample_6_8W', paste0('cluster_', c(2:5)) ])





#Now I will create the W
mask_w <- matrix(TRUE, 
                 nrow = (length(final_markers_partial_model) + length(extra_marker_genes_semireference)), 
                 ncol = (4+1))
colnames(mask_w) <- paste0('cluster_', c(2:5, 'unknown'))
rownames(mask_w) <- c(final_markers_partial_model, extra_marker_genes_semireference)
mask_w[(length(final_markers_partial_model)+1):nrow(mask_w), 1:5] <- FALSE
mask_w[1:length(final_markers_partial_model), (4+1)] <- FALSE

# I have k cell-types rows by m samples. I want to add the same proportions to the first three wild-type samples corresponding to the 
# '6_8W' time points
partial_w_fixed <- matrix(0, 
                          nrow = (length(final_markers_partial_model) + length(extra_marker_genes_semireference)), 
                          ncol = (4+1))
colnames(partial_w_fixed) <- paste0('cluster_', c(2:5, 'unknown'))
rownames(partial_w_fixed) <-  c(final_markers_partial_model, extra_marker_genes_semireference)

#Let's filter the w matrix reference (partially)
w_matrix_reference_basis_fixed <- as.data.frame(w_matrix_reference$basis)
w_matrix_reference_basis_fixed <- w_matrix_reference_basis_fixed[final_markers_partial_model, ]

partial_w_fixed[1:length(final_markers_partial_model), 1:4] <- as.matrix(w_matrix_reference_basis_fixed)

```

### 5.2.3. Running deconvolution with partial reference model

```{r calculation.dp}
#Top calculation
# First filter cpgs associated with marker genes.
expression.CpGs.hits.meth.filtered.marker.genes.partial.dp <- expression.CpGs.hits.meth[expression.CpGs.hits.meth$gene_name %in% c(final_markers_partial_model, extra_marker_genes_semireference),]
#I filtered the CpGs that are associated with the marker genes.
perc.meth.thymus.filtered.marker.genes.partial.dp <- perc.meth.thymus[unique(expression.CpGs.hits.meth.filtered.marker.genes.partial.dp$ID_METH),]
```


Finally we can put together the model and run the partial conditioned deconvolution model to see if that work
```{r flat.deconvolution.partial.references.dp}

order_normalized <- paste0('cluster_', c(2:5))


#Only WT and tumor
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3")

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001

#Replacing zeros and nulls with a small value.
perc.meth.thymus.temp <- data.frame(perc.meth.thymus.filtered.marker.genes.partial.dp) # 2,290
perc.meth.thymus.temp[is.na(perc.meth.thymus.temp)] <- 0.00000000001
bulk_data_meth <- perc.meth.thymus.temp[, standard_name_thymus]

proportion_constraint_h = TRUE

start_time <- Sys.time()

# I run the deconvolution without any other parameter
deco.alpha.beta.zero.results.partial.dp <- run_complete_deconvolution(
  x_matrix = data.frame(eset.thymus.bulk.sparse.df.filtered[c(final_markers_partial_model, extra_marker_genes_semireference), standard_name_thymus]),
  y_matrix = data.frame(bulk_data_meth),
  z_matrix = NULL,
  k = 5,
  alpha = 0.00001, 
  beta = 0,
  delta_threshold=1e-10, 
  max_iterations=8000, 
  #I have to deactivate the sum 1 because that is just for the 3 cell types
  proportion_constraint_h = proportion_constraint_h,
  partial_w_fixed=data.frame(partial_w_fixed[c(final_markers_partial_model, extra_marker_genes_semireference), ]),
  partial_h_fixed=data.frame(partial_h_fixed[, standard_name_thymus]),
  w_mask_fixed=data.frame(mask_w[,]),
  h_mask_fixed=data.frame(mask_h[, standard_name_thymus]),
  batches_partial_fixed=1)

end_time <- Sys.time()
end_time - start_time
```

Analysis of proportions
```{r proportions.assignment.dp}
colSums(deco.alpha.beta.zero.results.partial.dp$h[1:4,])

prop_recal <- deco.alpha.beta.zero.results.partial.dp$h

sum(prop_recal[1:4,1:5])

if(proportion_constraint_h){
  
}else{
  prop_recal[1:4, ] <- prop_recal[1:4, ]/colSums(prop_recal[1:4, ])
}

prop_recal.recal <- sweep(prop_recal,2,colSums(prop_recal),FUN="/")
colSums(prop_recal.recal)
prop_recal <- prop_recal.recal

prop_recal
```


### 5.1.4. Plot with semireference model proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion.flat.model.dp}
order_normalized <- paste0('cluster_', c('2','3', '4', '5', 'unknown'))
order_samples <- c('sample_6_8W')
list_pseudotime <- c("2preDP", "3DPbla", "4DPre", "5DPsel", 'unknown')

#Calculate the proportion for clusters for 2 clusters
real_proportion <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.dp$pseudo.bulk.data$truep)
real_proportion <- t(real_proportion)
rownames(real_proportion) <- c('sample_6_8W')
real_proportion <- cbind(real_proportion, 'cluster_unknown'=0)



real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]
real_proportion.pseudotime.rescaled <- real_proportion.pseudotime/sum(real_proportion.pseudotime)

#just checking. Everything should sum up 1.
sum(real_proportion.pseudotime.rescaled)
#Adding names
names(real_proportion.pseudotime.rescaled) <- list_pseudotime
real_proportion.pseudotime.rescaled <- data.frame(real_proportion.pseudotime.rescaled)
real_proportion.pseudotime.rescaled <- t(real_proportion.pseudotime.rescaled)
rownames(real_proportion.pseudotime.rescaled) <-  c('sample_6_8W')

# All experiments
experimental_data <- t(prop_recal[order_normalized, ])
experimental_data <- data.frame(experimental_data)
colnames(experimental_data) <- list_pseudotime


#Joining the bulk data wt
comparison_real_vs_deconvolution <- rbind(experimental_data, real_proportion.pseudotime.rescaled)


thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))

thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))


thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)

thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_KO'] <- 'KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'Thy_ALKpos_KO'] <- 'ALKKO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_6_8W'] <- '6_8w_thymus')

thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'KO', 'ALK', 'ALKKO', '6_8w_thymus'))

#thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl'))

#real proportion vs control
thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)

# assign values to zero
#thymus.proportions.deconvolution.summarized.melt$value[thymus.proportions.deconvolution.summarized.melt$value < 0.01] = 0.01

p <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% c('Ctrl', 'KO', 'ALK', 'ALKKO', '6_8w_thymus') & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
  geom_point(size=4, shape=20, alpha = .30, position=position_jitter(width=.3,height=.00)) +
  labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text=element_text(size=16),
        legend.title = element_text(size = 16),
          legend.text = element_text(size = 16)) + 
  ylim(-0.1, 1.0)
 
p <- p +  scale_color_manual(name = "Sample", breaks = c('6_8w_thymus', 'Ctrl', 'KO', 'ALK', 'ALKKO'), values = c("darkgrey", "#136c38", "blue", "red", "orange")) + theme_light()

p

save_plot_as_pdf(p, 'plot_proportions_dp_semireference_de_Thy_KO_vs_Thy_WT.pdf', 8, 5)

```


```{r data.markers.top}
#Version with the marker dataset and the marker repited by celltype
top.level.1.markers.detailed_dp <- create_dataset_markers_multiple_levels(
  result_level_object = deco.actual.data.thymus.reduced.results.complete$deco_results_list$subcluster_level_1_leaf_2,
  level_list = paste0('cluster_', 2:5))
```

```{r heatmap.level.top.semireference, fig.height=20, fig.width=15}

#Creation of genes for the new unknown celltype
top.level.1.markers.detailed_dp.unknown <- data.frame(cbind(extra_marker_genes_semireference, 'cluster_unknown', TRUE))
colnames(top.level.1.markers.detailed_dp.unknown) <- colnames(top.level.1.markers.detailed_dp$top.markers.detailed_all)
rownames(top.level.1.markers.detailed_dp.unknown) <- top.level.1.markers.detailed_dp.unknown$gene_name

#Adding those to the new one
top.level.1.markers.detailed_dp.plus.unknown <- rbind(top.level.1.markers.detailed_dp$top.markers.detailed_all,
                                                      top.level.1.markers.detailed_dp.unknown)

#Plot with heatmap level 1
plot.level.dp.semireference <- plot_heatmap_markers_multiple_level(
                     sc.eset.metacluster.all = eset.sc.thymus.6.8.w.sparse.metacluster,
                     sc.bulk.data.filtered.tpm = eset.thymus.bulk.sparse.df.filtered.tpm,
                     pseudo.bulk.df.filtered.tpm = sc.pseudo.bulk.data.dp,
                     res.object.de = RES.thymus.lfc$treatment_Thy_KO_vs_Thy_WT, 
                     top.markers.detailed_all = top.level.1.markers.detailed_dp.plus.unknown,
                     clustering_variable = 'cluster_normalized_bigstage',
                     list_cell_types = c(2:5), 
                     row_km_value = 2,
                     column.clusters = paste0('cluster_', 2:5),
                     color_left_groups = c("#D55E00", "#CC79A7", "skyblue", "darkgreen"), 
                     scale_activated = TRUE, 
                     show_legends = TRUE
                     )

save_plot_as_pdf(plot.level.dp.semireference$plot, 'plot.level.dp.semireference_de_Thy_Thy_KO_vs_Thy_WT.pdf', 20, 15)

#Saving the extra marker genes.
library("writexl")
path <- '/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/figures_manuscript/'
write_xlsx(top.level.1.markers.detailed_dp.plus.unknown,paste0(path, "top.level.1.markers.detailed_dp.plus.unknown.xlsx"))

```







## 5.4. Recalculation of proportions

TODO: methylation matrix and Z matrix to see patterns in each submodel and in the main model.
TODO: Z matrix with methylation for genes, using all de cpgs even missing ones.
TODO: performance of the best model with the additional plot...including the new one with zoom
TODO: TF analysis with these marker genes
TODO: GO terms and enritchment analysis with CpGs and genes that marked the unknown cell-types (https://rpubs.com/jrgonzalezISGlobal/enrichment)

#6. Additional Hdac1 KO - Second collaboration

##6.0 Datasets

```{r importing.data.Hdac1.KO}

#The ALK tumors are: C348, C413, C452, C453
#The ALK Hdac1 KO tumors are: B840, B966, C424, C455.

path_new_bulk_data <- "/Users/crhisto/Google Drive/PHD_PROJECT/UNIVERSITY/033_third_gerda_collaboration/data/bulk_data/"

ALK_Hdac1_KO.bulk <- read.table(paste0(path_new_bulk_data, 'masa_raw_counts.csv'), 
                 header = TRUE,
                 row.names = 1,
                 sep = ",")

#Setting the column names
ALK_Hdac1_KO.bulk <- ALK_Hdac1_KO.bulk[, c('C348', 'C413', 'C452', 'C453', 'B840', 'B966', 'C424', 'C455')]
colnames(ALK_Hdac1_KO.bulk) <- c('Tumor_ALKpos_WTa_4', 'Tumor_ALKpos_WTa_5', 'Tumor_ALKpos_WTa_6', 'Tumor_ALKpos_WTa_7',
                                 'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

```

```{r tpm.convertion.Hdac1.KO}

# michael's version
# https://support.bioconductor.org/p/91218/
tpm_function <- function(counts,len) {
  x <- counts/len
  return(t(t(x)*1e6/colSums(x)))
}

#pseudo bulk data all 7 celltypes
len.values.Hdac1.KO <- colSums(deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.top$pseudo.bulk.data$pseudo_eset@assayData$exprs)
sc.pseudo.bulk.data.Hdac1.KO.top <- tpm_function(counts=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.top$pseudo.bulk.data$pseudo_eset@assayData$exprs, len=len.values.Hdac1.KO)

#pseudo bulk data all dp celltypes
len.values.Hdac1.KO <- colSums(deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.dp$pseudo.bulk.data$pseudo_eset@assayData$exprs)
sc.pseudo.bulk.data.Hdac1.KO.dp <- tpm_function(counts=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.dp$pseudo.bulk.data$pseudo_eset@assayData$exprs, len=len.values.Hdac1.KO)

#pseudo bulk data all dp celltypes
len.values.Hdac1.KO <- colSums(deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.cds$pseudo.bulk.data$pseudo_eset@assayData$exprs)
sc.pseudo.bulk.data.Hdac1.KO.cds <- tpm_function(counts=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.cds$pseudo.bulk.data$pseudo_eset@assayData$exprs, len=len.values.Hdac1.KO)
```


```{r calculate_size}

calculate_size_count <- function(count_data, filter = "ensembl_gene_id"){
  r <- rownames(count_data) %>% gsub("\\.\\d+", "", ., perl=TRUE)
  mart <- useMart(biomart = "ensembl", dataset = "mmusculus_gene_ensembl") 
  
  #Getting the gene names, positions
  genes_biomart <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", 'start_position', 'end_position'), filters = filter, values = r, 
    mart = mart)
  
  
  #genes_biomart <- data.frame(genes_biomart)
  #Calculating the size of each gene.
  genes_biomart$size <- genes_biomart$end_position-genes_biomart$start_position
  
  genes_biomart
}

mouse.size.count <- calculate_size_count(ALK_Hdac1_KO.bulk)

```
I will add the gene names for the original counts.
```{r nomal.counts}

ALK_Hdac1_KO.bulk.genes <- as.matrix(ALK_Hdac1_KO.bulk[mouse.size.count$ensembl_gene_id, ])
rownames(ALK_Hdac1_KO.bulk.genes) <- mouse.size.count$external_gene_name

```


```{r convert.tpm.ALK_Hdac1_KO}

#For tpm function and others
#install.packages("DGEobj")
library(DGEobj)


#install.packages("DGEobj.utils")
library(DGEobj.utils)


#1. First we could use the ensembl_gene_id to convert to tpm
ALK_Hdac1_KO.bulk.tpm <- DGEobj.utils::convertCounts(countsMatrix = as.matrix.data.frame(ALK_Hdac1_KO.bulk[mouse.size.count$ensembl_gene_id,]), unit = "TPM", 
                                                     geneLength = mouse.size.count$size, 
                                                     log = FALSE,
                                                     normalize = 'none', 
                                                     prior.count = NULL)

#2. Adding the gene names
rownames(ALK_Hdac1_KO.bulk.tpm) <- mouse.size.count$external_gene_name

```
```{r convert.tpm.thymus.dnmt1.ko}

#For tpm function and others
#install.packages("DGEobj")
library(DGEobj)


#install.packages("DGEobj.utils")
library(DGEobj.utils)

#0. generation the database
mouse.size.count.thymus.dnmt1.ko <- calculate_size_count(count_data = eset.thymus.bulk.sparse@assayData$exprs,
                                                         filter = "external_gene_name")
rownames(mouse.size.count.thymus.dnmt1.ko) <- mouse.size.count.thymus.dnmt1.ko$ensembl_gene_id
nrow(mouse.size.count.thymus.dnmt1.ko) #45927

#Convert to essamble id
eset.thymus.bulk.sparse.df <- data.frame(eset.thymus.bulk.sparse@assayData$exprs)

# Match symbols in dataframe and annotation file
matches <- match(mouse.size.count.thymus.dnmt1.ko$external_gene_name, rownames(eset.thymus.bulk.sparse.df))
sum(is.na(matches))
matches <- na.exclude((matches))

# Add ensID to a new column
eset.thymus.bulk.sparse.df$ensembl_gene_id <- "-"
eset.thymus.bulk.sparse.df$ensembl_gene_id[matches] <- mouse.size.count.thymus.dnmt1.ko$ensembl_gene_id # A sanity check was performed, which bound m$Approved.Symbol, and it always matched to rownames!
eset.thymus.bulk.sparse.df <- eset.thymus.bulk.sparse.df[which(eset.thymus.bulk.sparse.df$ensembl_gene_id != "-"),]
rownames(eset.thymus.bulk.sparse.df) <- eset.thymus.bulk.sparse.df$ensembl_gene_id
eset.thymus.bulk.sparse.ensembl <- eset.thymus.bulk.sparse.df[, colnames(eset.thymus.bulk.sparse@assayData$exprs)]
  
#using just the shared genes.  
shared_genes  <- intersect(rownames(eset.thymus.bulk.sparse.ensembl), mouse.size.count.thymus.dnmt1.ko$ensembl_gene_id)
mouse.size.count.thymus.dnmt1.ko <- mouse.size.count.thymus.dnmt1.ko[shared_genes, ]
eset.thymus.bulk.sparse.ensembl <- eset.thymus.bulk.sparse.ensembl[shared_genes,]


#1. First we could use the ensembl_gene_id to convert to tpm
eset.thymus.bulk.sparse.tpm <- DGEobj.utils::convertCounts(countsMatrix = as.matrix.data.frame(eset.thymus.bulk.sparse.ensembl[mouse.size.count.thymus.dnmt1.ko$ensembl_gene_id,]), unit = "TPM", 
                                                     geneLength = mouse.size.count.thymus.dnmt1.ko$size, 
                                                     log = FALSE,
                                                     normalize = 'none', 
                                                     prior.count = NULL)

#2. Adding the gene names
rownames(eset.thymus.bulk.sparse.tpm) <- mouse.size.count.thymus.dnmt1.ko$external_gene_name

```

Adding gene names
```{r new_ko.gene.names.Hdac1.KO}
  library(biomaRt)

translate_gene_id_improved <- function(counts_matrix) {
  
  r <- rownames(counts_matrix) %>% gsub("\\.\\d+", "", ., perl=TRUE)
  
  mart <- useMart(biomart = "ensembl", dataset = "mmusculus_gene_ensembl") 
  
  genes_biomart <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), filters = "ensembl_gene_id", values = r, 
  mart = mart)
  
  d <- tibble(ensembl_gene_id = r) %>%
    left_join(genes_biomart, by='ensembl_gene_id') %>% 
    mutate(gene_name = if_else(is.na(external_gene_name), ensembl_gene_id, external_gene_name))
  
  rownames(counts_matrix) <- d$gene_name
  counts_matrix
}

#2. After tpm I can convert to gene names.
ALK_Hdac1_KO.bulk.tpm.genes <- translate_gene_id_improved(ALK_Hdac1_KO.bulk.tpm)

```

```{r adding.bulk.data.Hdac1.KO.tpm}

#First lets see the shared genes
intersection.genes.tpm <- intersect(rownames(ALK_Hdac1_KO.bulk.tpm.genes), rownames(eset.thymus.bulk.sparse.tpm))
intersection.genes <- intersect(rownames(ALK_Hdac1_KO.bulk.genes), rownames(eset.thymus.bulk.sparse))


#Join with just the WT samples
count.join <- cbind(eset.thymus.bulk.sparse@assayData$exprs[intersection.genes, 
                                                            c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3")], ALK_Hdac1_KO.bulk.genes[intersection.genes, ])

count.join.tpm <- cbind(eset.thymus.bulk.sparse.tpm[intersection.genes.tpm, 
                                                            c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3")], ALK_Hdac1_KO.bulk.tpm.genes[intersection.genes.tpm, ])


#For normal counts
fdata <- intersection.genes
pdata <- cbind(subjects = colnames(count.join))
eset.thymus.bulk.sparse.expanded <- getESET(count.join, fdata = fdata, pdata = pdata)
colnames(eset.thymus.bulk.sparse.expanded@assayData$exprs)

#For tpm
fdata.tpm <- intersection.genes.tpm
pdata.tpm <- cbind(subjects = colnames(count.join.tpm))
eset.thymus.bulk.sparse.expanded.tpm <- getESET(count.join.tpm, fdata = fdata.tpm, pdata = pdata.tpm)
colnames(eset.thymus.bulk.sparse.expanded.tpm@assayData$exprs)
```

```{r adding.bulk.data.Hdac1.KO.counts}

#First lets see the shared genes
intersection.genes.counts <- intersect(rownames(ALK_Hdac1_KO.bulk.genes), rownames(eset.thymus.bulk.sparse))
#Join with just the WT samples
count.join.counts <- cbind(eset.thymus.bulk.sparse@assayData$exprs[intersection.genes.counts, 
                                                            c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3")], ALK_Hdac1_KO.bulk.genes[intersection.genes.counts, ])

fdata.counts <- intersection.genes.counts
pdata.counts <- cbind(subjects = colnames(count.join.counts))
eset.thymus.bulk.sparse.expanded.counts <- getESET(count.join.counts, fdata = fdata.counts, pdata = pdata.counts)
colnames(eset.thymus.bulk.sparse.expanded.counts@assayData$exprs)

eset.thymus.bulk.sparse.expanded.counts <- getESET(count.join.counts, fdata = fdata.counts, pdata = pdata.counts)
colnames(eset.thymus.bulk.sparse.expanded.counts@assayData$exprs)
```

## 6.1 TOP model: Hdac1 KO

### 6.1.1 Simulation

```{r hierarchy.top.Hdac1.KO}
hierarchical_clustering_sc_thymus.Hdac1.KO.top <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(1:3)), 
           next_level_clustering=NULL
  )
)
```


```{r deconvolution.simulation.Hdac1.KO.top}
#detach(package:DecoFlex,unload=TRUE)
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster[, eset.sc.thymus.6.8.w.sparse.metacluster$metacluster %in% paste0('cluster_', 1:3)]
hierarchy = hierarchical_clustering_sc_thymus.Hdac1.KO.top
sub_clusters_var <- 'metacluster'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.top <- 
  run_deconvolution_simulation_generic_recursive(single_cell_data_exp = single_cell_data_exp, 
                                                 hierarchy = hierarchy,
                                                 sub_clusters_var = sub_clusters_var,
                                                 sample = sample, 
                                                 use_min_cor_strategy = use_min_cor_strategy, 
                                                 delete_shared_level_markers = delete_shared_level_markers, 
                                                 delete_shared_internal_markers = delete_shared_internal_markers,
                                                 param.logfc.threshold = 1.0,
                                                 param.p_val_adj = 0.05,
                                                 verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

### 6.1.2 Deconvolution with manual hierarchy

Now we will run the deconvolution with the actual bulk dataset from Thymus experiment.
```{r deconvolution.manual.hierarchy.Hdac1.KO.top}
library(DecoFlex)

order_normalized <- paste0('cluster_', c(1:3))

standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse.expanded.no.batch.effect@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001


#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.Hdac1.KO.top$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'metacluster'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.reduced.results.Hdac1.KO.top <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 1.0,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 4,
                                          min_delta_cor_threshold = 0.3,
                                          verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion.reduced.Hdac1.KO.top}

order_normalized <- paste0('cluster_', c(1:3))
order_samples <- c('sample_6W')
#list_pseudotime <- c('DN','DP1','DP2', 'CD4', 'CD8','Others')
list_pseudotime <- c('DN','DP','CDs','Others')
list_pseudotime<- list_pseudotime[1:3]


#Plotting the top model
plot_top.wt_vs_ctrl.Hdac1.KO <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.top$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.Hdac1.KO.top$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')], 
                        levels = c('Ctrl','6w_thymus'), 
                        colors = c("#136c38", "grey"))
plot(plot_top.wt_vs_ctrl.Hdac1.KO)

#save_plot_as_pdf(plot_top.wt_vs_ctrl.Hdac1.KO, 'plot_top.wt_vs_ctrl.Hdac1.KO.pdf', 8, 5)

```

### 6.1.2.2 Plot real proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r real.proportions.Hdac1.KO.top}

order_normalized <- paste0('cluster_', c(1:3))
order_samples <- c('sample_6W')
#list_pseudotime <- c('DN','DP1','DP2', 'CD4', 'CD8','Others')
list_pseudotime <- c('DN','DP','CDs','Others')
list_pseudotime<- list_pseudotime[1:3]


#Plotting the top model
pr.plot_top.all.results.Hdac1.KO <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.top$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.Hdac1.KO.top$back_propagation_proportions_top_detailed[order_normalized, ], 
                        levels = c('Ctrl', 'ALK','ALKa', 'ALK_Hdac1_KO'), 
                        colors = c("turquoise3" , "#136c38", "blue", "red", "pink", "orange")[c(2:4, 6)])
plot(pr.plot_top.all.results.Hdac1.KO)

#save_plot_as_pdf(pr.plot_top.all.results.Hdac1.KO, 'pr.plot_top.all.results.Hdac1.KO.pdf', 8, 5)

```
Fix it!! TODO
```{r heatmap.bulk.data.Hdac1.KO, fig.width=7, fig.height=30}

standard_name_thymus.Hdac1.KO <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                          "Thy_KO_1", "Thy_KO_2", "Thy_KO_3",
                          "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                          "Thy_ALKpos_KO_1", "Thy_ALKpos_KO_2", "Thy_ALKpos_KO_3")

data_filtered_bulk <- plot.level.top.semireference$sc.bulk.data.scaled[extra_marker_genes_semireference,standard_name_thymus]
data_filtered_bulk <- na.omit(data_filtered_bulk)

bulkdata.extra_marker <- Heatmap(data_filtered_bulk, name = "Markers",
                                 use_raster = FALSE,
                                 cluster_columns = FALSE,
                                 column_dend_reorder = TRUE,
                                 cluster_rows = TRUE,#
                                 row_dend_reorder = TRUE,#
                                 show_column_names = TRUE,
                                 row_km = 5,
                                 clustering_distance_rows = "pearson",
                                 column_split = c(rep('Thy_WT', 3),
                                                  rep('Tumor_ALKpos_WT', 3),
                                                  rep('Tumor_ALKpos_WTa', 4),
                                                  rep('Tumor_ALK_Hdac1_KO', 4)),
                                 #row_split = top.markers.detailed_all$group,
                                 #row_labels = top.markers.detailed_all$gene_name,
                                 row_names_gp = gpar(fontsize = 8),
                                 column_names_gp = gpar(fontsize = 7),
                                 #left_annotation = ha.rows.left, 
                                 #right_annotation = ha.rows.right.v2,
                                 #top_annotation = ha.columns,
                                 column_dend_height = unit(90, "mm"), 
                                 row_dend_width =  unit(60, "mm"), 
                                 column_title_rot = 90,
                                 row_title = 'Marker genes'
)

plot(bulkdata.extra_marker)


row_dendrogram_order <- row_dend(bulkdata.extra_marker)
order_groups <- lapply(row_order(bulkdata.extra_marker), function(x) list(x))

group.1 <- unlist(order_groups$'1')
group.2 <- unlist(order_groups$'2')

group.1.names <- bulkdata.extra_marker@row_names_param$labels[group.1]
paste(shQuote(group.1.names, type="sh"), collapse=", ")

group.2.names <- bulkdata.extra_marker@row_names_param$labels[group.2]
paste(shQuote(group.2.names, type="sh"), collapse=", ")


```

## 6.2 DP Double-positive model: Hdac1 KO


### 6.2.1 Simulation

```{r hierarchy.Hdac1.KO.dp}
# Only for DN
hierarchical_clustering_sc_thymus.reduced.Hdac1.KO.dp <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(2:5)), 
           next_level_clustering=NULL
  )
)
```


```{r deconvolution.simulation.dp}
#detach(package:DecoFlex,unload=TRUE)
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.Hdac1.KO.dp
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.dp <- 
  run_deconvolution_simulation_generic_recursive(single_cell_data_exp = single_cell_data_exp, 
                                                 hierarchy = hierarchy,
                                                 sub_clusters_var = sub_clusters_var,
                                                 sample = sample, 
                                                 use_min_cor_strategy = use_min_cor_strategy, 
                                                 delete_shared_level_markers = delete_shared_level_markers, 
                                                 delete_shared_internal_markers = delete_shared_internal_markers,
                                                 param.logfc.threshold = 0.2,
                                                 param.p_val_adj = 0.05,
                                                 verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

### 6.2.2 Deconvolution with manual hierarchy

Now we will run the deconvolution with the actual bulk dataset from Thymus experiment.
```{r deconvolution.manual.hierarchy.Hdac1.KO.dp}
library(DecoFlex)

order_normalized <- paste0('cluster_', c(2:5))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse.expanded.no.batch.effect@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001


#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.Hdac1.KO.dp$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.reduced.results.Hdac1.KO.dp <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 0.2,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 40,
                                          min_delta_cor_threshold = 0.3,
                                          verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

#### 6.2.2.1 Proportions WT simulation

```{r plot_comparison_ctrl_proportion.reduced.Hdac1.KO.dp}

order_normalized <- paste0('cluster_', c(2:5))
order_samples <- c('sample_6W')
list_pseudotime <- c("2preDP", "3DPbla", "4DPre", "5DPsel")
list_pseudotime<- list_pseudotime[1:4]

#Plotting the top model
pr.plot_dp.wt_vs_ctrl.Hdac1.KO <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.dp$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.Hdac1.KO.dp$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')], 
                        levels = c('Ctrl','6w_thymus'), 
                        colors = c("#136c38", "grey"))
print(pr.plot_dp.wt_vs_ctrl.Hdac1.KO)

#save_plot_as_pdf(pr.plot_dp.wt_vs_ctrl.Hdac1.KO, 'pr.plot_dp.wt_vs_ctrl.Hdac1.KO.pdf', 8, 5)


```

#### 6.2.2.2 Plot real proportions

```{r real.proportions.Hdac1.KO.dp}

order_normalized <- paste0('cluster_', c(2:5))
order_samples <- c('sample_6W')
list_pseudotime <- c("2preDP", "3DPbla", "4DPre", "5DPsel")
list_pseudotime<- list_pseudotime[1:4]

#Plotting the top model
pr.plot_dp.all.results.Hdac1.KO <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.dp$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.Hdac1.KO.dp$back_propagation_proportions_top_detailed[order_normalized, ], 
                        levels = c('Ctrl', 'ALK','ALKa', 'ALK_Hdac1_KO'), 
                        colors = c("turquoise3" , "#136c38", "blue", "red", "pink", "orange")[c(2:4, 6)])
plot(pr.plot_dp.all.results.Hdac1.KO)

#save_plot_as_pdf(pr.plot_dp.all.results.Hdac1.KO, 'pr.plot_dp.all.results.Hdac1.KO.pdf', 8, 5)

```

## 6.3 CDs - CD4-CD8 model: Hdac1 KO

### 6.3.1 Simulation

```{r hierarchy.Hdac1.KO.cds}
#Only for cd4 and cd8
hierarchical_clustering_sc_thymus.reduced.Hdac1.KO.cds <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(6:7)), 
           next_level_clustering=NULL
  )
)
```


```{r deconvolution.simulation.Hdac1.KO.cds}
#detach(package:DecoFlex,unload=TRUE)
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.Hdac1.KO.cds
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.cds <- 
  run_deconvolution_simulation_generic_recursive(single_cell_data_exp = single_cell_data_exp, 
                                                 hierarchy = hierarchy,
                                                 sub_clusters_var = sub_clusters_var,
                                                 sample = sample, 
                                                 use_min_cor_strategy = use_min_cor_strategy, 
                                                 delete_shared_level_markers = delete_shared_level_markers, 
                                                 delete_shared_internal_markers = delete_shared_internal_markers,
                                                 param.logfc.threshold = 0.6,
                                                 param.p_val_adj = 0.05,
                                                 verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

### 6.3.2 Deconvolution with manual hierarchy

Now we will run the deconvolution with the actual bulk dataset from Thymus experiment.
```{r deconvolution.manual.hierarchy.Hdac1.KO.cds}
library(DecoFlex)

order_normalized <- paste0('cluster_', c(6:7))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse.expanded.tpm@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.Hdac1.KO.cds$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.reduced.results.Hdac1.KO.cds <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 0.6,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 8,
                                          min_delta_cor_threshold = 0.5,
                                          verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

#### 6.3.2.1 Proportions WT simulation

```{r plot_comparison_ctrl_proportion.reduced.Hdac1.KO.cds}

order_normalized <- paste0('cluster_', c(6:7))
order_samples <- c('sample_6W')
list_pseudotime <- c('CD4','CD8')

#Plotting the top model
pr.plot_cds.wt_vs_ctrl.Hdac1.KO <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.cds$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.Hdac1.KO.cds$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')], 
                        levels = c('Ctrl','6w_thymus'), 
                        colors = c("#136c38", "gray"))
plot(pr.plot_cds.wt_vs_ctrl.Hdac1.KO)

#save_plot_as_pdf(pr.plot_cds.wt_vs_ctrl.Hdac1.KO, 'pr.plot_cds.wt_vs_ctrl.Hdac1.KO.pdf', 8, 5)

```

#### 6.3.2.2 Plot real proportions

```{r real.proportions.Hdac1.KO.cds}

order_normalized <- paste0('cluster_', c(6:7))
order_samples <- c('sample_6W')
list_pseudotime <- c('CD4','CD8')

#Plotting the top model
pr.plot_cds.all.results.Hdac1.KO <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.cds$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.Hdac1.KO.cds$back_propagation_proportions_top_detailed[order_normalized, ], 
                        levels = c('Ctrl', 'ALK','ALKa', 'ALK_Hdac1_KO'), 
                        colors = c("turquoise3" , "#136c38", "blue", "red", "pink", "orange")[c(2:4, 6)])
plot(pr.plot_cds.all.results.Hdac1.KO)

#save_plot_as_pdf(pr.plot_cds.all.results.Hdac1.KO, 'pr.plot_cds.all.results.Hdac1.KO.pdf', 8, 5)

```


## 6.4 COMPLETE MODEL: Hdac1 KO

## 6.4.1 Simulation

```{r hierarchy.Hdac1.KO.complete}

hierarchical_clustering_sc_thymus.reduced.flat.Hdac1.KO.complete <- list(
  '1'=list(tree_level=0, leaf_number=1, celltype_list=paste0('cluster_', c(1:7)), 
           next_level_clustering=NULL
  )
)

#Binary hierarchy.
hierarchical_clustering_sc_thymus.reduced.Hdac1.KO.complete <- list(
  '1'=list(tree_level=0, leaf_number=1, parameters=list(param.logfc.threshold = 1.0,
                                                        param.p_val_adj = 0.05,
                                                        minimum_markers = 4,
                                                        min_delta_cor_threshold = 0.3), 
           celltype_list=paste0('cluster_', c(1:7)), 
           next_level_clustering=list(
             '1'=list(tree_level=1, leaf_number=1, celltype_list=paste0('cluster_', c(1)), next_level_clustering=NULL), 
             '2'=list(tree_level=1, leaf_number=2, parameters=list(param.logfc.threshold = 0.2,
                                                                   param.p_val_adj = 0.05,
                                                                   minimum_markers = 40,
                                                                   min_delta_cor_threshold = 0.3),  
                      celltype_list=paste0('cluster_', c(2:5)), next_level_clustering=NULL),
             '3'=list(tree_level=1, leaf_number=3, parameters=list(param.logfc.threshold = 0.6,
                                                                   param.p_val_adj = 0.05,
                                                                   minimum_markers = 8,
                                                                   min_delta_cor_threshold = 0.5),  
                      celltype_list=paste0('cluster_', c(6:7)), next_level_clustering=NULL)
           )
  )
)
```

TODO: fix the problem with top category as only one group
```{r deconvolution.simulation.Hdac1.KO.complete}
#detach(package:DecoFlex,unload=TRUE)
library(DecoFlex)

#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.flat.Hdac1.KO.complete
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.complete <- 
  run_deconvolution_simulation_generic_recursive(single_cell_data_exp = single_cell_data_exp, 
                                                 hierarchy = hierarchy,
                                                 sub_clusters_var = sub_clusters_var,
                                                 sample = sample, 
                                                 use_min_cor_strategy = use_min_cor_strategy, 
                                                 delete_shared_level_markers = delete_shared_level_markers, 
                                                 delete_shared_internal_markers = delete_shared_internal_markers,
                                                 param.logfc.threshold = 1.0,
                                                 param.p_val_adj = 0.05,
                                                 verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

## 6.4.2 Deconvolution with manual hierarchy

Now we will run the deconvolution with the actual bulk dataset from Thymus experiment.
```{r deconvolution.manual.hierarchy.Hdac1.KO.complete}
library(DecoFlex)


order_normalized <- paste0('cluster_', c(1:7))
standard_name_thymus <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse.expanded.tpm@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered[is.na(eset.thymus.bulk.sparse.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered[eset.thymus.bulk.sparse.df.filtered==0] <- 0.0000000001


#Parameters for the simulation
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
hierarchy = hierarchical_clustering_sc_thymus.reduced.Hdac1.KO.complete$`1`
bulk_data = eset.thymus.bulk.sparse.df.filtered[, standard_name_thymus]
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'
use_min_cor_strategy = TRUE
delete_shared_level_markers = FALSE
delete_shared_internal_markers = FALSE

start_time <- Sys.time()

#let's run de simulation
deco.actual.data.thymus.reduced.results.Hdac1.KO.complete <- 
  run_deconvolution_tree_guided_recursive(bulk_data = bulk_data,
                                          single_cell_data_exp = single_cell_data_exp, 
                                          hierarchy = hierarchy,
                                          sub_clusters_var = sub_clusters_var,
                                          sample = sample, 
                                          use_min_cor_strategy = use_min_cor_strategy, 
                                          delete_shared_level_markers = delete_shared_level_markers, 
                                          delete_shared_internal_markers = delete_shared_internal_markers,
                                          param.logfc.threshold = 1.0,
                                          param.p_val_adj = 0.05,
                                          minimum_markers = 20,
                                          min_delta_cor_threshold = 0.5,
                                          verbose = TRUE)

end_time <- Sys.time()
end_time - start_time
```

### 6.4.2.1 Proportions WT simulation

```{r plot_comparison_ctrl_proportion.reduced.Hdac1.KO.complete}

order_normalized <- paste0('cluster_', c(1:7))
order_samples <- c('sample_6W')
list_pseudotime <- cluster_list.thymus.bigstage$bigstage[1:7]

#Plotting the top model
pr.plot_complete_join.wt_vs_ctrl.Hdac1.KO <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.complete$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.Hdac1.KO.complete$back_propagation_proportions_top_detailed[order_normalized, c('Thy_WT_1', 'Thy_WT_2', 'Thy_WT_3')], 
                        levels = c('Ctrl','6w_thymus'), 
                        colors = c("#136c38", "grey"))
plot(pr.plot_complete_join.wt_vs_ctrl.Hdac1.KO)

#save_plot_as_pdf(pr.plot_complete_join.wt_vs_ctrl.Hdac1.KO, 'pr.plot_complete_join.wt_vs_ctrl.Hdac1.KO.pdf', 8, 5)


```

### 6.4.2.2 Plot real proportions

```{r real.proportions.Hdac1.KO.complete}

order_normalized <- paste0('cluster_', c(1:7))
order_samples <- c('sample_6W')
list_pseudotime <- cluster_list.thymus.bigstage$bigstage[1:7]

#Plotting the top model
pr.plot_complete_join.all.results.Hdac1.KO <- plot_proportions_thymus(order_normalized=order_normalized, 
                        order_samples=order_samples, 
                        list_pseudotime=list_pseudotime, 
                        true_proportions=deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.complete$pseudo.bulk.data$truep, 
                        actual_proportions=deco.actual.data.thymus.reduced.results.Hdac1.KO.complete$back_propagation_proportions_top_detailed[order_normalized, ], 
                        levels = c('Ctrl', 'ALK','ALKa', 'ALK_Hdac1_KO'), 
                        colors = c("turquoise3" , "#136c38", "blue", "red", "pink", "orange")[c(2:4, 6)])
plot(pr.plot_complete_join.all.results.Hdac1.KO)


#save_plot_as_pdf(pr.plot_complete_join.all.results.Hdac1.KO, 'pr.plot_complete_join.all.results.Hdac1.KO.pdf', 8, 5)


```



# 7 Partial Deconvolution: Hdac1 KO

## 7.0. Differential expression analysis

Now we need and differencial expression analysis over the bulk data to identify the up and down-regulated genes.
```{r differential.expression.analysis.thymus.Hdac1.KO}

standard_name_thymus.Hdac1.KO <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

countdata.Hdac1.KO <- as.matrix(eset.thymus.bulk.sparse.expanded.counts@assayData$exprs)
countdata.Hdac1.KO <- countdata.Hdac1.KO[,standard_name_thymus.Hdac1.KO]

#I put numbers on it because other wise I wouldn't get  ko vs wt.
type.Hdac1.KO <- c("control","control","control",
          "real_tumor","real_tumor","real_tumor",
          "real_tumor","real_tumor","real_tumor","real_tumor",
          "Hdac1_KO","Hdac1_KO","Hdac1_KO", "Hdac1_KO")

treatment.Hdac1.KO <- c("Thy_WT","Thy_WT","Thy_WT",
                 "Thy_ALKpos_WT","Thy_ALKpos_WT","Thy_ALKpos_WT",
                 "Thy_ALKpos_WT","Thy_ALKpos_WT","Thy_ALKpos_WT","Thy_ALKpos_WT", 
                 "Tumor_ALK_Hdac1_KO","Tumor_ALK_Hdac1_KO","Tumor_ALK_Hdac1_KO","Tumor_ALK_Hdac1_KO"
                 )

#treatment.Hdac1.KO <- as.factor(treatment.Hdac1.KO)

time.Hdac1.KO <- c("18w","18w","18w",
          "18w","18w","18w","18w",
          "18w","18w","18w","18w")

replicates.Hdac1.KO  <- c("1","2","3",
                 "1","2","3",
                 "4","5","6","7",
                 "1","2","3", "4")

batch.Hdac1.KO  <- c("1","1","1",
                 "1","1","1",
                 "2","2","2","2",
                 "2","2","2", "2")

#batch.Hdac1.KO <- as.factor(batch.Hdac1.KO)

#secondary information
sample.Hdac1.KO <- paste0("count_", 1:14)

coldata.Hdac1.KO <- as.data.frame(cbind(replicates.Hdac1.KO, treatment.Hdac1.KO, time.Hdac1.KO, sample.Hdac1.KO, type.Hdac1.KO, batch.Hdac1.KO))
rownames(coldata.Hdac1.KO) <- NULL

#building the object DESeqDataSet
ddsFullCountTable.Hdac1.KO <- DESeqDataSetFromMatrix(
  countData = countdata.Hdac1.KO,
  colData = coldata.Hdac1.KO,
  design = ~batch.Hdac1.KO + treatment.Hdac1.KO)

#giving the order and setting the control sample for the analyisis, which is - in this case - the real Tumor_ALKpos_WT.
ddsFullCountTable.Hdac1.KO$treatment.Hdac1.KO <- factor(ddsFullCountTable.Hdac1.KO$treatment.Hdac1.KO, levels = c("Thy_WT", "Thy_ALKpos_WT", "Tumor_ALK_Hdac1_KO"))

  
dds.Hdac1.KO <- ddsFullCountTable.Hdac1.KO

## Pre-filter
dds.Hdac1.KO <- dds.Hdac1.KO[ rowSums(counts(dds.Hdac1.KO)) > 1, ]

## The rlog and variance stabilizing transformations => homoskedastic data
rld.Hdac1.KO <- rlog(dds.Hdac1.KO, blind = FALSE)
vsd.Hdac1.KO <- vst(dds.Hdac1.KO, blind = FALSE)
dds.Hdac1.KO <- estimateSizeFactors(dds.Hdac1.KO)
normalized.wt.bulk.Hdac1.KO <- counts(dds.Hdac1.KO, normalized=TRUE)

#Checking the new values
assay(vsd.Hdac1.KO)[1:2,]
countdata.Hdac1.KO[1:2,]


dds.Hdac1.KO <- DESeq(dds.Hdac1.KO)
resultsNames(dds.Hdac1.KO)

res.Hdac1.KO <- results(dds.Hdac1.KO)

  
RES.thymus.lfc.Hdac1.KO <- list(Intercept = results(dds.Hdac1.KO, name = "Intercept"),
                       treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT = results(dds.Hdac1.KO, name = "treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT"), 
                       treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT = results(dds.Hdac1.KO, name = "treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT"), 
                       batch.Hdac1.KO_2_vs_1 = results(dds.Hdac1.KO, name = "batch.Hdac1.KO_2_vs_1"))


RES.thymus.lfc.Hdac1.KO
```
```{r batch.removing, fig.width=5, fig.height=5}
#BiocManager::install("limma")
library(limma)
mat.Hdac1.KO <- assay(vsd.Hdac1.KO)
mm.Hdac1.KO <- model.matrix(~treatment.Hdac1.KO, colData(vsd.Hdac1.KO))
mat.Hdac1.KO.remove <- limma::removeBatchEffect(mat.Hdac1.KO, batch=vsd.Hdac1.KO$batch.Hdac1.KO, design=mm.Hdac1.KO)

vsd.Hdac1.KO.remove <- vsd.Hdac1.KO
assay(vsd.Hdac1.KO.remove) <- mat.Hdac1.KO.remove

#Removing batch effect
plot.pca.vsd.Hdac1.KO.batch.effect <- plotPCA(vsd.Hdac1.KO, "treatment.Hdac1.KO") + coord_fixed(ratio = 5)
plot(plot.pca.vsd.Hdac1.KO.batch.effect)
#save_plot_as_pdf(plot.pca.vsd.Hdac1.KO.batch.effect, 'plot.pca.vsd.Hdac1.KO.batch.effect.pdf', 10, 5)
plot.pca.vsd.Hdac1.KO.batch.effect.removed <- plotPCA(vsd.Hdac1.KO.remove, "treatment.Hdac1.KO") + coord_fixed(ratio = 1)
plot(plot.pca.vsd.Hdac1.KO.batch.effect.removed)
#save_plot_as_pdf(plot.pca.vsd.Hdac1.KO.batch.effect.removed, 'plot.pca.vsd.Hdac1.KO.batch.effect.removed.pdf', 10, 5)

#Creation of the dataset without the batch effect
fdata.remove <- rownames(mat.Hdac1.KO.remove)
pdata.remove <- cbind(subjects = colnames(mat.Hdac1.KO.remove))
eset.thymus.bulk.sparse.expanded.no.batch.effect <- getESET(mat.Hdac1.KO.remove, fdata = fdata.remove, pdata = pdata.remove)
colnames(eset.thymus.bulk.sparse.expanded.no.batch.effect@assayData$exprs)

```

```{r original.vs.correction}
par(mfrow=c(1,2))
boxplot(as.data.frame(countdata.Hdac1.KO),main="Original")
boxplot(as.data.frame(mat.Hdac1.KO.remove),main="Batch corrected")
```



Effects of transformations on the variance
```{r}
#BiocManager::install('vsn')
# this gives log2(n + 1)
ntd.Hdac1.KO <- normTransform(dds.Hdac1.KO)
library("vsn")
meanSdPlot(assay(ntd.Hdac1.KO))
meanSdPlot(assay(vsd.Hdac1.KO))
meanSdPlot(assay(rld.Hdac1.KO))

```


### 7.0.1 Log fold change shrinkage for visualization and ranking

http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html

```{r shrinkage.Hdac1.KO}
#BiocManager::install("apeglm")
library(apeglm)

resultsNames(dds.Hdac1.KO)

resLFC.Hdac1.KO <- lfcShrink(dds.Hdac1.KO, coef="treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT", type="apeglm")
resLFC.Hdac1.KO

resOrdered.Hdac1.KO <- res.Hdac1.KO[order(res.Hdac1.KO$pvalue),]
summary(res.Hdac1.KO)

sum(res.Hdac1.KO$padj < 0.1, na.rm=TRUE)

res05.Hdac1.KO <- results(dds.Hdac1.KO, alpha=0.05)
summary(res05.Hdac1.KO)

```

```{r MA_plot.Hdac1.KO}
plotDispEsts(dds.Hdac1.KO)
plotMA(resLFC.Hdac1.KO)
```

```{r}
par(mfrow=c(2,2),mar=c(2,2,1,1))
ylim <- c(-2.5,2.5)
resGA <- results(dds.Hdac1.KO, lfcThreshold=.5, altHypothesis="greaterAbs")
resLA <- results(dds.Hdac1.KO, lfcThreshold=.5, altHypothesis="lessAbs")
resG <- results(dds.Hdac1.KO, lfcThreshold=.5, altHypothesis="greater")
resL <- results(dds.Hdac1.KO, lfcThreshold=.5, altHypothesis="less")
drawLines <- function() abline(h=c(-.5,.5),col="dodgerblue",lwd=2)
plotMA(resGA, ylim=ylim); drawLines()
plotMA(resLA, ylim=ylim); drawLines()
plotMA(resG, ylim=ylim); drawLines()
plotMA(resL, ylim=ylim); drawLines()
```


```{r}
plotCounts(dds.Hdac1.KO, gene=which.min(res.Hdac1.KO$padj), intgroup="treatment.Hdac1.KO")
```

Data quality assessment by sample clustering and visualization

```{r heatmap.counts, fig.width=7, fig.height=30}
library("pheatmap") 
select.Hdac1.KO <- order(rowMeans(counts(dds.Hdac1.KO,normalized=TRUE)),
                decreasing=TRUE)[1:300]
#Check the value that is not normal
rowMeans(counts(dds.Hdac1.KO,normalized=TRUE))[3] #H19

df.Hdac1.KO <- as.data.frame(colData(dds.Hdac1.KO)[,c("treatment.Hdac1.KO","batch.Hdac1.KO")])
pheatmap(assay(ntd.Hdac1.KO)[select.Hdac1.KO,], cluster_rows=FALSE, 
         fontsize_row=7, show_rownames=TRUE,
         cluster_cols=FALSE, annotation_col=df.Hdac1.KO)

pheatmap(assay(vsd.Hdac1.KO)[select.Hdac1.KO,], cluster_rows=FALSE,
         show_rownames=TRUE, fontsize_row=7, 
         cluster_cols=FALSE, annotation_col=df.Hdac1.KO)

pheatmap(assay(rld.Hdac1.KO)[select.Hdac1.KO,], cluster_rows=FALSE, 
         show_rownames=TRUE, fontsize_row=7, 
         cluster_cols=FALSE, annotation_col=df.Hdac1.KO)

```
Heatmap of the sample-to-sample distances
```{r}
sampleDists.Hdac1.KO <- dist(t(assay(vsd.Hdac1.KO)))

library("RColorBrewer")
sampleDistMatrix.Hdac1.KO <- as.matrix(sampleDists.Hdac1.KO)
rownames(sampleDistMatrix.Hdac1.KO) <- paste(vsd.Hdac1.KO$treatment.Hdac1.KO, vsd.Hdac1.KO$batch.Hdac1.KO, sep="-")
colnames(sampleDistMatrix.Hdac1.KO) <- NULL
colors.Hdac1.KO <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap.samples.batch.effect <- pheatmap(sampleDistMatrix.Hdac1.KO,
         clustering_distance_rows=sampleDists.Hdac1.KO,
         clustering_distance_cols=sampleDists.Hdac1.KO,
         col=colors.Hdac1.KO)
plot(pheatmap.samples.batch.effect)

save_plot_as_pdf(pheatmap.samples.batch.effect, 'pheatmap.samples.batch.effect.pdf', 8, 5)

```


```{r pca, fig.width=5, fig.height=5}
plotPCA(vsd.Hdac1.KO, intgroup=c("treatment.Hdac1.KO","batch.Hdac1.KO")) + coord_fixed(ratio = 5)

plotPCA(vsd.Hdac1.KO, intgroup=c("treatment.Hdac1.KO")) + coord_fixed(ratio = 5)


pcaData.Hdac1.KO <- plotPCA(vsd.Hdac1.KO, intgroup=c("treatment.Hdac1.KO","batch.Hdac1.KO"), returnData=TRUE)
percentVar.Hdac1.KO <- round(100 * attr(pcaData.Hdac1.KO, "percentVar"))
ggplot(pcaData.Hdac1.KO, aes(PC1, PC2, color=treatment.Hdac1.KO, shape=batch.Hdac1.KO)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar.Hdac1.KO[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar.Hdac1.KO[2],"% variance")) + 
  coord_fixed() +
  coord_fixed(ratio = 5)

plotDispEsts(dds.Hdac1.KO)

```



Let's have the volcano plots for each pair of conditions with different cuts. I will use the percentile 99.9% of the log2FoldChange value
https://www.bioconductor.org/packages/devel/bioc/vignettes/EnhancedVolcano/inst/doc/EnhancedVolcano.html
```{r volcano_plot.Hdac1.KO, fig.width=10, fig.height=9}
#BiocManager::install('EnhancedVolcano')
library(EnhancedVolcano)


treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT_res <- results(dds.Hdac1.KO, name = "treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT")
quantile(abs(as.data.frame(treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT_res)$log2FoldChange), c(.25, .50, .75, .90, .95, .993, .995), na.rm = TRUE) 
volcano_plot.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT <- EnhancedVolcano(treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT_res,
  lab = rownames(treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT_res),
  FCcutoff = 7.4524692,
  title = 'treatment_Thy_KO_vs_Thy_WT',
  x = 'log2FoldChange',
  y = 'pvalue')
print(volcano_plot.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT)

#save_plot_as_pdf(volcano_plot.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT, 'volcano_plot.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT.pdf', 8, 6)

treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT_res <- results(dds.Hdac1.KO, name = "treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT")
quantile(as.data.frame(treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT_res)$log2FoldChange, c(.25, .50, .75, .90, .95, .995), na.rm = TRUE) 
volcano_plot.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT <- EnhancedVolcano(treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT_res,
  lab = rownames(treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT_res),
  FCcutoff = 6.3596272,
  title = 'treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT',
  x = 'log2FoldChange',
  y = 'pvalue')
print(volcano_plot.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT)

#save_plot_as_pdf(volcano_plot.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT, 'volcano_plot.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT.pdf', 8, 6)

batch.Hdac1.KO_2_vs_1_res <- results(dds.Hdac1.KO, name = "batch.Hdac1.KO_2_vs_1")
quantile(as.data.frame(batch.Hdac1.KO_2_vs_1_res)$log2FoldChange, c(.25, .50, .75, .90, .95, .995), na.rm = TRUE) 
volcano_plot.Hdac1.KO_batch.Hdac1.KO_2_vs_1 <- EnhancedVolcano(batch.Hdac1.KO_2_vs_1_res,
  lab = rownames(batch.Hdac1.KO_2_vs_1_res),
  FCcutoff = 14.8081557,
  title = 'batch.Hdac1.KO_2_vs_1_res',
  x = 'log2FoldChange',
  y = 'pvalue')
print(volcano_plot.Hdac1.KO_batch.Hdac1.KO_2_vs_1)

#save_plot_as_pdf(batch.Hdac1.KO_2_vs_1_res, 'batch.Hdac1.KO_2_vs_1_res.pdf', 8, 6)



```

```{r selection.genes}

#now lets check the genes that I should include
select_markers_de <- function(de_object, log2FoldChange = 7.5){
  rownames(de_object[which(abs(de_object$log2FoldChange) >= log2FoldChange & de_object$padj <= 0.05),])
}

#shared between tumor and ko: 39
inter.tumor.ko <- intersect(select_markers_de(RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT, 7.4524692),
                     select_markers_de(RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT, 6.3596272))
length(inter.tumor.ko)

#Diff between tumor and ko: 47
diff.tumor.ko.a <- setdiff(select_markers_de(RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT, 7.4524692),
                     select_markers_de(RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT, 6.3596272))
length(diff.tumor.ko.a)

#85
diff.tumor.ko.b <- setdiff(select_markers_de(RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT, 7.4524692),
                           select_markers_de(RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT, 6.3596272))
length(diff.tumor.ko.b)


# All ->Based on the volcano plots: 261
de_genes.thymus.Hdac1.KO <- c(select_markers_de(RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT, 7.4524692),
                     select_markers_de(RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT, 6.3596272))
de_genes.thymus.Hdac1.KO <- unique(de_genes.thymus.Hdac1.KO)
length(de_genes.thymus.Hdac1.KO) # 215

#Based on the volcano plots: 86
de_genes.thymus.Hdac1.KO.treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT <- c(select_markers_de(RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT, 7.4524692)) #6
paste(shQuote(de_genes.thymus.Hdac1.KO.treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT, type="sh"), collapse=", ")
length(de_genes.thymus.Hdac1.KO.treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT)

##Based on the volcano plots: 214
de_genes.thymus.Hdac1.treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT <- c(select_markers_de(RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT, 6.3596272))#8
paste(shQuote(de_genes.thymus.Hdac1.treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT, type="sh"), collapse=", ")
length(de_genes.thymus.Hdac1.treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT)


#261 We hope that this will be enough to describe the missing celltype.
de_genes.thymus.Hdac1.KO <- unique(de_genes.thymus.Hdac1.KO)
length(de_genes.thymus.Hdac1.KO)
paste(shQuote(de_genes.thymus.Hdac1.KO, type="sh"), collapse=", ")

```


## 7.1 Partial Deconvolution: TOP Hdac1 KO

Let's put together the marker genes from the flat deconvolution and the differential expressed genes. 
```{r final.list.genes.Hdac1.KO}
black_list_genes.Hdac1.KO <- c()
#1. Lets try with the ko vs wt
de_genes.thymus.total.Hdac1.KO <- de_genes.thymus.Hdac1.treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT
#de_genes.thymus.total.Hdac1.KO <- de_genes.thymus.total.Hdac1.KO[de_genes.thymus.total.Hdac1.KO %in% black_list_genes.Hdac1.KO == FALSE]

eset.thymus.bulk.sparse.expanded.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse.expanded.tpm@assayData$exprs))
eset.thymus.bulk.sparse.expanded.df.filtered[is.na(eset.thymus.bulk.sparse.expanded.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.expanded.df.filtered[eset.thymus.bulk.sparse.expanded.df.filtered==0] <- 0.0000000001


#Let's create the w reference with all the genes and then we could see which are shared with the final_markers_partial_model
# I don't use the one in the model becasue only has the marker genes in the reference and I need those  plus the Differential
# expressed ons
single_cell_data_exp.Hdac1.KO <- eset.sc.thymus.6.8.w.sparse.metacluster
top_clusters_list.Hdac1.KO = paste0('cluster_', c(1:3))
bulk_data.Hdac1.KO = eset.thymus.bulk.sparse.expanded.df.filtered
sub_clusters_var.Hdac1.KO <- 'metacluster'
sample.Hdac1.KO <- 'age'


w_matrix_reference.Hdac1.KO <- decoflex_build_cell_reference(
  x = single_cell_data_exp.Hdac1.KO,
  ct.sub = top_clusters_list.Hdac1.KO,
  ct.varname = sub_clusters_var.Hdac1.KO,
  sample = sample.Hdac1.KO,
  verbose = TRUE)

# sorting the results by columns
w_matrix_reference.basics.Hdac1.KO <- w_matrix_reference.Hdac1.KO$basis[, paste0('cluster_', c(1:3))]

#zero intersection between top markers and differentially expressed genes.
length(de_genes.thymus.Hdac1.KO) #261
length(rownames(deco.actual.data.thymus.reduced.results.Hdac1.KO.complete$result_deco_top_cluster$w)) # 14
intersect(de_genes.thymus.Hdac1.KO, rownames(deco.actual.data.thymus.reduced.results.Hdac1.KO.complete$result_deco_top_cluster$w))#1"Ms4a4b"

#275 = de and top marker genes from the w matrix
final_markers_partial_model.Hdac1.KO <- c(de_genes.thymus.Hdac1.KO, rownames(deco.actual.data.thymus.reduced.results.Hdac1.KO.complete$result_deco_top_cluster$w))
length(final_markers_partial_model.Hdac1.KO)

#274 no duplication
final_markers_partial_model.Hdac1.KO <- unique(final_markers_partial_model.Hdac1.KO)
length(final_markers_partial_model.Hdac1.KO)

#0. 
diff.1.Hdac1.KO <- setdiff(de_genes.thymus.Hdac1.KO, final_markers_partial_model.Hdac1.KO)
length(diff.1.Hdac1.KO)

#13 markers corresponding to the top marker genes.
diff.2.Hdac1.KO <- setdiff(final_markers_partial_model.Hdac1.KO, de_genes.thymus.Hdac1.KO)
length(diff.2.Hdac1.KO)

#185 Only 75 genes are shared with the w matrix, makeing the rest: 154 with zero values as refernce
shared.final.vs.w.Hdac1.KO <- intersect(final_markers_partial_model.Hdac1.KO, rownames(as.matrix(w_matrix_reference.basics.Hdac1.KO)))
length(shared.final.vs.w.Hdac1.KO)

#89: This are additional factors in the W matrix semireference.
extra_marker_genes_semireference.Hdac1.KO <- setdiff(de_genes.thymus.Hdac1.KO, shared.final.vs.w.Hdac1.KO)
length(extra_marker_genes_semireference.Hdac1.KO)

#185
final_markers_partial_model.Hdac1.KO <- shared.final.vs.w.Hdac1.KO
length(final_markers_partial_model.Hdac1.KO)

#no intersection, therefore everything is fine.
intersect(extra_marker_genes_semireference.Hdac1.KO, final_markers_partial_mode.Hdac1.KO)

```

### 5.1.2. Creation of partial references: W and H

Now we can create the partial references with TWO OR MORE fixed cell-type
```{r creation.mask.matrices.h.w.one.celltype.Hdac1.KO}

extra_unknown_celltypes.Hdac1.KO <- 2

# I have n genes as rows and m+1 columns, being the last one the unknown one. 
mask_h.Hdac1.KO <- matrix(FALSE, nrow = (3+extra_unknown_celltypes.Hdac1.KO), ncol = 14)
colnames(mask_h.Hdac1.KO) <- standard_name_thymus.Hdac1.KO
rownames(mask_h.Hdac1.KO) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes.Hdac1.KO)))

# In this case, I can do two things: 1. Fix just the celltypes that I have as reference and the unknown leave it as black. 2. Assign the unknown cell-type as zero, since it suppose to be a WT, and then in the other conditions it will appear a proportion. Also the Tumor DNMT1 KO, will be similar to WT.
version <- 'two'
if(version=='one'){
  #Version 1.
  mask_h.Hdac1.KO[1:3,1:3] <- TRUE
}else if(version=='two'){
  #Version 1.
  mask_h.Hdac1.KO[1:(3+extra_unknown_celltypes.Hdac1.KO),1:3] <- TRUE
}




#Now let's put the proportions that I needed, filling with zeros the rest
partial_h_fixed.Hdac1.KO <- matrix(0, nrow = (3+extra_unknown_celltypes.Hdac1.KO), ncol = 14)
colnames(partial_h_fixed.Hdac1.KO) <- standard_name_thymus.Hdac1.KO
rownames(partial_h_fixed.Hdac1.KO) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes.Hdac1.KO)))
#let's take the proportion
proportions_wt_single_cell.Hdac1.KO <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.top$pseudo.bulk.data$truep) 
colnames(proportions_wt_single_cell.Hdac1.KO) <- c('sample_6_8W')
proportions_wt_single_cell.Hdac1.KO <- t(proportions_wt_single_cell.Hdac1.KO)
proportions_wt_single_cell.Hdac1.KO['sample_6_8W', paste0('cluster_', c(1:3)) ]

#Since I have three replicates I have to fix the proportions three times
partial_h_fixed.Hdac1.KO[1:3,1] <- as.matrix(proportions_wt_single_cell.Hdac1.KO['sample_6_8W', paste0('cluster_', c(1:3)) ])
partial_h_fixed.Hdac1.KO[1:3,2] <- as.matrix(proportions_wt_single_cell.Hdac1.KO['sample_6_8W', paste0('cluster_', c(1:3)) ])
partial_h_fixed.Hdac1.KO[1:3,3] <- as.matrix(proportions_wt_single_cell.Hdac1.KO['sample_6_8W', paste0('cluster_', c(1:3)) ])





#Now I will create the W
mask_w.Hdac1.KO <- matrix(TRUE, 
                 nrow = (length(final_markers_partial_model.Hdac1.KO) + length(extra_marker_genes_semireference.Hdac1.KO)), 
                 ncol = (3+extra_unknown_celltypes.Hdac1.KO))
colnames(mask_w.Hdac1.KO) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes.Hdac1.KO)))
rownames(mask_w.Hdac1.KO) <- c(final_markers_partial_model.Hdac1.KO, extra_marker_genes_semireference.Hdac1.KO)
mask_w.Hdac1.KO[1:length(final_markers_partial_model.Hdac1.KO), (3+1):(3+extra_unknown_celltypes.Hdac1.KO)] <- FALSE
mask_w.Hdac1.KO[(length(final_markers_partial_model.Hdac1.KO)+1):nrow(mask_w.Hdac1.KO), 1:(3+extra_unknown_celltypes.Hdac1.KO)] <- FALSE

# I have k cell-types rows by m samples. I want to add the same proportions to the first three wild-type samples corresponding to the 
# '6_8W' time points
partial_w_fixed.Hdac1.KO <- matrix(0, 
                          nrow = (length(final_markers_partial_model.Hdac1.KO) + length(extra_marker_genes_semireference.Hdac1.KO)), 
                          ncol = (3+extra_unknown_celltypes.Hdac1.KO))
colnames(partial_w_fixed.Hdac1.KO) <- paste0('cluster_', c(1:3, paste0('unknown_', 1:extra_unknown_celltypes.Hdac1.KO)))
rownames(partial_w_fixed.Hdac1.KO) <-  c(final_markers_partial_model.Hdac1.KO, extra_marker_genes_semireference.Hdac1.KO)

#Let's filter the w matrix reference (partially)
w_matrix_reference_basis_fixed.Hdac1.KO <- as.data.frame(w_matrix_reference.Hdac1.KO$basis)
w_matrix_reference_basis_fixed.Hdac1.KO <- w_matrix_reference_basis_fixed.Hdac1.KO[final_markers_partial_model.Hdac1.KO, ]

partial_w_fixed.Hdac1.KO[1:length(final_markers_partial_model.Hdac1.KO), 1:3] <- as.matrix(w_matrix_reference_basis_fixed.Hdac1.KO)

```



### 5.1.3. Running deconvolution with partial reference model


Finally we can put together the model and run the partial conditioned deconvolution model to see if that work
```{r flat.deconvolution.partial.references}

order_normalized.Hdac1.KO.top <- paste0('cluster_', c(1:3))


#Only WT and tumor
standard_name_thymus.Hdac1.KO <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3",
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7")

standard_name_thymus.Hdac1.KO <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.expanded.df.filtered <- data.frame(as.matrix(eset.thymus.bulk.sparse.expanded.tpm@assayData$exprs))
eset.thymus.bulk.sparse.expanded.df.filtered[is.na(eset.thymus.bulk.sparse.expanded.df.filtered)] <- 0.0000000001
eset.thymus.bulk.sparse.expanded.df.filtered[eset.thymus.bulk.sparse.expanded.df.filtered==0] <- 0.0000000001

proportion_constraint_h.Hdac1.KO = TRUE

start_time <- Sys.time()

# I run the deconvolution without any other parameter
deco.alpha.beta.zero.results.partial.Hdac1.KO.top <- run_complete_deconvolution(
  x_matrix = data.frame(eset.thymus.bulk.sparse.expanded.df.filtered[unique(c(final_markers_partial_model.Hdac1.KO, extra_marker_genes_semireference.Hdac1.KO)), standard_name_thymus.Hdac1.KO]),
  y_matrix = NULL,
  z_matrix = NULL,
  k = (3+extra_unknown_celltypes.Hdac1.KO),
  alpha = 0, 
  beta = 0,
  delta_threshold=1e-10, 
  max_iterations=10000, 
  #I have to deactivate the sum 1 because that is just for the 3 cell types
  proportion_constraint_h = proportion_constraint_h.Hdac1.KO,
  partial_w_fixed=data.frame(partial_w_fixed.Hdac1.KO[unique(c(final_markers_partial_model.Hdac1.KO, extra_marker_genes_semireference.Hdac1.KO)), ]),
  partial_h_fixed=data.frame(partial_h_fixed.Hdac1.KO[, standard_name_thymus.Hdac1.KO]),
  w_mask_fixed=data.frame(mask_w.Hdac1.KO[,]),
  h_mask_fixed=data.frame(mask_h.Hdac1.KO[, standard_name_thymus.Hdac1.KO]),
  batches_partial_fixed=1)

end_time <- Sys.time()
end_time - start_time
```


Analysis of proportions
```{r proportions.assignment.Hdac1.KO}
colSums(deco.alpha.beta.zero.results.partial.Hdac1.KO.top$h[1:3,])

prop_recal.Hdac1.KO.top <- deco.alpha.beta.zero.results.partial.Hdac1.KO.top$h

sum(prop_recal.Hdac1.KO.top[1:3,1:3])

if(proportion_constraint_h.Hdac1.KO.top){
  
}else{
  prop_recal.Hdac1.KO.top[1:3, ] <- prop_recal.Hdac1.KO.top[1:3, ]/colSums(prop_recal.Hdac1.KO.top[1:3, ])
}

prop_recal.recal.Hdac1.KO.top <- sweep(prop_recal.Hdac1.KO.top,2,colSums(prop_recal.Hdac1.KO.top),FUN="/")
colSums(prop_recal.recal.Hdac1.KO.top)
prop_recal.Hdac1.KO.top <- prop_recal.recal.Hdac1.KO.top

prop_recal.Hdac1.KO.top
colSums(prop_recal.Hdac1.KO.top)
```


### 5.1.4. Plot with semireference model proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion.flat.model.Hdac1.KO}

plot_proportions_semireference_hdac1_ko <- function(real_proportion.parameter, prop_recal, order_normalized, list_pseudotime, extra_unknown_celltypes=1){

order_samples <- c('sample_6_8W')

#Calculate the proportion for clusters for 3 clusters
real_proportion <- real_proportion.parameter
real_proportion <- t(real_proportion)
rownames(real_proportion) <- c('sample_6_8W')

#Initialization of extra clusters unknown
for(extra in 1:extra_unknown_celltypes){
  names_temp <- c(colnames(real_proportion), paste0('cluster_unknown_', extra))
  real_proportion <- cbind(real_proportion, 0)
  colnames(real_proportion) <- names_temp
}

real_proportion.pseudotime <- real_proportion[order_samples, order_normalized]
real_proportion.pseudotime.rescaled <- real_proportion.pseudotime

#just checking. Everything should sum up 1.
sum(real_proportion.pseudotime.rescaled)
#Adding names
names(real_proportion.pseudotime.rescaled) <- list_pseudotime
real_proportion.pseudotime.rescaled <- data.frame(real_proportion.pseudotime.rescaled)
real_proportion.pseudotime.rescaled <- t(real_proportion.pseudotime.rescaled)
rownames(real_proportion.pseudotime.rescaled) <-  c('sample_6_8W')

# All experiments
experimental_data <- t(prop_recal[order_normalized, ])
experimental_data <- data.frame(experimental_data)
colnames(experimental_data) <- list_pseudotime


#Joining the bulk data wt
comparison_real_vs_deconvolution <- rbind(experimental_data, real_proportion.pseudotime.rescaled)


thymus.proportions.summarized <- as.data.frame(t(comparison_real_vs_deconvolution[]))

thymus.proportions.summarized <- cbind(thymus.proportions.summarized, cluster_name = rownames(thymus.proportions.summarized))


thymus.proportions.summarized.melt <- melt(thymus.proportions.summarized, id.vars='cluster_name')
thymus.proportions.summarized.melt <- cbind(thymus.proportions.summarized.melt, type = '', type_normalized = '', stringsAsFactors=FALSE)

thymus.proportions.summarized.melt$cluster_name <- factor(thymus.proportions.summarized.melt$cluster_name, levels = list_pseudotime)

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 6) == 'Thy_WT'] <- 'Ctrl')

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 15) == 'Tumor_ALKpos_WT'] <- 'ALK')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 16) == 'Tumor_ALKpos_WTa'] <- 'ALKa')

thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 18) == 'Tumor_ALK_Hdac1_KO'] <- 'ALK_Hdac1_KO')
thymus.proportions.summarized.melt <- within(thymus.proportions.summarized.melt, type_normalized[str_sub(variable, 1, 13) == 'sample_6_8W'] <- '6_8w_thymus')

thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl', 'ALK','ALKa', 'ALK_Hdac1_KO', '6_8w_thymus'))

#thymus.proportions.summarized.melt$type_normalized <- factor(thymus.proportions.summarized.melt$type_normalized, levels= c('Ctrl'))

#real proportion vs control
thymus.proportions.deconvolution.summarized.melt <- rbind(thymus.proportions.summarized.melt)

# assign values to zero
#thymus.proportions.deconvolution.summarized.melt$value[thymus.proportions.deconvolution.summarized.melt$value < 0.01] = 0.01

p <- ggplot(thymus.proportions.deconvolution.summarized.melt[thymus.proportions.deconvolution.summarized.melt$type_normalized %in% c('Ctrl', 'ALK', 'ALKa', 'ALK_Hdac1_KO', '6_8w_thymus') & thymus.proportions.deconvolution.summarized.melt$cluster_name %in% list_pseudotime,], aes(x=cluster_name, y=value, color=type_normalized)) +
  geom_point(size=4, shape=20, alpha = .30, position=position_jitter(width=.3,height=.00)) +
  labs(title=NULL,x="Cell Type", y = "Proportion") + theme_linedraw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text=element_text(size=16),
        legend.title = element_text(size = 16),
          legend.text = element_text(size = 16)) + 
  ylim(-0.1, 1.0)
 
p <- p +  scale_color_manual(name = "Sample", breaks = c('6_8w_thymus', 'Ctrl', 'ALK','ALKa', 'ALK_Hdac1_KO'), values = c("darkgrey", "#136c38", "blue", "red", "orange")) + theme_light()

p  
}

plot.Hdac1.KO.top <- plot_proportions_semireference_hdac1_ko(real_proportion.parameter =  as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.top$pseudo.bulk.data$truep), 
                                        prop_recal=prop_recal.Hdac1.KO.top, 
                                        order_normalized = paste0('cluster_', c('1','2','3', paste0('unknown_', 1:extra_unknown_celltypes.Hdac1.KO))), 
                                        list_pseudotime = c('DN', 'DP','CDs', paste0('unknown_', 1:extra_unknown_celltypes.Hdac1.KO)), 
                                        extra_unknown_celltypes =extra_unknown_celltypes.Hdac1.KO)

plot(plot.Hdac1.KO.cds)

#save_plot_as_pdf(plot.Hdac1.KO.top, 'plot_proportions_top_semireference_de_Thy_ALKpos_KO_vs_Thy_WT.Hdac1_KO.pdf', 8, 5)

```


```{r function.plot.Hdac1.KO}


#Function to plot the heatmaps with the level marker genes.
plot_heatmap_markers_multiple_level.Hdac1.KO <- function(
  sc.eset.metacluster.all, 
  sc.bulk.data.filtered.tpm, 
  pseudo.bulk.df.filtered.tpm,
  res.object.de, 
  top.markers.detailed_all, 
  list_cell_types,
  row_km_value = 1, 
  color_left_groups = NULL, 
  clustering_variable = 'cluster_normalized_bigstage', 
  column.clusters = NULL, scale_activated=TRUE, 
  show_legends = TRUE){
  
  ############# IMPORTING DATASETS
  
  #1.1. pseduo bulk data:p2 and p11. I have to use the filter for the marker genes unique. I use tpm
  sc.bulk.data.p2.p11 <- data.frame(pseudo.bulk.df.filtered.tpm)
  
  #1.2. bulk data
  sc.bulk.data.wt.ko <- data.frame(sc.bulk.data.filtered.tpm[, ])
  
  #1.3. DE data
  bulk.data.wt.ko.de <- data.frame(res.object.de)
  #Filtering the values with zero and NA in the differential Expression analysis.
  bulk.data.wt.ko.de <- na.omit(bulk.data.wt.ko.de)
  
  #2.1. Now we have to intersect everything, even with the total marker genes.
  pseudo.sc.bulk.vs.ko.wt.bulk <- intersect(rownames(sc.bulk.data.p2.p11), rownames(sc.bulk.data.wt.ko))
  
  #2.2. Intersection with de dataset
  bulks.vs.de.data <- intersect(pseudo.sc.bulk.vs.ko.wt.bulk, rownames(bulk.data.wt.ko.de))
  
  #2.3. FINAL INTERSECTION: with marker genes: markers
  bulks.de.vs.markers <- intersect(bulks.vs.de.data, top.markers.detailed_all$gene_name)
  
  print( (paste(top.markers.detailed_all$gene_name, collapse=', ' )))
  
  #2.4. Now I'm going to filter the main dataset with markers with the intersected markers found. I double checked the order of both datasets: they supposed to keep the order
  (paste(top.markers.detailed_all$gene_name, collapse=', ' ))
  top.markers.detailed_all <- top.markers.detailed_all[top.markers.detailed_all$gene_name %in% bulks.de.vs.markers, ]
  (paste(top.markers.detailed_all$gene_name, collapse=', ' ))
  
  ########### STEPS TO PLOT THE HEATMAP BY CELLTYPE WITH CORRESPONDING MARKER GENES.
  

  #################DATA
  #################SINGLE CELL PSEUDO BULK DATA
  #I have to use the filter for the marker genes unique. I use tpm
  
  #ordering with duplicates
  sc.bulk.data.p2.p11.temp <- sc.bulk.data.p2.p11[top.markers.detailed_all$gene_name,]
  sc.bulk.data.p2.p11.temp <- as.data.frame(sc.bulk.data.p2.p11.temp)
  colnames(sc.bulk.data.p2.p11.temp) <- colnames(sc.bulk.data.p2.p11)
  rownames(sc.bulk.data.p2.p11.temp) <- top.markers.detailed_all$gene_name
  sc.bulk.data.p2.p11 <- sc.bulk.data.p2.p11.temp
  
  #log1p
  sc.bulk.data.p2.p11.scaled <- log1p(sc.bulk.data.p2.p11)
  sc.bulk.data.p2.p11.scaled$gene_name <- rownames(sc.bulk.data.p2.p11)
  
  
  #DNMT1 BULK DATA
  
  #ordering with duplicates
  sc.bulk.data.wt.ko <- sc.bulk.data.wt.ko[match(top.markers.detailed_all$gene_name, rownames(sc.bulk.data.wt.ko)), ] 
  sc.bulk.data.wt.ko.scaled <- log1p(sc.bulk.data.wt.ko)
  sc.bulk.data.wt.ko.scaled$gene_name <- rownames(sc.bulk.data.wt.ko)
  
  
  sc.bulk.data <- cbind(sc.bulk.data.p2.p11, sc.bulk.data.wt.ko)
  sc.bulk.data.scaled <- cbind(sc.bulk.data.p2.p11.scaled, sc.bulk.data.wt.ko.scaled)

  #I could use the function scale but lets try with the original tpm
  sc.bulk.data <- data.frame(sc.bulk.data)
  sc.bulk.data.scaled <- data.frame(sc.bulk.data.scaled)
  rownames(sc.bulk.data) <- (top.markers.detailed_all$gene_name)
  rownames(sc.bulk.data.scaled) <- (top.markers.detailed_all$gene_name)
  
  
  #adding differential analysis result
  bulk.data.wt.ko.de$gene_name <- rownames(bulk.data.wt.ko.de)
  bulk.data.wt.ko.de.filtered <- bulk.data.wt.ko.de[rownames(bulk.data.wt.ko.de) %in% top.markers.detailed_all$gene_name,]
  
  
  #######SINGLE CELL CONFIGURATION
  
  #1. Filter cells for just three cell-types: 
  cells.collection.complete <- sc.eset.metacluster.all[,sc.eset.metacluster.all[[clustering_variable]] %in% paste0('cluster_', list_cell_types)]
  
  cells.collection.matrix <- as.matrix(cells.collection.complete@assayData$exprs)
  rownames(cells.collection.matrix) <- rownames(cells.collection.complete)
  cells.collection.matrix <- data.frame(cells.collection.matrix)
  

  ##########NORMAL CONFIGURATION
  
  level_list <- unique(top.markers.detailed_all$group)
  sc.data.duplicated.all <- NULL
  for(counter_level in 1:length(level_list)){
    #let's filter with the markers
    cells.collection.matrix.filtered <- filter(cells.collection.matrix, rownames(cells.collection.matrix) %in% top.markers.detailed_all[top.markers.detailed_all$group == level_list[counter_level],]$gene_name)
    print(paste0(counter_level, '=', nrow(cells.collection.matrix.filtered)))
    print(top.markers.detailed_all[top.markers.detailed_all$group == level_list[counter_level],]$gene_name)
    
    sc.data.duplicated.all <- rbind(sc.data.duplicated.all,
                                    as.matrix(cells.collection.matrix.filtered))
  }
  
  #I added the genes that are missing
  missing.genes.sc <- setdiff(top.markers.detailed_all$gene_name, rownames(sc.data.duplicated.all))
  
  #then I will add genes fields with empty NA values to single cell
  diff.dataset.sc <- matrix(0, nrow = length(missing.genes.sc), ncol = ncol(sc.data.duplicated.all))
  rownames(diff.dataset.sc) <- missing.genes.sc
  colnames(diff.dataset.sc) <- colnames(sc.data.duplicated.all)
  
  #Add the empty part with genes to the normal pseudo
  sc.data.duplicated.all <- rbind(sc.data.duplicated.all, diff.dataset.sc)
  
  
  ############# COLUMNS
  
  if(!is.null(column.clusters)){
    
    library(RColorBrewer)
    n <- length(column.clusters)
    qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
    col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

    colors_list_parametric <- sample(col_vector, n)
    colour.columns.list <- c(colors_list_parametric)
    names(colour.columns.list) <- column.clusters
    
    # Define color for the cell type variable
    colour.columns <- list(cell_type = colour.columns.list)
    
    #Define the columns and levels for the celltypes
    column.values <- data.frame(column.names = cells.collection.complete[[clustering_variable]])
    column.values$column.names <- factor(x = column.values$column.names, levels = column.clusters)
    
  }else{
    # Define colors for each levels of qualitative variables
    color.clusters.1.to.7 <- c("#F8766D", "#C49A00", "#53B400", "#00C094", "#00B6EB", "#A58AFF", "#FB61D7")
    # Define color for the cell type variable
    colour.columns <- list(cell_type = c("cluster_1" = color.clusters.1.to.7[1], 
                                         "cluster_2" = color.clusters.1.to.7[2], 
                                         "cluster_3" = color.clusters.1.to.7[3], 
                                         "cluster_4" = color.clusters.1.to.7[4], 
                                         "cluster_5" = color.clusters.1.to.7[5], 
                                         "cluster_6" = color.clusters.1.to.7[6],
                                         "cluster_7" = color.clusters.1.to.7[7]))
    
    column.values <- data.frame(column.names = cells.collection.complete[[clustering_variable]])
    column.values$column.names <- factor(x = column.values$column.names, levels = paste0('cluster_', c(1:7)))
  }
  
  library(ComplexHeatmap)
  
  # Create the heatmap annotation columns
  ha.columns <- HeatmapAnnotation(
    cell_type = column.values$column.names,
    col = colour.columns
  )
  
  
  ################# ROWS
  
  
  ################# ROWS
  
  # Define gradient color for each level
  colour.rows.left_list <- NULL
  for(couter_level in 1:length(level_list)){
    
    #To get the color coding of the left annotation right.
    if(is.null(color_left_groups)){
      colour.rows.left_list <- c(colour.rows.left_list, color.clusters.1.to.7[couter_level])
    }else{
      colour.rows.left_list <- c(colour.rows.left_list, color_left_groups[couter_level])
    }

  }
  names(colour.rows.left_list) <- level_list
  
  colour.rows.left <- list(marker_type = colour.rows.left_list)
  top.markers.detailed_all$group <- factor(x = top.markers.detailed_all$group, levels = unique(top.markers.detailed_all$group))
  
  # Create the heatmap annotation rows
  ha.rows.left <- rowAnnotation(
    marker_type = top.markers.detailed_all$group,
    col = colour.rows.left
  )
  
  
  
  ########### ROW RIGHT
  
  
  #new approach of color coding
  #########################
  
  sc.bulk.cols.6.colors <-function(n) {
    colorRampPalette(rev(c("red4","red2","tomato2","orange","gold1","forestgreen")))(6)                                
  }
  
  min_value.sc <- min(sc.bulk.data.scaled$sample_6W, na.rm = TRUE)
  max_value.sc <- max(sc.bulk.data.scaled$sample_6W, na.rm = TRUE)
  
  min_value.bulk <- min(sc.bulk.data.scaled$Thy_WT_1, sc.bulk.data.scaled$Thy_WT_2, sc.bulk.data.scaled$Thy_WT_3,
                        sc.bulk.data.scaled$Tumor_ALKpos_WT_1, sc.bulk.data.scaled$Tumor_ALKpos_WT_2, sc.bulk.data.scaled$Tumor_ALKpos_WT_3,
                        sc.bulk.data.scaled$Tumor_ALKpos_WTa_4, sc.bulk.data.scaled$Tumor_ALKpos_WTa_5,
                        sc.bulk.data.scaled$Tumor_ALKpos_WTa_6,sc.bulk.data.scaled$Tumor_ALKpos_WTa_7,
                        sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_1, sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_2, sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_3, sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_4)
  
  max_value.bulk <- max(sc.bulk.data.scaled$Thy_WT_1, sc.bulk.data.scaled$Thy_WT_2, sc.bulk.data.scaled$Thy_WT_3,
                        sc.bulk.data.scaled$Tumor_ALKpos_WT_1, sc.bulk.data.scaled$Tumor_ALKpos_WT_2, sc.bulk.data.scaled$Tumor_ALKpos_WT_3,
                        sc.bulk.data.scaled$Tumor_ALKpos_WTa_4, sc.bulk.data.scaled$Tumor_ALKpos_WTa_5,
                        sc.bulk.data.scaled$Tumor_ALKpos_WTa_6,sc.bulk.data.scaled$Tumor_ALKpos_WTa_7,
                        sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_1, sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_2, sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_3, sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_4)
  
  calculate_range <- function(min, max, number){
  step <- (max-min)/(number-1)
  
  result <- c(min)
  for (counter in 1:(number)) {
    result <- c(result, result[counter-1]+step)
  }
  
  result
}
  
  values.sc <- circlize::colorRamp2(calculate_range(min_value.sc, max_value.sc, 6), sc.bulk.cols.6.colors(6))
  values.bulk <- circlize::colorRamp2(calculate_range(min_value.bulk, max_value.bulk, 6), sc.bulk.cols.6.colors(6))
  
  #limit based on the limit set as minimum
  values.de.min <- min((bulk.data.wt.ko.de.filtered$log2FoldChange), na.rm = TRUE)
  values.de.max <- max(c(max((bulk.data.wt.ko.de.filtered$log2FoldChange), na.rm = TRUE),
                         abs(min(bulk.data.wt.ko.de.filtered$log2FoldChange, na.rm = TRUE))))
  print(paste0('min: ', values.de.min, 'max: ', values.de.max))
  values.de <- circlize::colorRamp2(calculate_range(values.de.min,
                                                    values.de.max, 6),
                                    sc.bulk.cols.6.colors(6))
  
  
  colour.rows.right.v2 <- list(sample_6W = values.sc,
                               Thy_WT_1 = values.bulk, Thy_WT_2 = values.bulk, Thy_WT_3 = values.bulk,
                               Tumor_ALKpos_WT_1 = values.bulk, Tumor_ALKpos_WT_2 = values.bulk, Tumor_ALKpos_WT_3 = values.bulk,
                               Tumor_ALKpos_WTa_4 = values.bulk, Tumor_ALKpos_WTa_5 = values.bulk, Tumor_ALKpos_WTa_6 = values.bulk, Tumor_ALKpos_WTa_7 = values.bulk,
                               Tumor_ALK_Hdac1_KO_1 = values.bulk, Tumor_ALK_Hdac1_KO_2 = values.bulk, Tumor_ALK_Hdac1_KO_3 = values.bulk, Tumor_ALK_Hdac1_KO_4 = values.bulk,
                               de =   values.de)
  
  ###################
  ha.rows.right.v2 <- rowAnnotation(
    sample_6W =   sc.bulk.data.scaled$sample_6W, 
    Thy_WT_1 = sc.bulk.data.scaled$Thy_WT_1, 
    Thy_WT_2 = sc.bulk.data.scaled$Thy_WT_2, 
    Thy_WT_3 = sc.bulk.data.scaled$Thy_WT_3, 
    Tumor_ALKpos_WT_1 = sc.bulk.data.scaled$Tumor_ALKpos_WT_1, 
    Tumor_ALKpos_WT_2 = sc.bulk.data.scaled$Tumor_ALKpos_WT_2, 
    Tumor_ALKpos_WT_3 = sc.bulk.data.scaled$Tumor_ALKpos_WT_3,
    Tumor_ALKpos_WTa_4 = sc.bulk.data.scaled$Tumor_ALKpos_WTa_4,
    Tumor_ALKpos_WTa_5 = sc.bulk.data.scaled$Tumor_ALKpos_WTa_5,
    Tumor_ALKpos_WTa_6 = sc.bulk.data.scaled$Tumor_ALKpos_WTa_6,
    Tumor_ALKpos_WTa_7 = sc.bulk.data.scaled$Tumor_ALKpos_WTa_7,
    Tumor_ALK_Hdac1_KO_1 = sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_1, 
    Tumor_ALK_Hdac1_KO_2 = sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_2, 
    Tumor_ALK_Hdac1_KO_3 = sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_3, 
    Tumor_ALK_Hdac1_KO_4 = sc.bulk.data.scaled$Tumor_ALK_Hdac1_KO_4, 
    de = bulk.data.wt.ko.de.filtered[match(top.markers.detailed_all$gene_name, rownames(bulk.data.wt.ko.de.filtered)), 'log2FoldChange'],
    col = colour.rows.right.v2,
    show_legend = c(rep(show_legends, 16))
  )
  
  
  
  #NORMAL CONFIGURATION
  if(scale_activated){
    data <- t(scale(t(as.matrix(sc.data.duplicated.all)), center = TRUE, scale = TRUE))
    data[is.nan(data)] <- 0
  }else{
    data <- t((t(as.matrix(sc.data.duplicated.all))))
  }


  # Combine the heatmap and the annotation
  heatmap.two.groups  <- Heatmap(data, name = "Markers",
                                 na_col = "grey",
                                 cluster_columns = FALSE,
                                 column_dend_reorder = FALSE,
                                 cluster_rows = TRUE,#
                                 row_dend_reorder = TRUE,#
                                 show_column_names = FALSE,
                                 row_km = row_km_value,
                                 column_split = column.values$column.names,
                                 row_split = top.markers.detailed_all$group,
                                 row_labels = top.markers.detailed_all$gene_name,
                                 row_names_gp = gpar(fontsize = 9),
                                 column_names_gp = gpar(fontsize = 7),
                                 left_annotation = ha.rows.left, 
                                 right_annotation = ha.rows.right.v2,
                                 top_annotation = ha.columns,
                                 column_dend_height = unit(90, "mm"), 
                                 row_dend_width =  unit(60, "mm"), 
                                 column_title_rot = 90,
                                 row_title = 'Marker genes'
  )
  
  print(heatmap.two.groups)
  
  return(list(sc.bulk.data = sc.bulk.data,
              sc.bulk.data.scaled = sc.bulk.data.scaled,
              bulk.data.wt.ko.de.filtered = bulk.data.wt.ko.de.filtered, 
              sc.data = data, 
              plot = heatmap.two.groups))
}
```

```{r data.markers.top.Hdac1.KO}
#Version with the marker dataset and the marker repited by celltype
top.level.1.markers.detailed_all.Hdac1.KO <- create_dataset_markers_multiple_levels(
  result_level_object = deco.actual.data.thymus.reduced.results.Hdac1.KO.complete,
  level_list = c('subcluster_level_1_leaf_1', 'subcluster_level_1_leaf_2', 'subcluster_level_1_leaf_3'))
```

Normal version
```{r heatmap.level.top.semireference.Hdac1.KO, fig.height=50, fig.width=20}

#Creation of genes for the new unknown celltype
top.level.1.markers.detailed_all.unknown.Hdac1.KO <- data.frame(cbind(extra_marker_genes_semireference.Hdac1.KO, 'subcluster_level_1_leaf_4', TRUE))
colnames(top.level.1.markers.detailed_all.unknown.Hdac1.KO) <- colnames(top.level.1.markers.detailed_all.Hdac1.KO$top.markers.detailed_all)
rownames(top.level.1.markers.detailed_all.unknown.Hdac1.KO) <- top.level.1.markers.detailed_all.unknown.Hdac1.KO$gene_name

#Adding those to the new one
top.level.1.markers.detailed_all.plus.unknow.Hdac1.KO <- rbind(top.level.1.markers.detailed_all.Hdac1.KO$top.markers.detailed_all,
                                                      top.level.1.markers.detailed_all.unknown.Hdac1.KO)



#fixing the pseudo
sc.pseudo.bulk.data.Hdac1.KO.top.df <- data.frame(sc.pseudo.bulk.data.Hdac1.KO.top) 
diff.pseudo.markers <- setdiff(top.level.1.markers.detailed_all.plus.unknow.Hdac1.KO$gene_name, rownames(sc.pseudo.bulk.data.Hdac1.KO.top.df))
length(diff.pseudo.markers) #147

#then I will add 147 fields with empty NA values to the pseudo
diff.dataset.pseudo <- data.frame("sample_6W"=rep(0, length(diff.pseudo.markers)))
rownames(diff.dataset.pseudo) <- diff.pseudo.markers

#Add the empty part with genes to the normal pseudo
sc.pseudo.bulk.data.Hdac1.KO.top.df.extended <- rbind(sc.pseudo.bulk.data.Hdac1.KO.top.df, diff.dataset.pseudo)



#fixing single cell




#Plot with heatmap level 1
plot.level.top.semireference.Hdac1.KO <- plot_heatmap_markers_multiple_level.Hdac1.KO(
                     sc.eset.metacluster.all = eset.sc.thymus.6.8.w.sparse.metacluster,
                     sc.bulk.data.filtered.tpm = data.frame(eset.thymus.bulk.sparse.expanded.tpm@assayData$exprs),
                     pseudo.bulk.df.filtered.tpm = data.frame(sc.pseudo.bulk.data.Hdac1.KO.top.df.extended),
                     res.object.de = RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT, 
                     top.markers.detailed_all = top.level.1.markers.detailed_all.plus.unknow.Hdac1.KO,
                     clustering_variable = 'cluster_normalized_bigstage',
                     list_cell_types = c(1:7), 
                     row_km_value = 1,
                     column.clusters = paste0('cluster_', 1:7),
                     color_left_groups = c("#D55E00", "#CC79A7", "skyblue", "darkgreen"), 
                     scale_activated = TRUE, 
                     show_legends = TRUE
                     ) 

#save_plot_as_pdf(plot.level.top.semireference.Hdac1.KO$plot, 'plot.level.top.semireference_de_Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT_v1.pdf', width.parameter= 20, height.parameter = 40)


```

```{r heatmap.bulk.data.Hdac1.KO, fig.width=7, fig.height=30}

standard_name_thymus.Hdac1.KO <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

data_filtered_bulk.Hdac1.KO <- plot.level.top.semireference.Hdac1.KO$sc.bulk.data.scaled[extra_marker_genes_semireference.Hdac1.KO, standard_name_thymus.Hdac1.KO]
data_filtered_bulk.Hdac1.KO <- na.omit(data_filtered_bulk.Hdac1.KO)

bulkdata.extra_marker.Hdac1.KO <- Heatmap(data_filtered_bulk.Hdac1.KO, name = "Markers",
                                 use_raster = FALSE,
                                 cluster_columns = TRUE,
                                 column_dend_reorder = TRUE,
                                 cluster_rows = TRUE,#
                                 row_dend_reorder = TRUE,#
                                 show_column_names = TRUE,
                                 row_km = 5,
                                 clustering_distance_rows = "pearson",
                                 column_split = c(rep('Thy_WT', 3),
                                                  rep('Tumor_ALKpos_WT', 3),
                                                  rep('Tumor_ALKpos_WTa', 4),
                                                  rep('Tumor_ALK_Hdac1_KO', 4)),
                                 #row_split = top.markers.detailed_all$group,
                                 #row_labels = top.markers.detailed_all$gene_name,
                                 row_names_gp = gpar(fontsize = 8),
                                 column_names_gp = gpar(fontsize = 7),
                                 #left_annotation = ha.rows.left, 
                                 #right_annotation = ha.rows.right.v2,
                                 #top_annotation = ha.columns,
                                 column_dend_height = unit(90, "mm"), 
                                 row_dend_width =  unit(60, "mm"), 
                                 column_title_rot = 90,
                                 row_title = 'Marker genes'
)

plot(bulkdata.extra_marker.Hdac1.KO)


row_dendrogram_order.Hdac1.KO <- row_dend(bulkdata.extra_marker.Hdac1.KO)
order_groups.Hdac1.KO <- lapply(row_order(bulkdata.extra_marker.Hdac1.KO), function(x) list(x))

group.1.Hdac1.KO <- unlist(order_groups.Hdac1.KO$'1')
group.2.Hdac1.KO <- unlist(order_groups.Hdac1.KO$'2')

group.1.names.Hdac1.KO <- bulkdata.extra_marker.Hdac1.KO@row_names_param$labels[group.1.Hdac1.KO]
paste(shQuote(group.1.names.Hdac1.KO, type="sh"), collapse=", ")

group.2.names.Hdac1.KO <- bulkdata.extra_marker.Hdac1.KO@row_names_param$labels[group.2.Hdac1.KO]
paste(shQuote(group.2.names.Hdac1.KO, type="sh"), collapse=", ")


```

## 7.2 Partial Deconvolution: CDs Hdac1 KO

Let's put together the marker genes from the flat deconvolution and the differential expressed genes.
```{r final.list.genes.Hdac1.KO.cds}
black_list_genes.Hdac1.KO.cds <- c() #Xist?
de_genes.thymus.total.Hdac1.KO.cds <- de_genes.thymus.Hdac1.treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT
de_genes.thymus.Hdac1.KO.cds <- de_genes.thymus.total.Hdac1.KO.cds[de_genes.thymus.total.Hdac1.KO.cds %in% black_list_genes.Hdac1.KO.cds == FALSE]

#Let's create the w reference with all the genes and then we could see which are shared with the final_markers_partial_model
# I don't use the one in the model becasue only has the marker genes in the reference and I need those  plus the Differential
# expressed ons
single_cell_data_exp.Hdac1.KO.cds <- eset.sc.thymus.6.8.w.sparse.metacluster
top_clusters_list = paste0('cluster_', c(6:7))
bulk_data = eset.thymus.bulk.sparse.expanded.df.filtered
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'

w_matrix_reference.Hdac1.KO.cds <- decoflex_build_cell_reference(
  x = single_cell_data_exp,
  ct.sub = top_clusters_list,
  ct.varname = sub_clusters_var,
  sample = sample,
  verbose = TRUE)

# sorting the results by columns
w_matrix_reference.basics.Hdac1.KO.cds <- w_matrix_reference.Hdac1.KO.cds$basis[, paste0('cluster_', c(6:7))]



#75
final_markers_partial_model.Hdac1.KO.cds <- c(de_genes.thymus.Hdac1.KO.cds, rownames(deco.actual.data.thymus.reduced.results.Hdac1.KO.complete$deco_results_list$subcluster_level_1_leaf_3$result_deco_top_cluster$w))

#75
final_markers_partial_model.Hdac1.KO.cds <- unique(final_markers_partial_model.Hdac1.KO.cds)
length(final_markers_partial_model.Hdac1.KO.cds)

diff.1.Hdac1.KO.cds <- setdiff(de_genes.thymus.Hdac1.KO.cds, final_markers_partial_model.Hdac1.KO.cds)

#46 (what???? why???)
shared.final.vs.w.Hdac1.KO.cds <- intersect(final_markers_partial_model.Hdac1.KO.cds, rownames(as.matrix(w_matrix_reference.basics.Hdac1.KO.cds)))
length(shared.final.vs.w.Hdac1.KO.cds)

#This are additional factors in the W matrix semireference
extra_marker_genes_semireference.Hdac1.KO.cds <- setdiff(de_genes.thymus.Hdac1.KO.cds, shared.final.vs.w.Hdac1.KO.cds)

final_markers_partial_model.Hdac1.KO.cds <- shared.final.vs.w.Hdac1.KO.cds


```

### 7.2.2. Creation of partial references: W and H

Now we can create the partial references with ONE fixed cell-type
```{r creation.mask.matrices.h.w.one.celltype.Hdac1.KO.cds}

standard_name_thymus.Hdac1.KO <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

# I have n genes as rows and m+1 columns, being the last one the unknown one. 
mask_h.Hdac1.KO.cds <- matrix(FALSE, nrow = (2+1), ncol = 14)
colnames(mask_h.Hdac1.KO.cds) <- standard_name_thymus.Hdac1.KO
rownames(mask_h.Hdac1.KO.cds) <- paste0('cluster_', c(6:7, 'unknown_1'))

# In this case, I can do two things: 1. Fix just the celltypes that I have as reference and the unknown leave it as black. 2. Assign the unknown cell-type as zero, since it suppose to be a WT, and then in the other conditions it will appear a proportion. Also the Tumor DNMT1 KO, will be similar to WT.
version <- 'two'
if(version=='one'){
  #Version 1.
  mask_h.Hdac1.KO.cds[1:2,1:3] <- TRUE
}else if(version=='two'){
  #Version 1.
  mask_h.Hdac1.KO.cds[1:3,1:3] <- TRUE
}




#Now let's put the proportions that I needed, filling with zeros the rest
partial_h_fixed.Hdac1.KO.cds <- matrix(0, nrow = (2+1), ncol = 14)
colnames(partial_h_fixed.Hdac1.KO.cds) <- standard_name_thymus.Hdac1.KO
rownames(partial_h_fixed.Hdac1.KO.cds) <- paste0('cluster_', c(6:7, 'unknown_1'))
#let's take the proportion
proportions_wt_single_cell.Hdac1.KO.cds <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.cds$pseudo.bulk.data$truep) 
colnames(proportions_wt_single_cell.Hdac1.KO.cds) <- c('sample_6_8W')
proportions_wt_single_cell.Hdac1.KO.cds <- t(proportions_wt_single_cell.Hdac1.KO.cds)
proportions_wt_single_cell.Hdac1.KO.cds['sample_6_8W', paste0('cluster_', c(6:7)) ]

#Scale to 1
proportions_wt_single_cell.Hdac1.KO.cds['sample_6_8W', paste0('cluster_', c(6:7))] <- proportions_wt_single_cell.Hdac1.KO.cds['sample_6_8W', paste0('cluster_', c(6:7))]/sum(proportions_wt_single_cell.Hdac1.KO.cds['sample_6_8W', paste0('cluster_', c(6:7))])

#Since I have three replicates I have to fix the proportions three times
partial_h_fixed.Hdac1.KO.cds[1:2,1] <- as.matrix(proportions_wt_single_cell.Hdac1.KO.cds['sample_6_8W', paste0('cluster_', c(6:7)) ])
partial_h_fixed.Hdac1.KO.cds[1:2,2] <- as.matrix(proportions_wt_single_cell.Hdac1.KO.cds['sample_6_8W', paste0('cluster_', c(6:7)) ])
partial_h_fixed.Hdac1.KO.cds[1:2,3] <- as.matrix(proportions_wt_single_cell.Hdac1.KO.cds['sample_6_8W', paste0('cluster_', c(6:7)) ])





#Now I will create the W
mask_w.Hdac1.KO.cds <- matrix(TRUE, 
                 nrow = (length(final_markers_partial_model.Hdac1.KO.cds) + length(extra_marker_genes_semireference.Hdac1.KO.cds)), 
                 ncol = 3)
colnames(mask_w.Hdac1.KO.cds) <- paste0('cluster_', c(6:7, 'unknown_1'))
rownames(mask_w.Hdac1.KO.cds) <- c(final_markers_partial_model.Hdac1.KO.cds, extra_marker_genes_semireference.Hdac1.KO.cds)
mask_w.Hdac1.KO.cds[(length(final_markers_partial_model.Hdac1.KO.cds)+1):nrow(mask_w.Hdac1.KO.cds), 1:3] <- FALSE
mask_w.Hdac1.KO.cds[1:length(final_markers_partial_model.Hdac1.KO.cds), 3] <- FALSE

# I have k cell-types rows by m samples. I want to add the same proportions to the first three wild-type samples corresponding to the 
# '6_8W' time points
partial_w_fixed.Hdac1.KO.cds <- matrix(0, 
                          nrow = (length(final_markers_partial_model.Hdac1.KO.cds) + length(extra_marker_genes_semireference.Hdac1.KO.cds)), 
                          ncol = 3)
colnames(partial_w_fixed.Hdac1.KO.cds) <- paste0('cluster_', c(6:7, 'unknown_1'))
rownames(partial_w_fixed.Hdac1.KO.cds) <-  c(final_markers_partial_model.Hdac1.KO.cds, extra_marker_genes_semireference.Hdac1.KO.cds)

#Let's filter the w matrix reference (partially)
w_matrix_reference_basis_fixed.Hdac1.KO.cds <- as.data.frame(w_matrix_reference.Hdac1.KO.cds$basis)
w_matrix_reference_basis_fixed.Hdac1.KO.cds <- w_matrix_reference_basis_fixed.Hdac1.KO.cds[final_markers_partial_model.Hdac1.KO.cds, ]

partial_w_fixed.Hdac1.KO.cds[1:length(final_markers_partial_model.Hdac1.KO.cds), 1:2] <- as.matrix(w_matrix_reference_basis_fixed.Hdac1.KO.cds)

```



### 7.2.3. Running deconvolution with partial reference model

Finally we can put together the model and run the partial conditioned deconvolution model to see if that work
```{r flat.deconvolution.partial.references.Hdac1.KO.cds}

order_normalized <- paste0('cluster_', c(6:7))

standard_name_thymus.Hdac1.KO <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.cds <- data.frame(as.matrix(eset.thymus.bulk.sparse.expanded.tpm@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.cds[is.na(eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.cds)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.cds[eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.cds==0] <- 0.0000000001

proportion_constraint_h.Hdac1.KO.cds = TRUE

start_time <- Sys.time()

# I run the deconvolution without any other parameter
deco.alpha.beta.zero.results.partial.Hdac1.KO.cds <- run_complete_deconvolution(
  x_matrix = data.frame(eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.cds[c(final_markers_partial_model.Hdac1.KO.cds, extra_marker_genes_semireference.Hdac1.KO.cds), standard_name_thymus.Hdac1.KO]),
  y_matrix = NULL,
  z_matrix = NULL,
  k = 3,
  alpha = 0, 
  beta = 0,
  delta_threshold=1e-10, 
  max_iterations=10000, 
  #I have to deactivate the sum 1 because that is just for the 3 cell types
  proportion_constraint_h = proportion_constraint_h.Hdac1.KO.cds,
  partial_w_fixed=data.frame(partial_w_fixed.Hdac1.KO.cds[c(final_markers_partial_model.Hdac1.KO.cds, extra_marker_genes_semireference.Hdac1.KO.cds), ]),
  partial_h_fixed=data.frame(partial_h_fixed.Hdac1.KO.cds[, standard_name_thymus.Hdac1.KO]),
  w_mask_fixed=data.frame(mask_w.Hdac1.KO.cds),
  h_mask_fixed=data.frame(mask_h.Hdac1.KO.cds[, standard_name_thymus.Hdac1.KO]),
  batches_partial_fixed=1)

end_time <- Sys.time()
end_time - start_time
```
Analysis of proportions
```{r proportions.assignment.Hdac1.KO.cds}
colSums(deco.alpha.beta.zero.results.partial.Hdac1.KO.cds$h[1:2,])

prop_recal.Hdac1.KO.cds <- deco.alpha.beta.zero.results.partial.Hdac1.KO.cds$h

sum(prop_recal.Hdac1.KO.cds[1:2,1:3])

if(proportion_constraint_h.Hdac1.KO.cds){
  
}else{
  prop_recal.Hdac1.KO.cds[1:2, ] <- prop_recal.Hdac1.KO.cds[1:2, ]/colSums(prop_recal.Hdac1.KO.cds[1:2, ])
}

prop_recal.recal.Hdac1.KO.cds <- sweep(prop_recal.Hdac1.KO.cds,2,colSums(prop_recal.Hdac1.KO.cds),FUN="/")
colSums(prop_recal.recal.Hdac1.KO.cds)
prop_recal.Hdac1.KO.cds <- prop_recal.recal.Hdac1.KO.cds

prop_recal.Hdac1.KO.cds
```


### 5.1.4. Plot with semireference model proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion.flat.model.Hdac1.KO.cds}

plot.Hdac1.KO.cds <- plot_proportions_semireference_hdac1_ko(real_proportion.parameter =  as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.cds$pseudo.bulk.data$truep), 
                                        prop_recal=prop_recal.Hdac1.KO.cds, 
                                        order_normalized = paste0('cluster_', c('6','7', 'unknown_1')), 
                                        list_pseudotime = c('CD4', 'CD8', 'unknown_1'), 
                                        extra_unknown_celltypes =1)
plot(plot.Hdac1.KO.cds)

#save_plot_as_pdf(plot.Hdac1.KO.cds, 'plot_proportions_cds_semireference_de_Thy_ALKpos_KO_vs_Thy_WT.Hdac1_KO.pdf', 8, 5)
```

```{r data.markers.Hdac1.KO.cds}
#Version with the marker dataset and the marker repited by celltype
top.level.1.markers.detailed.Hdac1.KO.cds <- create_dataset_markers_multiple_levels(
  result_level_object = deco.actual.data.thymus.reduced.results.Hdac1.KO.complete$deco_results_list$subcluster_level_1_leaf_3,
  level_list = c('cluster_6', 'cluster_7'))
```

```{r heatmap.level.cds.semireference, fig.height=40, fig.width=15}

#Creation of genes for the new unknown celltype
top.level.1.markers.detailed_cds.unknown.Hdac1.KO <- data.frame(cbind(extra_marker_genes_semireference.Hdac1.KO, 'cluster_unknown', TRUE))
colnames(top.level.1.markers.detailed_cds.unknown.Hdac1.KO) <- colnames(top.level.1.markers.detailed.Hdac1.KO.cds$top.markers.detailed_all)
rownames(top.level.1.markers.detailed_cds.unknown.Hdac1.KO) <- top.level.1.markers.detailed_cds.unknown.Hdac1.KO$gene_name

#Adding those to the new one
top.level.1.markers.detailed_cds.plus.unknown.Hdac1.KO <- rbind(top.level.1.markers.detailed.Hdac1.KO.cds$top.markers.detailed_all,
                                                      top.level.1.markers.detailed_cds.unknown.Hdac1.KO)

#Plot with heatmap level 1
plot.level.cds.semireference.Hdac1.KO <- plot_heatmap_markers_multiple_level(
                     sc.eset.metacluster.all = eset.sc.thymus.6.8.w.sparse.metacluster,
                     sc.bulk.data.filtered.tpm = eset.thymus.bulk.sparse.expanded.df.filtered,
                     pseudo.bulk.df.filtered.tpm = sc.pseudo.bulk.data.Hdac1.KO.cds,
                     res.object.de = RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT, 
                     top.markers.detailed_all = top.level.1.markers.detailed_cds.plus.unknown.Hdac1.KO,
                     clustering_variable = 'cluster_normalized_bigstage',
                     list_cell_types = c(6:7), 
                     row_km_value = 1,
                     column.clusters = paste0('cluster_', 6:7),
                     color_left_groups = c("#D55E00", "#CC79A7", "skyblue", "darkgreen"), 
                     scale_activated = TRUE, 
                     show_legends = TRUE
                     )

#save_plot_as_pdf(plot.level.cds.semireference.Hdac1.KO$plot, 'plot.level.cds.semireference.Hdac1.KO_de_Thy_ALKpos_KO_vs_Thy_WT.pdf', 20, 15)


```

## 7.3 Partial Deconvolution: DP Hdac1 KO

Let's put together the marker genes from the flat deconvolution and the differential expressed genes.
```{r final.list.genes.Hdac1.KO.dp}
black_list_genes.Hdac1.KO.dp <- c() #Xist?
de_genes.thymus.total.Hdac1.KO.dp <- de_genes.thymus.Hdac1.KO.treatment.Hdac1.KO_Thy_ALKpos_WT_vs_Thy_WT
de_genes.thymus.Hdac1.KO.dp <- de_genes.thymus.total.Hdac1.KO.dp[de_genes.thymus.total.Hdac1.KO.dp %in% black_list_genes.Hdac1.KO.dp == FALSE]

#Let's create the w reference with all the genes and then we could see which are shared with the final_markers_partial_model
# I don't use the one in the model becasue only has the marker genes in the reference and I need those  plus the Differential
# expressed ons
single_cell_data_exp <- eset.sc.thymus.6.8.w.sparse.metacluster
top_clusters_list = paste0('cluster_', c(2:5))
bulk_data = eset.thymus.bulk.sparse.df.filtered.Hdac1.KO
sub_clusters_var <- 'cluster_normalized_bigstage'
sample <- 'age'

w_matrix_reference.Hdac1.KO.dp <- decoflex_build_cell_reference(
  x = single_cell_data_exp,
  ct.sub = top_clusters_list,
  ct.varname = sub_clusters_var,
  sample = sample,
  verbose = TRUE)

# sorting the results by columns
w_matrix_reference.basics.Hdac1.KO.dp <- w_matrix_reference.Hdac1.KO.dp$basis[, paste0('cluster_', c(2:5))]



#75
final_markers_partial_model.Hdac1.KO.dp <- c(de_genes.thymus.Hdac1.KO.dp, rownames(deco.actual.data.thymus.reduced.results.Hdac1.KO.complete$deco_results_list$subcluster_level_1_leaf_2$result_deco_top_cluster$w))

#75
final_markers_partial_model.Hdac1.KO.dp <- unique(final_markers_partial_model.Hdac1.KO.dp)
length(final_markers_partial_model.Hdac1.KO.dp)

diff.1 <- setdiff(de_genes.thymus.Hdac1.KO.dp, final_markers_partial_model.Hdac1.KO.dp)

#46 (what???? why???)
shared.final.vs.w.Hdac1.KO.dp <- intersect(final_markers_partial_model.Hdac1.KO.dp, rownames(as.matrix(w_matrix_reference.basics.Hdac1.KO.dp)))
length(shared.final.vs.w.Hdac1.KO.dp)

#This are additional factors in the W matrix semireference
extra_marker_genes_semireference.Hdac1.KO.dp <- setdiff(de_genes.thymus.Hdac1.KO.dp, shared.final.vs.w.Hdac1.KO.dp)

final_markers_partial_model.Hdac1.KO.dp <- shared.final.vs.w.Hdac1.KO.dp


```

### 7.2.2. Creation of partial references: W and H

Now we can create the partial references with ONE fixed cell-type
```{r creation.mask.matrices.h.w.one.celltype.Hdac1.KO.dp}

# I have n genes as rows and m+1 columns, being the last one the unknown one. 
mask_h.Hdac1.KO.dp <- matrix(FALSE, nrow = (4+1), ncol = 14)
colnames(mask_h.Hdac1.KO.dp) <- standard_name_thymus.Hdac1.KO
rownames(mask_h.Hdac1.KO.dp) <- paste0('cluster_', c(2:5, 'unknown_1'))

# In this case, I can do two things: 1. Fix just the celltypes that I have as reference and the unknown leave it as black. 2. Assign the unknown cell-type as zero, since it suppose to be a WT, and then in the other conditions it will appear a proportion. Also the Tumor DNMT1 KO, will be similar to WT.
version <- 'two'
if(version=='one'){
  #Version 1.
  mask_h.Hdac1.KO.dp[1:4,1:3] <- TRUE
}else if(version=='two'){
  #Version 1.
  mask_h.Hdac1.KO.dp[1:5,1:3] <- TRUE
}




#Now let's put the proportions that I needed, filling with zeros the rest
partial_h_fixed.Hdac1.KO.dp <- matrix(0, nrow = (4+1), ncol = 14)
colnames(partial_h_fixed.Hdac1.KO.dp) <- standard_name_thymus.Hdac1.KO
rownames(partial_h_fixed.Hdac1.KO.dp) <- paste0('cluster_', c(2:5, 'unknown_1'))
#let's take the proportion
proportions_wt_single_cell.Hdac1.KO.dp <- as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.dp$pseudo.bulk.data$truep) 
colnames(proportions_wt_single_cell.Hdac1.KO.dp) <- c('sample_6_8W')
proportions_wt_single_cell.Hdac1.KO.dp <- t(proportions_wt_single_cell.Hdac1.KO.dp)
proportions_wt_single_cell.Hdac1.KO.dp['sample_6_8W', paste0('cluster_', c(2:5)) ]

#Scale to 1
proportions_wt_single_cell.Hdac1.KO.dp['sample_6_8W', paste0('cluster_', c(2:5))] <- proportions_wt_single_cell.Hdac1.KO.dp['sample_6_8W', paste0('cluster_', c(2:5))]/sum(proportions_wt_single_cell.Hdac1.KO.dp['sample_6_8W', paste0('cluster_', c(2:5))])

#Since I have three replicates I have to fix the proportions three times
partial_h_fixed.Hdac1.KO.dp[1:4,1] <- as.matrix(proportions_wt_single_cell.Hdac1.KO.dp['sample_6_8W', paste0('cluster_', c(2:5)) ])
partial_h_fixed.Hdac1.KO.dp[1:4,2] <- as.matrix(proportions_wt_single_cell.Hdac1.KO.dp['sample_6_8W', paste0('cluster_', c(2:5)) ])
partial_h_fixed.Hdac1.KO.dp[1:4,3] <- as.matrix(proportions_wt_single_cell.Hdac1.KO.dp['sample_6_8W', paste0('cluster_', c(2:5)) ])





#Now I will create the W
mask_w.Hdac1.KO.dp <- matrix(TRUE, 
                 nrow = (length(final_markers_partial_model.Hdac1.KO.dp) + length(extra_marker_genes_semireference.Hdac1.KO.dp)), 
                 ncol = (4+1))
colnames(mask_w.Hdac1.KO.dp) <- paste0('cluster_', c(2:5, 'unknown_1'))
rownames(mask_w.Hdac1.KO.dp) <- c(final_markers_partial_model.Hdac1.KO.dp, extra_marker_genes_semireference.Hdac1.KO.dp)
mask_w.Hdac1.KO.dp[(length(final_markers_partial_model.Hdac1.KO.dp)+1):nrow(mask_w.Hdac1.KO.dp), 1:5] <- FALSE
mask_w.Hdac1.KO.dp[1:length(final_markers_partial_model.Hdac1.KO.dp), (4+1)] <- FALSE

# I have k cell-types rows by m samples. I want to add the same proportions to the first three wild-type samples corresponding to the 
# '6_8W' time points
partial_w_fixed.Hdac1.KO.dp <- matrix(0, 
                          nrow = (length(final_markers_partial_model.Hdac1.KO.dp) + length(extra_marker_genes_semireference.Hdac1.KO.dp)), 
                          ncol = (4+1))
colnames(partial_w_fixed.Hdac1.KO.dp) <- paste0('cluster_', c(2:5, 'unknown_1'))
rownames(partial_w_fixed.Hdac1.KO.dp) <-  c(final_markers_partial_model.Hdac1.KO.dp, extra_marker_genes_semireference.Hdac1.KO.dp)

#Let's filter the w matrix reference (partially)
w_matrix_reference_basis_fixed.Hdac1.KO.dp <- as.data.frame(w_matrix_reference.Hdac1.KO.dp$basis)
w_matrix_reference_basis_fixed.Hdac1.KO.dp <- w_matrix_reference_basis_fixed.Hdac1.KO.dp[final_markers_partial_model.Hdac1.KO.dp, ]

partial_w_fixed.Hdac1.KO.dp[1:length(final_markers_partial_model.Hdac1.KO.dp), 1:4] <- as.matrix(w_matrix_reference_basis_fixed.Hdac1.KO.dp)

```

### 7.2.3. Running deconvolution with partial reference model


Finally we can put together the model and run the partial conditioned deconvolution model to see if that work
```{r flat.deconvolution.partial.references.Hdac1.KO.dp}

order_normalized.Hdac1.KO.dp <- paste0('cluster_', c(2:5))

#Only WT and tumor
standard_name_thymus.Hdac1.KO <- c("Thy_WT_1", "Thy_WT_2", "Thy_WT_3", 
                     "Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7",
                     'Tumor_ALK_Hdac1_KO_1',  'Tumor_ALK_Hdac1_KO_2', 'Tumor_ALK_Hdac1_KO_3', 'Tumor_ALK_Hdac1_KO_4')

#Replacing zeros and nulls with a small value.
eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.dp <- data.frame(as.matrix(eset.thymus.bulk.sparse.expanded.tpm@assayData$exprs))
eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.dp[is.na(eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.dp)] <- 0.0000000001
eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.dp[eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.dp==0] <- 0.0000000001


proportion_constraint_h.Hdac1.KO.dp = TRUE

start_time <- Sys.time()

# I run the deconvolution without any other parameter
deco.alpha.beta.zero.results.partial.Hdac1.KO.dp <- run_complete_deconvolution(
  x_matrix = data.frame(eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.dp[c(final_markers_partial_model.Hdac1.KO.dp, extra_marker_genes_semireference.Hdac1.KO.dp), standard_name_thymus.Hdac1.KO]),
  y_matrix = NULL,
  z_matrix = NULL,
  k = 5,
  alpha = 0, 
  beta = 0,
  delta_threshold=1e-10, 
  max_iterations=8000, 
  #I have to deactivate the sum 1 because that is just for the 3 cell types
  proportion_constraint_h = proportion_constraint_h.Hdac1.KO.dp,
  partial_w_fixed=data.frame(partial_w_fixed.Hdac1.KO.dp[c(final_markers_partial_model.Hdac1.KO.dp, extra_marker_genes_semireference.Hdac1.KO.dp), ]),
  partial_h_fixed=data.frame(partial_h_fixed.Hdac1.KO.dp[, standard_name_thymus.Hdac1.KO]),
  w_mask_fixed=data.frame(mask_w.Hdac1.KO.dp[,]),
  h_mask_fixed=data.frame(mask_h.Hdac1.KO.dp[, standard_name_thymus.Hdac1.KO]),
  batches_partial_fixed=1)

end_time <- Sys.time()
end_time - start_time
```

Analysis of proportions
```{r proportions.assignment.Hdac1.KO.dp}
colSums(deco.alpha.beta.zero.results.partial.Hdac1.KO.dp$h[1:4,])

prop_recal.Hdac1.KO.dp <- deco.alpha.beta.zero.results.partial.Hdac1.KO.dp$h

sum(prop_recal.Hdac1.KO.dp[1:4,1:5])

if(proportion_constraint_h.Hdac1.KO.dp){
  
}else{
  prop_recal.Hdac1.KO.dp[1:4, ] <- prop_recal.Hdac1.KO.dp[1:4, ]/colSums(prop_recal.Hdac1.KO.dp[1:4, ])
}

prop_recal.recal.Hdac1.KO.dp <- sweep(prop_recal.Hdac1.KO.dp,2,colSums(prop_recal.Hdac1.KO.dp),FUN="/")
colSums(prop_recal.recal.Hdac1.KO.dp)
prop_recal.Hdac1.KO.dp <- prop_recal.recal.Hdac1.KO.dp

prop_recal.Hdac1.KO.dp
```


### 7.1.4. Plot with semireference model proportions

Comparison between the actual proportions of the single-cell data and the estimated proportions of the bulk thymus data, specifically with the Ctrl sample.
```{r plot_comparison_ctrl_proportion.flat.model.Hdac1.KO.dp}

plot.Hdac1.KO.dp <- plot_proportions_semireference_hdac1_ko(real_proportion.parameter =  as.data.frame(deco.simulation.thymus.tree_guided.recursive.reduced.results.Hdac1.KO.dp$pseudo.bulk.data$truep), 
                                        prop_recal=prop_recal.Hdac1.KO.dp, 
                                        order_normalized = paste0('cluster_', c('2','3', '4', '5', 'unknown_1')), 
                                        list_pseudotime = list_pseudotime <- c("2preDP", "3DPbla", "4DPre", "5DPsel", 'unknown_1'), 
                                        extra_unknown_celltypes =1)
plot(plot.Hdac1.KO.dp)

#save_plot_as_pdf(plot.Hdac1.KO.dp, 'plot_proportions_dp_semireference_de_Thy_ALKpos_KO_vs_Thy_WT.Hdac1_KO.pdf', 8, 5)

```




```{r data.markers.Hdac1.KO.dp}
#Version with the marker dataset and the marker repited by celltype
top.level.1.markers.detailed.Hdac1.KO.dp <- create_dataset_markers_multiple_levels(
  result_level_object = deco.actual.data.thymus.reduced.results.Hdac1.KO.complete$deco_results_list$subcluster_level_1_leaf_2,
  level_list = paste0('cluster_', 2:5))
```

```{r heatmap.level.dp.semireference.Hdac1.KO.dp, fig.height=30, fig.width=15}

#Creation of genes for the new unknown celltype
top.level.1.markers.detailed_dp.unknown.Hdac1.KO.dp <- data.frame(cbind(extra_marker_genes_semireference.Hdac1.KO.dp, 'cluster_unknown_1', TRUE))
colnames(top.level.1.markers.detailed_dp.unknown.Hdac1.KO.dp) <- colnames(top.level.1.markers.detailed.Hdac1.KO.dp$top.markers.detailed_all)
rownames(top.level.1.markers.detailed_dp.unknown.Hdac1.KO.dp) <- top.level.1.markers.detailed_dp.unknown.Hdac1.KO.dp$gene_name

#Adding those to the new one
top.level.1.markers.detailed_dp.plus.unknown.Hdac1.KO.dp <- rbind(top.level.1.markers.detailed.Hdac1.KO.dp$top.markers.detailed_all,
                                                      top.level.1.markers.detailed_dp.unknown.Hdac1.KO.dp)

#Plot with heatmap level 1
plot.level.dp.semireference.Hdac1.KO.dp <- plot_heatmap_markers_multiple_level(
                     sc.eset.metacluster.all = eset.sc.thymus.6.8.w.sparse.metacluster,
                     sc.bulk.data.filtered.tpm = eset.thymus.bulk.sparse.df.filtered.Hdac1.KO.dp,
                     pseudo.bulk.df.filtered.tpm = sc.pseudo.bulk.data.Hdac1.KO.dp,
                     res.object.de = RES.thymus.lfc.Hdac1.KO$treatment.Hdac1.KO_Tumor_ALK_Hdac1_KO_vs_Thy_WT, 
                     top.markers.detailed_all = top.level.1.markers.detailed_dp.plus.unknown.Hdac1.KO.dp,
                     clustering_variable = 'cluster_normalized_bigstage',
                     list_cell_types = c(2:5), 
                     row_km_value = 2,
                     column.clusters = paste0('cluster_', 2:5),
                     color_left_groups = c("#D55E00", "#CC79A7", "skyblue", "darkgreen"), 
                     scale_activated = TRUE, 
                     show_legends = TRUE
                     )

#save_plot_as_pdf(plot.level.dp.semireference$plot, 'plot.level.dp.semireference_de_Thy_Thy_KO_vs_Thy_WT.pdf', 20, 15)


```

# 8. Differencial expression analysis: Tumor_ALKpos_WT.Dnmt1.KO VS Tumor_ALKpos_WT.Hdac1.KO

Since we found in analysis 7.0 and 7.0.1 that Tumor_ALKpos_WT samples from the DNMT1 KO look different in comparison to the ones in the Hdac1_KO, I will complete a DE between both types of samples, therefore, if there is a significant difference, I would see a lot of genes differentialy expressed, which is not expected in similar samples
```{r differential.expression.analysis.thymus.Tumor_ALKpos_WT.Dnmt1.KO.vs.Hdac1.KO}

standard_name_thymus.Tumor_ALKpos_WT <- c("Tumor_ALKpos_WT_1", "Tumor_ALKpos_WT_2", "Tumor_ALKpos_WT_3", 
                     "Tumor_ALKpos_WTa_4", "Tumor_ALKpos_WTa_5", "Tumor_ALKpos_WTa_6", "Tumor_ALKpos_WTa_7")

countdata.Tumor_ALKpos_WT <- as.matrix(eset.thymus.bulk.sparse.expanded.counts@assayData$exprs)
countdata.Tumor_ALKpos_WT <- countdata.Tumor_ALKpos_WT[,standard_name_thymus.Tumor_ALKpos_WT]

#I put numbers on it because other wise I wouldn't get  ko vs wt.
type.Tumor_ALKpos_WT <- c("tumor_dnmt1_ko","tumor_dnmt1_ko","tumor_dnmt1_ko",
          "tumor_hdac1_ko","tumor_hdac1_ko","tumor_hdac1_ko","tumor_hdac1_ko")

treatment.Tumor_ALKpos_WT <- c("Tumor_ALK_Dnmt1_KO","Tumor_ALK_Dnmt1_KO","Tumor_ALK_Dnmt1_KO", 
                 "Tumor_ALK_Hdac1_KO","Tumor_ALK_Hdac1_KO","Tumor_ALK_Hdac1_KO","Tumor_ALK_Hdac1_KO"
                 )

#treatment.Tumor_ALKpos_WT <- as.factor(treatment.Tumor_ALKpos_WT)

time.Tumor_ALKpos_WT <- c("18w","18w","18w",
          "18w","18w","18w","18w")

replicates.Tumor_ALKpos_WT  <- c("1","2","3",
                 "1","2","3", "4")

batch.Tumor_ALKpos_WT  <- c("1","1","1",
                 "2","2","2","2")

#batch.Tumor_ALKpos_WT <- as.factor(batch.Tumor_ALKpos_WT)

#secondary information
sample.Tumor_ALKpos_WT <- paste0("count_", 1:7)

coldata.Tumor_ALKpos_WT <- as.data.frame(cbind(replicates.Tumor_ALKpos_WT, treatment.Tumor_ALKpos_WT, time.Tumor_ALKpos_WT, sample.Tumor_ALKpos_WT, type.Tumor_ALKpos_WT, batch.Tumor_ALKpos_WT))
rownames(coldata.Tumor_ALKpos_WT) <- NULL

#building the object DESeqDataSet
ddsFullCountTable.Tumor_ALKpos_WT <- DESeqDataSetFromMatrix(
  countData = countdata.Tumor_ALKpos_WT,
  colData = coldata.Tumor_ALKpos_WT,
  design = ~treatment.Tumor_ALKpos_WT)

#giving the order and setting the control sample for the analyisis, which is - in this case - the real Tumor_ALKpos_WT.
ddsFullCountTable.Tumor_ALKpos_WT$treatment.Tumor_ALKpos_WT <- factor(ddsFullCountTable.Tumor_ALKpos_WT$treatment.Tumor_ALKpos_WT, levels = c("Tumor_ALK_Dnmt1_KO", "Tumor_ALK_Hdac1_KO"))

  
dds.Tumor_ALKpos_WT <- ddsFullCountTable.Tumor_ALKpos_WT

## Pre-filter
dds.Tumor_ALKpos_WT <- dds.Tumor_ALKpos_WT[ rowSums(counts(dds.Tumor_ALKpos_WT)) > 1, ]

## The rlog and variance stabilizing transformations => homoskedastic data
rld.Tumor_ALKpos_WT <- rlog(dds.Tumor_ALKpos_WT, blind = FALSE)
vsd.Tumor_ALKpos_WT <- vst(dds.Tumor_ALKpos_WT, blind = FALSE)
dds.Tumor_ALKpos_WT <- estimateSizeFactors(dds.Tumor_ALKpos_WT)
normalized.wt.bulk.Tumor_ALKpos_WT <- counts(dds.Tumor_ALKpos_WT, normalized=TRUE)

#Checking the new values
assay(vsd.Tumor_ALKpos_WT)[1:2,]
countdata.Tumor_ALKpos_WT[1:2,]


dds.Tumor_ALKpos_WT <- DESeq(dds.Tumor_ALKpos_WT)
resultsNames(dds.Tumor_ALKpos_WT)

res.Tumor_ALKpos_WT <- results(dds.Tumor_ALKpos_WT)

  
RES.thymus.lfc.Tumor_ALKpos_WT <- list(Intercept = results(dds.Tumor_ALKpos_WT, name = "Intercept"),
                       treatment.Tumor_ALKpos_WT_Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO = results(dds.Tumor_ALKpos_WT, name = "treatment.Tumor_ALKpos_WT_Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO"))


RES.thymus.lfc.Tumor_ALKpos_WT
```

```{r de.genes}

de.Tumor_ALKpos_WT <- data.frame(RES.thymus.lfc.Tumor_ALKpos_WT$treatment.Tumor_ALKpos_WT_Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO)

de.Tumor_ALKpos_WT[de.Tumor_ALKpos_WT$padj <= 0.05 & de.Tumor_ALKpos_WT$log2FoldChange > 2.0,]



#now lets check the genes that I should include
select_markers_de.df <- function(de_object, log2FoldChange = 7.5){
  de_object[which(abs(de_object$log2FoldChange) >= log2FoldChange & de_object$padj <= 0.05),]
}

de.Tumor_ALKpos_WT.filtered <- select_markers_de.df(de.Tumor_ALKpos_WT, 2.0)
de.Tumor_ALKpos_WT.filtered$gene_name <- rownames(de.Tumor_ALKpos_WT.filtered)

library("writexl")
path.excel <- '/Users/crhisto/Documents/GitHub/DecoFlex/DecoFlexR/vignettes/figures_manuscript/'
write_xlsx(de.Tumor_ALKpos_WT.filtered, paste0(path.excel, "de.Tumor_ALKpos_WT.filtered.xlsx"))


```


```{r volcano_plot.Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO, fig.width=10, fig.height=9}
Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO_res <- results(dds.Tumor_ALKpos_WT, name = "treatment.Tumor_ALKpos_WT_Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO")
volcano_plot.Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO <- EnhancedVolcano(Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO_res,
  lab = rownames(Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO_res),
  FCcutoff = 2.0,
  title = 'Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO_res',
  x = 'log2FoldChange',
  y = 'pvalue')
print(volcano_plot.Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO)

#save_plot_as_pdf(volcano_plot.Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO, 'volcano_plot.Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO.pdf', 10, 9)

```

```{r pca.Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO, fig.width=5, fig.height=5}
plotPCA.Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO <- plotPCA(vsd.Tumor_ALKpos_WT, intgroup=c("treatment.Tumor_ALKpos_WT")) + coord_fixed(ratio = 5)
plot(plotPCA.Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO)

save_plot_as_pdf(plotPCA.Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO, 'plotPCA.Tumor_ALK_Hdac1_KO_vs_Tumor_ALK_Dnmt1_KO.pdf', 5, 5)

```


```{r}
target <- matrix(1:4,nrow=2)
target

input_1 <- target
input_1[1:2,2] <- 0
input_1
input_2 <- target
input_2[1:2, 1] <- 0
input_2

sum_1_2 <- input_1 + input_2
sum_1_2
```

